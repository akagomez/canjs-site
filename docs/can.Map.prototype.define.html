<!DOCTYPE html>

<!--[if lt IE 7]>
<html class="no-js ie lt-ie9 lt-ie8 lt-ie7" lang="en">
<![endif]-->
<!--[if IE 7]>
<html class="no-js ie lt-ie9 lt-ie8" lang="en">
<![endif]-->
<!--[if IE 8]>
<html class="no-js ie lt-ie9" lang="en">
<![endif]-->
<!--[if IE 9]>
<html class="no-js ie ie9" lang="en">
<![endif]-->
<!--[if gt IE 9]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->
<head>
	<meta charset="utf-8">
	<title>CanJS - define </title>
	<meta name="description" content="">
	<meta name="author" content="">

	
	<link rel="stylesheet" type="text/css" href="./static/bundles/static.css">
	
	<!--[if lt IE 9]>
   <script type="text/javascript" src="static/html5shiv.js"></script>
    <!--<![endif]-->
</head>

<body class="docs ">
	<header>
		<nav class="container">

			<div class="logo-menu">
				<a class="brand" href="../index.html">CanJS</a>
				<ul class="dropdown-menu">
		          <li><a href="http://javascriptmvc.com">JavaScriptMVC</a></li>
		          <li><a href="http://canjs.com" class="active">CanJS</a></li>
		          <li><a href="http://jquerypp.com">jQuery++</a></li>
		          <li><a href="http://stealjs.com">StealJS</a></li>
		          <li><a href="http://funcunit.com">FuncUnit</a></li>
		          <li><a href="http://documentjs.com">DocumentJS</a></li>
		        </ul>
			</div>
			
			<ul class="nav">
		        <li >
	              <a href="../index.html">Home</a>
                </li>
		       <li><a href='../guides/index.html'>guides</a></li>
		       <li class='active'><a href='index.html'>api</a></li>
		        <li class=" community-menu">
		          <a href="../community.html#!forums">Community</a>
		          <ul class="dropdown-menu">
		            <li><a href="https://forum.javascriptmvc.com/canjs">Forums</a></li>
		            <li><a href="http://webchat.freenode.net/?channels=canjs">IRC</a></li>
		            <li><a href="http://bithub.com/canjs/app/">Apps</a></li>
		            <li><a href="http://bithub.com/canjs/plugin/">Plugins</a></li>
		            <li><a href="http://bithub.com/canjs/article/">Articles</a></li>
		            <li><a href="http://github.com/bitovi/canjs">Github</a></li>
		            <li><a href="http://twitter.com/canjs">Twitter</a></li>
		            <li><a href="http://bitovi.github.io/canjsmeetup/">Meetups</a></li>
		          </ul>
		        </li>
		        <li >
	              <a href="../blog/index.html">Blog</a>
                </li>
		        <li >
	              <a href="../download.html">Download</a>
                </li>
	      	</ul>
			
			<div class="pull-right">
				<div class="bitovi-menu">
					<a href="http://bitovi.com" class="bitovi icon-bits">Bitovi</a>
					<ul class="dropdown-menu">
						<li><a href="http://bitovi.com">Bitovi.com</a></li>
						<li><a href="http://bitovi.com/blog/">Blog</a></li>
						<li><a href="http://bitovi.com/consulting/">Consulting</a></li>
						<li><a href="http://bitovi.com/training/">Training</a></li>
						<li><a href="http://bitovi.com/open-source/">Open Source</a></li>
						<li><a href="http://bitovi.com/people/">People</a></li>
						<li><a href="http://bitovi.com/contact/">Contact Us</a></li>
					</ul>
				</div>
			</div>
			
		</nav>
	</header>

	
<div class="container api">

	
	<nav class="sidebar">
		
		<h2 id="version">
	<select id='versions'></select>
</h2>
<ul class="api">
	<!-- First Level -->
	
	   <li class="search-container">
	   		<a href="can.Component.html" data-search="can.Component">
				can.Component
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Construct.html" data-search="can.Construct">
				can.Construct
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Control.html" data-search="can.Control">
				can.Control
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.List.html" data-search="can.List">
				can.List
			</a>
			
	   </li>
	
	   <li class="search-container active">
	   		<a href="can.Map.html" data-search="can.Map">
				can.Map
			</a>
			
				
	<ul class="primary-grouping">
		
			
				
					
					<li class="heading search-container">
						<span>prototype</span>
						
	<ul >
		
			
				
				
					<li class="search-container  ">
						<a 	class="property" 
							href="can.Map.prototype.COMPUTE-ATTR.html" 
							data-search="can.Map.prototype.COMPUTE-ATTR">
							COMPUTE-ATTR
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="property" 
							href="can.Map.prototype.DEFAULT-ATTR.html" 
							data-search="can.Map.prototype.DEFAULT-ATTR">
							DEFAULT-ATTR
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.attr.html" 
							data-search="attr">
							attr
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.bind.html" 
							data-search="bind">
							bind
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.compute.html" 
							data-search="compute">
							compute
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.each.html" 
							data-search="each">
							each
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.removeAttr.html" 
							data-search="removeAttr">
							removeAttr
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.serialize.html" 
							data-search="serialize">
							serialize
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.unbind.html" 
							data-search="unbind">
							unbind
						</a>
						
					</li>
				
			
			
		
			
		
	</ul>

					</li>
					
				
				
			
			
		
			
				
					
					<li class="heading search-container">
						<span>static</span>
						
	<ul >
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.keys.html" 
							data-search="keys">
							keys
						</a>
						
					</li>
				
			
			
		
			
		
	</ul>

					</li>
					
				
				
			
			
		
			
				
					
					<li class="heading search-container">
						<span>Plugins</span>
						
	<ul >
		
			
				
				
					<li class="search-container  ">
						<a 	class="constructor" 
							href="can.LazyMap.html" 
							data-search="can.LazyMap">
							can.LazyMap
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container parent ">
						<a 	class="page" 
							href="can.Map.attributes.html" 
							data-search="attributes">
							attributes
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container parent ">
						<a 	class="page" 
							href="can.Map.backup.html" 
							data-search="backup">
							backup
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container parent ">
						<a 	class="page" 
							href="can.Map.delegate.html" 
							data-search="delegate">
							delegate
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container active parent expanded">
						<a 	class="property" 
							href="can.Map.prototype.define.html" 
							data-search="define">
							define
						</a>
						
							
	<ul >
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.define.TypeConstructor.html" 
							data-search="Type">
							Type
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.define.ValueConstructor.html" 
							data-search="Value">
							Value
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="typedef" 
							href="can.Map.prototype.define.attrDefinition.html" 
							data-search="attrDefinition">
							attrDefinition
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.define.get.html" 
							data-search="get">
							get
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.define.remove.html" 
							data-search="remove">
							remove
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.define.serialize.html" 
							data-search="serialize">
							serialize
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.define.set.html" 
							data-search="set">
							set
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.define.type.html" 
							data-search="type">
							type
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.define.value.html" 
							data-search="value">
							value
						</a>
						
					</li>
				
			
			
		
	</ul>

						
					</li>
				
			
			
		
			
				
				
					<li class="search-container parent ">
						<a 	class="function" 
							href="can.Map.setter.html" 
							data-search="setter">
							setter
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container parent ">
						<a 	class="page" 
							href="can.Map.validations.html" 
							data-search="validations">
							validations
						</a>
						
					</li>
				
			
			
		
	</ul>

					</li>
					
				
				
			
			
		
	</ul>

			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Model.html" data-search="can.Model">
				can.Model
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Model.List.html" data-search="can.Model.List">
				can.Model.List
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.compute.html" data-search="can.compute">
				can.compute
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.ejs.html" data-search="can.ejs">
				can.ejs
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.event.html" data-search="can.event">
				can.event
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.fixture.html" data-search="can.fixture">
				can.fixture
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.mustache.html" data-search="can.mustache">
				can.mustache
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.route.html" data-search="can.route">
				can.route
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.stache.html" data-search="can.stache">
				can.stache
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.util.html" data-search="can.util">
				can.util
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.view.html" data-search="can.view">
				can.view
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.view.bindings.html" data-search="can.view.bindings">
				can.view.bindings
			</a>
			
	   </li>
	
</ul>
	</nav>
	
	
	
	<article class="content docs">
	
	
		
		<section class="title">
			<div class="heading">
<h1>define</h1>
	<ul class="tags">
		<li>property</li>
	</ul>
	
	
</div>

<div class="sub-heading">
	
	
		<span class="module">can.Map.prototype.define</span>
	
	
	
	<h2><code>{Object&lt;String,<a href="can.Map.prototype.define.attrDefinition.html" >attrDefinition</a>&gt;}</code></h2>
	
	<span class="inherits">&nbsp;</span>
</div>

<ul class="links">
    
	
		<li><a href="">source</a></li>
	
	
	
</ul>
<br />
		</section>
		
		
		
		<section class="contents">
		</section>
		
		
		

		
		<section class="description">
			<p>Defines the
type, initial value, get, set, remove, and serialize behavior for attributes
of a <a href="can.Map.html">can.Map</a>.</p>

		</section>
		

		
			
			<section class='primary-options'>
				

  <h2 id="sig_">Object&lt;String,<a href="can.Map.prototype.define.attrDefinition.html" >attrDefinition</a>&gt;
</h2>
<div class="signature-wrapper">
<p>A map of
attribute names to <a href="can.Map.prototype.define.attrDefinition.html">attribute definition</a>
objects.</p>







</div>

  

			</section>
			
		
		
		
		

		
		<section class="comment">
			<h2>Use</h2>
<p>The <a href="can.Map.prototype.define.html">can.Map.define</a> plugin allows you to completely control the behavior
of attributes on a <a href="can.Map.html">can.Map</a>. To use it, you specify
an define object that is a mapping of properties
to <a href="can.Map.prototype.define.attrDefinition.html">attribute definitions</a>. The following example
specifies a Paginate Map:</p>
<pre><code>var Paginate = can.Map.extend({
  define: {
    count: {
      type: &quot;number&quot;,
      value: Infinity,
      // Keeps count above 0.
      set: function(newCount){
        return newCount &lt; 0 ? 0 : newCount;
      }
    },
    offset: {
      type: &quot;number&quot;,
      value: 0,
      // Keeps offset between 0 and count
      set: function(newOffset){
        var count = this.attr(&quot;count&quot;);
        return newOffset &lt; 0 ?
          0 :
          Math.min(newOffset, !isNaN( count - 1) ?
            count - 1 :
            Infinity);
      }
    },
    limit: {
      type: &quot;number&quot;,
      value: 5
    },
    page: {
      // Setting page changes the offset
      set: function(newVal){
        this.attr('offset', (parseInt(newVal) - 1) * 
                             this.attr('limit'));
      },
      // The page value is derived from offset and limit.
      get: function (newVal) {
        return Math.floor(this.attr('offset') / 
                          this.attr('limit')) + 1;
      }
    }
  }
});
</code></pre>
<h2>Overview</h2>
<p>This plugin is a replacement for the now deprecated <a href="can.Map.attributes.html">attributes</a> and <a href="can.Map.setter.html">setter</a> plugins. It intends to provide a single place to define the behavior of all the properties of a can.Map.</p>
<p>Here is the cliffnotes version of this plugin.  To define...</p>
<ul>
<li>The default value for a property - use <a href="can.Map.prototype.define.value.html">value</a></li>
<li>That default value as a constructor function - use <a href="can.Map.prototype.define.ValueConstructor.html">Value</a></li>
<li>What value is returned when a property is read - use <a href="can.Map.prototype.define.get.html">get</a></li>
<li>Behavior when a property is set - use <a href="can.Map.prototype.define.set.html">set</a></li>
<li>How a property is serialized when <a href="can.Map.prototype.serialize.html">serialize</a> is called on it - use <a href="can.Map.prototype.define.serialize.html">serialize</a></li>
<li>Behavior when a property is removed - use <a href="can.Map.prototype.define.remove.html">remove</a></li>
<li>A custom converter method or a pre-defined standard converter called whenever a property is set - use <a href="can.Map.prototype.define.type.html">type</a></li>
<li>That custom converter method as a constructor function - use <a href="can.Map.prototype.define.TypeConstructor.html">Type</a></li>
</ul>
<h2>Demo</h2>
<p>The following shows picking cars by make / model / year:</p>
<div class='demo_wrapper' data-demo-src='can/map/define/doc/examples/makemodelyear.html'></div>

		</section>
		
		

		
	
	
	</article>
	
	

</div>





	
	
	<footer>
		<nav class="container">
			<a class="brand" href="index.html"></a>
			<ul class='nav'>
				<li >
	              <a href="../index.html">Home</a>
	            </li>
		        <li><a href='../guides/index.html'>guides</a></li>
		        <li class='active'><a href='index.html'>api</a></li>
		        <li class="">
		          <a href="../community.html#!forums">Community</a>
		        </li>
		        <li >
	              <a href="../blog/index.html">Blog</a>
	            </li>
		        <li >
	              <a href="../download.html">Download</a>
	            </li>
            </ul>
		</nav>
	</footer>
	

    
    <!--<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-2302003-11']);
	  _gaq.push(['_setDomainName', 'canjs.com']);
	  _gaq.push(['_setAllowLinker', true]);
	  _gaq.push(['_trackPageview']);
	
	  (function() {
	  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();
	
	</script>-->
	
	<script type="text/javascript">
		var docObject = {"parent":"can.Map.plugins","templates":"/Users/justin/dev/canjs.com/theme/templates","static":"/Users/justin/dev/canjs.com/theme/static","versionsSelectText":"CanJS v<%= version %>","glob":{"ignore":["guides/*.md","{node_modules,bower_components}/**/*"],"pattern":"**/*.{md,js}","cwd":"/Users/justin/dev/canjs.com/can"},"dest":"/Users/justin/dev/canjs.com/docs","generators":["html"],"urls":{"builderData":"http://bitbuilder.herokuapp.com/canjs","builder":"http://bitbuilder.herokuapp.com/can.custom.js","bithub":"http://api.bithub.com/api/v1/events/","cdn":"//canjs.com/release/","github":"https://github.com/bitovi/canjs.com"},"versions":[{"branch":"master","number":"2.1"},{"number":"2.0"},{"number":"1.1"}],"defaultDownloadVersion":"2.1.3","docConfigDest":"../documentjs.json","project":{"version":"2.1","name":"canjs"},"type":"property","name":"can.Map.prototype.define","description":"<p>Defines the\ntype, initial value, get, set, remove, and serialize behavior for attributes\nof a [can.Map].</p>\n","types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"can.Map.prototype.define.attrDefinition"}]}],"description":"<p>A map of\nattribute names to [can.Map::define.attrDefinition attribute definition]\nobjects.</p>\n"}],"title":"define","comment":" ","src":"map/define/doc/define.md","children":[{"type":"function","name":"can.Map.prototype.define.TypeConstructor","description":"<p>Provides a constructor function to be used to convert any value passed into [can.Map::attr attr] into an appropriate value</p>\n","title":"Type","parent":"can.Map.prototype.define","signatures":[{"code":"constructorFunc","description":"<p>A constructor function can be provided that is called to convert incoming values set on this property, like:</p>\n<pre><code>define: {\n  prop: {\n    Type: Person\n  }\n}\n</code></pre>\n","params":[]}],"comment":" ","src":"map/define/doc/TypeConstructor.md"},{"type":"function","name":"can.Map.prototype.define.ValueConstructor","description":"<p>Provides a constructor function to be used to provide a default value for a certain property of a can.Map.  This constructor will be invoked with <code>new</code> each time a new instance of the map is created.</p>\n","title":"Value","parent":"can.Map.prototype.define","signatures":[{"code":"constructorFunc","description":"<p>A constructor function can be provided that is called to create a default value used for this property, like:</p>\n<pre><code>define: {\n  prop: {\n    Value: Array\n  },\n  person: {\n    Value: Person\n  }\n}\n</code></pre>\n","params":[]}],"comment":" ","src":"map/define/doc/ValueConstructor.md"},{"type":"typedef","name":"can.Map.prototype.define.attrDefinition","description":"<p>Defines the type, initial value, and get, set, and remove behavior for an attribute of a [can.Map].</p>\n","title":"attrDefinition","types":[{"type":"Object","options":[{"name":"value","description":"<p>Specifies the initial value of the attribute or\na function that returns the initial value. For example, a default value of <code>0</code> can be\nspecified like:</p>\n<pre><code>define: {\n  prop: {\n    value: 0\n  }\n}\n</code></pre>\n<p><code>Object</code> types should not be specified directly on <code>value</code> because that same object will\nbe shared on every instance of the Map.  Instead, a [can.Map::define.value value function] that\nreturns a fresh copy can be provided:</p>\n<pre><code>define: {\n  prop: {\n    value: function(){\n      return {foo: &quot;bar&quot;}\n    }\n  }\n}\n</code></pre>\n","types":[{"type":"can.Map.prototype.define.value"},{"type":"*"}]},{"name":"Value","description":"<p>Specifies a function that will be called with <code>new</code> whose result is\nset as the initial value of the attribute. For example, if the default value should be a can.List:</p>\n<pre><code>define: {\n  prop: {\n    Value: can.List\n  }\n}\n</code></pre>\n","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]},{"name":"type","description":"<p>Specifies the type of the\nattribute.  The type can be specified as either a [can.Map.prototype.define.type type function]\nthat returns the type coerced value or one of the following strings:</p>\n<ul>\n<li><code>&quot;string&quot;</code> - Converts the value to a string.</li>\n<li><code>&quot;date&quot;</code> - Converts the value to a date or `null if the date can not be converted.</li>\n<li><code>&quot;number&quot;</code> - Passes the value through <code>parseFloat</code>.</li>\n<li><code>&quot;boolean&quot;</code> - Converts falsey, <code>&quot;false&quot;</code> or <code>&quot;0&quot;</code> to <code>false</code> and everything else to true.</li>\n<li><code>&quot;*&quot;</code> - Prevents the default type coersion of converting Objects to [can.Map]s and Arrays to [can.List]s.</li>\n</ul>\n<p>The following example converts the <code>count</code> property to a number and the <code>items</code> property to an array:</p>\n<pre><code> define: {\n   count: {type: &quot;number&quot;},\n   items: {\n     type: function(newValue){\n       if(typeof newValue === &quot;string&quot;) {\n         return newValue.split(&quot;,&quot;)\n       } else if( can.isArray(newValue) ) {\n         return newValue;\n       }\n     }\n   }\n }\n</code></pre>\n","types":[{"type":"can.Map.prototype.define.type"},{"type":"String"}]},{"name":"Type","description":"<p>A constructor function that takes\nthe value passed to [can.Map::attr attr] as the first argument and called with\nnew. For example, if you want whatever\ngets passed to go through <code>new Array(newValue)</code> you can do that like:</p>\n<pre><code>define: {\n  items: {\n    Type: Array\n  }\n}\n</code></pre>\n<p>If the value passed to [can.Map::attr attr] is already an Array, it will be left as is.</p>\n","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]},{"name":"set","description":"<p>A set function that specifies what should happen when an attribute\nis set on a [can.Map]. <code>set</code> is called with the result of <code>type</code> or <code>Type</code>. The following\ndefines a <code>page</code> setter that updates the map's offset:</p>\n<pre><code>define: {\n  page: {\n    set: function(newVal){\n      this.attr('offset', (parseInt(newVal) - 1) * \n                           this.attr('limit'));\n    }\n  }\n}\n</code></pre>\n","types":[{"type":"can.Map.prototype.define.set"}]},{"name":"get","description":"<p>A function that specifies how the value is retrieved.  The get function is\nconverted to an [can.compute.async async compute].  It should derive its value from other values\non the map. The following\ndefines a <code>page</code> getter that reads from a map's offset and limit:</p>\n<pre><code>define: {\n  page: {\n    get: function (newVal) {\n      return Math.floor(this.attr('offset') / \n                        this.attr('limit')) + 1;\n    }\n  }\n}\n</code></pre>\n<p>A <code>get</code> definition makes the property <strong>computed</strong> which means it will not be serialized by default.</p>\n","types":[{"type":"can.Map.prototype.define.get"}]},{"name":"remove","description":"<p>A function that specifies what should happen when an attribute is removed\nwith [can.Map::removeAttr removeAttr]. The following removes a <code>modelId</code> when <code>makeId</code> is removed:</p>\n<pre><code>define: {\n  makeId: {\n    remove: function(){\n      this.removeAttr(&quot;modelId&quot;);\n    }\n  }\n}\n</code></pre>\n","types":[{"type":"can.Map.prototype.define.remove"}]},{"name":"serialize","description":"<p>Specifies the behavior of the\nproperty when [can.Map::serialize serialize] is called.</p>\n<p>By default, serialize does not include computed values. Properties with a <code>get</code> definition\nare computed and therefore are not added to the result.  Non-computed properties values are\nserialized if possible and added to the result.</p>\n<pre><code>Paginate = can.Map.extend({\n  define: {\n    pageNum: {\n      get: function(){ return this.offset() / 20 }\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-&gt; {offset: 40}\n</code></pre>\n<p>If <code>true</code> is specified, computed properties will be serialized and added to the result.</p>\n<pre><code>Paginate = can.Map.extend({\n  define: {\n    pageNum: { \n      get: function(){ return this.offset() / 20 },\n      serialize: true\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-&gt; {offset: 40, pageNum: 2}\n</code></pre>\n<p>If <code>false</code> is specified, non-computed properties will not be added to the result.</p>\n<pre><code>Paginate = can.Map.extend({\n  define: {\n    offset: {\n      serialize: false\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-&gt; {}\n</code></pre>\n<p>If a [can.Map.prototype.define.serialize serialize function] is specified, the result\nof the function is added to the result.</p>\n<pre><code>Paginate = can.Map.extend({\n  define: {\n    offset: {\n      serialize: function(offset){\n        return (offset / 20)+1\n      }\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-&gt; {offset: 3}\n</code></pre>\n","types":[{"type":"can.Map.prototype.define.serialize"},{"type":"Boolean"}]}]}],"parent":"can.Map.prototype.define","src":"map/define/doc/attrDefinition.md"},{"type":"function","name":"can.Map.prototype.define.get","description":"<p>Specify what happens when a certain property is read on a map.</p>\n","title":"get","parent":"can.Map.prototype.define","signatures":[{"code":"get( )","description":"<p>A get function defines the behavior of what happens when a value is read on a\n[can.Map]. It is typically used to provide properties that derive their value from other properties of the map.</p>\n","params":[],"returns":{"types":[{"type":"*"}],"description":"<p>Anything can be returned from a getter.</p>\n"}}],"comment":" ","src":"map/define/doc/get.md"},{"type":"function","name":"can.Map.prototype.define.remove","description":"<p>Called when an attribute is removed.</p>\n","title":"remove","parent":"can.Map.prototype.define","signatures":[{"code":"remover( currentValue )","description":"","params":[],"returns":{"types":[{"type":"*"},{"type":"false"}],"description":"<p>If <code>false</code> is returned, the value is not removed.</p>\n"}}],"comment":" ","src":"map/define/doc/remove.md"},{"type":"function","name":"can.Map.prototype.define.serialize","description":"<p>Called when an attribute is removed.</p>\n","title":"serialize","parent":"can.Map.prototype.define","signatures":[{"code":"serializer( currentValue )","description":"","params":[{"types":[{"type":"*"}],"name":"value","description":"<p>The current value of the attribute.</p>\n"},{"types":[{"type":"String"}],"name":"attr","description":"<p>The name of the attribute being serialized.</p>\n"}],"returns":{"types":[{"type":"*"},{"type":"undefined"}],"description":"<p>If <code>undefined</code> is returned, the value is not serialized.</p>\n"},"context":{"types":[{"type":"can.Map"}],"description":"<p>The map instance being serialized.</p>\n"}}],"comment":" ","src":"map/define/doc/serialize.md"},{"type":"function","name":"can.Map.prototype.define.set","description":"<p>Specify what happens when a value is set on a map attribute.</p>\n","title":"set","parent":"can.Map.prototype.define","signatures":[{"code":"set( [newVal,] [setValue] )","description":"<p>A set function defines the behavior of what happens when a value is set on a\n[can.Map]. It is typically used to:</p>\n<ul>\n<li>Add or remove other attributes as side effects</li>\n<li>Coerce the set value into an appropriate action</li>\n</ul>\n<p>The behavior of the setter depends on the number of arguments specified. This means that a\nsetter like:</p>\n<pre><code>define: {\n  prop: {\n    set: function(){}\n  }\n}\n</code></pre>\n<p>behaves differently than:</p>\n<pre><code>define: {\n  prop: {\n    set: function(newVal){}\n  }\n}\n</code></pre>\n","params":[{"types":[{"type":"*"}],"optional":true,"name":"newVal","description":"<p>The [can.Map::define.type type function] coerced value the user intends to set on the\ncan.Map.</p>\n"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*"}],"name":"newValue"}]}],"optional":true,"name":"setValue","description":"<p>A callback that can set the value of the property\nasyncronously.</p>\n"}],"returns":{"types":[{"type":"*"},{"type":"undefined"}],"description":"<p>If a non-undefined value is returned, that value is set as\nthe attribute value.</p>\n<p>If an <code>undefined</code> value is returned, the behavior depends on the number of\narguments the setter declares:</p>\n<ul>\n<li>If the setter <em>does not</em> specify the <code>newValue</code> argument, the attribute value is set\nto whatever was passed to [can.Map::attr attr].</li>\n<li>If the setter specifies the <code>newValue</code> argument only, the attribute value will be removed.</li>\n<li>If the setter specifies both <code>newValue</code> and <code>setValue</code>, the value of the property will not be\nupdated until <code>setValue</code> is called.</li>\n</ul>\n"}}],"comment":" ","src":"map/define/doc/set.md"},{"type":"function","name":"can.Map.prototype.define.type","description":"<p>Converts a value passed to [can.Map::attr attr] into an appropriate value.</p>\n","title":"type","parent":"can.Map.prototype.define","params":[{"types":[{"type":"*"}],"name":"newValue","description":"<p>The value passed to <code>attr</code>.</p>\n"},{"types":[{"type":"String"}],"name":"attrName","description":"<p>The attribute name being set.</p>\n"}],"context":{"types":[{"type":"can.Map"}],"description":"<p>the instance of the can.Map.</p>\n"},"returns":{"types":[{"type":"*"}],"description":"<p>The value that should be passed to <code>set</code> or (if there is no <code>set</code> property) the value to set on the map instance.</p>\n"},"comment":" ","src":"map/define/doc/type.md"},{"type":"function","name":"can.Map.prototype.define.value","description":"<p>Returns the default value for instances of this can.Map.  This is called before <code>init</code>.</p>\n","title":"value","parent":"can.Map.prototype.define","signatures":[{"code":"defaulter()","description":"<p>A function can be provided that returns the default value used for this property, like:</p>\n<pre><code>define: {\n  prop: {\n    value: function(){ return []; }\n  }\n}\n</code></pre>\n<p>If the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object.  For example, if the property <code>value</code> above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).</p>\n","params":[],"context":{"types":[{"type":"can.Map"}],"description":"<p>the instance of the can.Map.</p>\n"},"returns":{"types":[{"type":"*"}],"description":"<p>The default value.  This will be passed through setter and type.</p>\n"}},{"code":"defaulVal","description":"<p>Any value can be provided as the default value used for this property, like:</p>\n<pre><code>define: {\n  prop: {\n    value: 'foo'\n  }\n}\n</code></pre>\n","params":[{"types":[{"type":"*"}],"name":"defaultVal","description":"<p>The default value, which will be passed through setter and type.</p>\n"}]}],"comment":" ","src":"map/define/doc/value.md"}]};
	</script>
	
	
		<script type='text/javascript' 
				data-main="static"
				src="./static/steal.production.js"
		    		bundles-path="bundles"></script>
	
	
</body>

</html>
<!DOCTYPE html>

<html>
<head>
  <title>dojo-1.8.1.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="component.html">
                component.js
              </a>
            
              
              <a class="source" href="grid.html">
                grid.js
              </a>
            
              
              <a class="source" href="compute.html">
                compute.js
              </a>
            
              
              <a class="source" href="construct.html">
                construct.js
              </a>
            
              
              <a class="source" href="proxy.html">
                proxy.js
              </a>
            
              
              <a class="source" href="super.html">
                super.js
              </a>
            
              
              <a class="source" href="control.html">
                control.js
              </a>
            
              
              <a class="source" href="key.html">
                key.js
              </a>
            
              
              <a class="source" href="modifier.html">
                modifier.js
              </a>
            
              
              <a class="source" href="plugin.html">
                plugin.js
              </a>
            
              
              <a class="source" href="route.html">
                route.js
              </a>
            
              
              <a class="source" href="view.html">
                view.js
              </a>
            
              
              <a class="source" href="list.html">
                list.js
              </a>
            
              
              <a class="source" href="attributes.html">
                attributes.js
              </a>
            
              
              <a class="source" href="backup.html">
                backup.js
              </a>
            
              
              <a class="source" href="delegate.html">
                delegate.js
              </a>
            
              
              <a class="source" href="map.html">
                map.js
              </a>
            
              
              <a class="source" href="map_benchmark.html">
                map_benchmark.js
              </a>
            
              
              <a class="source" href="setter.html">
                setter.js
              </a>
            
              
              <a class="source" href="sort.html">
                sort.js
              </a>
            
              
              <a class="source" href="validations.html">
                validations.js
              </a>
            
              
              <a class="source" href="cached.html">
                cached.js
              </a>
            
              
              <a class="source" href="local.html">
                local.js
              </a>
            
              
              <a class="source" href="model.html">
                model.js
              </a>
            
              
              <a class="source" href="queue.html">
                queue.js
              </a>
            
              
              <a class="source" href="store.html">
                store.js
              </a>
            
              
              <a class="source" href="observe.html">
                observe.js
              </a>
            
              
              <a class="source" href="pushstate.html">
                pushstate.js
              </a>
            
              
              <a class="source" href="route.html">
                route.js
              </a>
            
              
              <a class="source" href="all.html">
                all.js
              </a>
            
              
              <a class="source" href="each.html">
                each.js
              </a>
            
              
              <a class="source" href="makeArray.html">
                makeArray.js
              </a>
            
              
              <a class="source" href="batch.html">
                batch.js
              </a>
            
              
              <a class="source" href="bind.html">
                bind.js
              </a>
            
              
              <a class="source" href="can.html">
                can.js
              </a>
            
              
              <a class="source" href="deferred.html">
                deferred.js
              </a>
            
              
              <a class="source" href="observer.html">
                observer.js
              </a>
            
              
              <a class="source" href="destroyed.html">
                destroyed.js
              </a>
            
              
              <a class="source" href="dojo-1.8.1.html">
                dojo-1.8.1.js
              </a>
            
              
              <a class="source" href="dojo.html">
                dojo.js
              </a>
            
              
              <a class="source" href="nodelist-traverse.html">
                nodelist-traverse.js
              </a>
            
              
              <a class="source" href="trigger.html">
                trigger.js
              </a>
            
              
              <a class="source" href="event.html">
                event.js
              </a>
            
              
              <a class="source" href="fixture.html">
                fixture.js
              </a>
            
              
              <a class="source" href="fragment.html">
                fragment.js
              </a>
            
              
              <a class="source" href="func.html">
                func.js
              </a>
            
              
              <a class="source" href="function.html">
                function.js
              </a>
            
              
              <a class="source" href="hashchange.html">
                hashchange.js
              </a>
            
              
              <a class="source" href="inserted.html">
                inserted.js
              </a>
            
              
              <a class="source" href="jquery.html">
                jquery.js
              </a>
            
              
              <a class="source" href="library.html">
                library.js
              </a>
            
              
              <a class="source" href="mootools.html">
                mootools.js
              </a>
            
              
              <a class="source" href="mvc.html">
                mvc.js
              </a>
            
              
              <a class="source" href="isplain.html">
                isplain.js
              </a>
            
              
              <a class="source" href="object.html">
                object.js
              </a>
            
              
              <a class="source" href="classize.html">
                classize.js
              </a>
            
              
              <a class="source" href="deparam.html">
                deparam.js
              </a>
            
              
              <a class="source" href="rsplit.html">
                rsplit.js
              </a>
            
              
              <a class="source" href="string.html">
                string.js
              </a>
            
              
              <a class="source" href="util.html">
                util.js
              </a>
            
              
              <a class="source" href="yui.html">
                yui.js
              </a>
            
              
              <a class="source" href="zepto.html">
                zepto.js
              </a>
            
              
              <a class="source" href="bindings.html">
                bindings.js
              </a>
            
              
              <a class="source" href="ejs.html">
                ejs.js
              </a>
            
              
              <a class="source" href="foo.html">
                foo.js
              </a>
            
              
              <a class="source" href="elements.html">
                elements.js
              </a>
            
              
              <a class="source" href="live.html">
                live.js
              </a>
            
              
              <a class="source" href="modifiers.html">
                modifiers.js
              </a>
            
              
              <a class="source" href="mustache.html">
                mustache.js
              </a>
            
              
              <a class="source" href="node_lists.html">
                node_lists.js
              </a>
            
              
              <a class="source" href="render.html">
                render.js
              </a>
            
              
              <a class="source" href="scanner.html">
                scanner.js
              </a>
            
              
              <a class="source" href="scope.html">
                scope.js
              </a>
            
              
              <a class="source" href="view.html">
                view.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>dojo-1.8.1.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * @documentjs-ignore
 */</span>
<span class="hljs-comment">/*
 Copyright (c) 2004-2012, The Dojo Foundation All Rights Reserved.
 Available via Academic Free License &gt;= 2.1 OR the modified BSD license.
 see: http://dojotoolkit.org/license for details
 */</span>
<span class="hljs-comment">/*
 This is an optimized version of Dojo, built for deployment and not for
 development. To get sources and documentation, please visit:

 http://dojotoolkit.org
 */</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userConfig, defaultConfig)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>summary:
    This is the “source loader” and is the entry point for Dojo during development. You may also load Dojo with
    any AMD-compliant loader via the package main module dojo/main.
description:
    This is the “source loader” for Dojo. It provides an AMD-compliant loader that can be configured
    to operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded
    IAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package
    via the package main module dojo/main and this loader is not required; see dojo/package.json for details.</p>
<pre><code>In order to keep compatibility <span class="hljs-keyword">with</span> the v1.x line, <span class="hljs-keyword">this</span> loader includes additional machinery that enables
the dojo.provide, dojo.require et al API. This machinery is loaded by <span class="hljs-keyword">default</span>, but may be dynamically removed
via the has.js API and statically removed via the build system.

This loader includes sniffing machinery to determine the environment; the following environments are supported:

- browser
- node.js
- rhino

This is the so-called <span class="hljs-string">"source loader"</span>. As such, it includes many optional features that may be discadred by
building a customized verion <span class="hljs-keyword">with</span> the build system.
</code></pre><p>Design and Implementation Notes</p>
<p>This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.</p>
<p>This function defines an AMD-compliant (<a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition</a>)
loader that can be configured to operate in either synchronous or asynchronous modes.</p>
<p>Since this machinery implements a loader, it does not have the luxury of using a load system and/or
leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:</p>
<ol>
<li>Small library for use implementing the loader.</li>
<li>Define the has.js API; this is used throughout the loader to bracket features.</li>
<li>Define the node.js and rhino sniffs and sniff.</li>
<li>Define the loader’s data.</li>
<li>Define the configuration machinery.</li>
<li>Define the script element sniffing machinery and sniff for configuration data.</li>
<li>Configure the loader IAW the provided user, default, and sniffing data.</li>
<li>Define the global require function.</li>
<li>Define the module resolution machinery.<ol>
<li>Define the module and plugin module definition machinery</li>
<li>Define the script injection machinery.</li>
<li>Define the window load detection.</li>
<li>Define the logging API.</li>
<li>Define the tracing API.</li>
<li>Define the AMD define function.</li>
<li>Define the dojo v1.x provide/require machinery—so called “legacy” modes.</li>
<li>Publish global variables.</li>
</ol>
</li>
</ol>
<p>Language and Acronyms and Idioms</p>
<p>moduleId: a CJS module identifier, (used for public APIs)
mid: moduleId (used internally)
packageId: a package identifier (used for public APIs)
pid: packageId (used internally); the implied system or default package has pid===””
pack: package is used internally to reference a package object (since javascript has reserved words including “package”)
prid: plugin resource identifier
The integer constant 1 is used in place of true and 0 in place of false.
define a minimal library to help build the loader</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> noop = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>}, isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(it)</span> {</span>
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> it) {
				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
			}
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		}, toString = {}.toString,
		isFunction = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(it)</span> {</span>
			<span class="hljs-keyword">return</span> toString.call(it) === <span class="hljs-string">'[object Function]'</span>;
		}, isString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(it)</span> {</span>
			<span class="hljs-keyword">return</span> toString.call(it) === <span class="hljs-string">'[object String]'</span>;
		}, isArray = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(it)</span> {</span>
			<span class="hljs-keyword">return</span> toString.call(it) === <span class="hljs-string">'[object Array]'</span>;
		}, forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(vector, callback)</span> {</span>
			<span class="hljs-keyword">if</span> (vector) {
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; vector.length;) {
					callback(vector[i++]);
				}
			}
		}, mix = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dest, src)</span> {</span>
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> src) {
				dest[p] = src[p];
			}
			<span class="hljs-keyword">return</span> dest;
		}, makeError = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error, info)</span> {</span>
			<span class="hljs-keyword">return</span> mix(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(error), {
				src: <span class="hljs-string">'dojoLoader'</span>,
				info: info
			});
		}, uidSeed = <span class="hljs-number">1</span>,
		uid = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Returns a unique indentifier (within the lifetime of the document) of the form /_d+/.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> <span class="hljs-string">'_'</span> + uidSeed++;
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>FIXME: how to doc window.require() api
this will be the global require function; define it immediately so we can start hanging things off of it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		req = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(config, dependencies, callback)</span> {</span>
			<span class="hljs-keyword">return</span> contextRequire(config, dependencies, callback, <span class="hljs-number">0</span>, req);
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		global = <span class="hljs-keyword">this</span>,
		doc = global.document,
		element = doc &amp;&amp; doc.createElement(<span class="hljs-string">'DiV'</span>),
		has = req.has = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span>
			<span class="hljs-keyword">return</span> isFunction(hasCache[name]) ? hasCache[name] = hasCache[name](global, doc, element) : hasCache[name];
		}, hasCache = has.cache = defaultConfig.hasCache;
	has.add = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, test, now, force)</span> {</span>
		(hasCache[name] === <span class="hljs-literal">undefined</span> || force) &amp;&amp; (hasCache[name] = test);
		<span class="hljs-keyword">return</span> now &amp;&amp; has(name);
	};
	<span class="hljs-number">0</span> &amp;&amp; has.add(<span class="hljs-string">'host-node'</span>, userConfig.has &amp;&amp; <span class="hljs-string">'host-node'</span> <span class="hljs-keyword">in</span> userConfig.has ? userConfig.has[<span class="hljs-string">'host-node'</span>] : <span class="hljs-keyword">typeof</span> process === <span class="hljs-string">'object'</span> &amp;&amp; process.versions &amp;&amp; process.versions.node &amp;&amp; process.versions.v8);
	<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>fixup the default config for node.js environment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-built_in">require</span>(<span class="hljs-string">'./_base/configNode.js'</span>)
			.config(defaultConfig);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>remember node’s require (with respect to baseUrl==dojo’s root)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		defaultConfig.loaderPatch.nodeRequire = <span class="hljs-built_in">require</span>;
	}
	<span class="hljs-number">0</span> &amp;&amp; has.add(<span class="hljs-string">'host-rhino'</span>, userConfig.has &amp;&amp; <span class="hljs-string">'host-rhino'</span> <span class="hljs-keyword">in</span> userConfig.has ? userConfig.has[<span class="hljs-string">'host-rhino'</span>] : <span class="hljs-keyword">typeof</span> load === <span class="hljs-string">'function'</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> Packages === <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> Packages === <span class="hljs-string">'object'</span>));
	<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>owing to rhino’s lame feature that hides the source of the script, give the user a way to specify the baseUrl…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> baseUrl = userConfig.baseUrl || <span class="hljs-string">'.'</span>, arg, rhinoArgs = <span class="hljs-keyword">this</span>.arguments, i = <span class="hljs-number">0</span>; i &lt; rhinoArgs.length;) {
			arg = (rhinoArgs[i++] + <span class="hljs-string">''</span>)
				.split(<span class="hljs-string">'='</span>);
			<span class="hljs-keyword">if</span> (arg[<span class="hljs-number">0</span>] === <span class="hljs-string">'baseUrl'</span>) {
				baseUrl = arg[<span class="hljs-number">1</span>];
				<span class="hljs-keyword">break</span>;
			}
		}
		load(baseUrl + <span class="hljs-string">'/_base/configRhino.js'</span>);
		rhinoDojoConfig(defaultConfig, baseUrl, rhinoArgs);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>userConfig has tests override defaultConfig has tests; do this after the environment detection because
the environment detection usually sets some has feature values in the hasCache.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> userConfig.has) {
		has.add(p, userConfig.has[p], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>define the loader data</p>
<p>the loader will use these like symbols if the loader has the traceApi; otherwise
define magic numbers so that modules can be provided as part of defaultConfig</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> requested = <span class="hljs-number">1</span>,
		arrived = <span class="hljs-number">2</span>,
		nonmodule = <span class="hljs-number">3</span>,
		executing = <span class="hljs-number">4</span>,
		executed = <span class="hljs-number">5</span>;
	<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>these make debugging nice; but using strings for symbols is a gross rookie error; don’t do it for production code</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		requested = <span class="hljs-string">'requested'</span>;
		arrived = <span class="hljs-string">'arrived'</span>;
		nonmodule = <span class="hljs-string">'not-a-module'</span>;
		executing = <span class="hljs-string">'executing'</span>;
		executed = <span class="hljs-string">'executed'</span>;
	}
	<span class="hljs-keyword">var</span> legacyMode = <span class="hljs-number">0</span>,
		sync = <span class="hljs-string">'sync'</span>,
		xd = <span class="hljs-string">'xd'</span>,
		syncExecStack = [],
		dojoRequirePlugin = <span class="hljs-number">0</span>,
		checkDojoRequirePlugin = noop,
		transformToAmd = noop,
		getXhr;
	<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
		req.isXdUrl = noop;
		req.initSyncLoader = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojoRequirePlugin_, checkDojoRequirePlugin_, transformToAmd_)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>the first dojo/_base/loader loaded gets to define these variables; they are designed to work
in the presense of zero to many mapped dojo/_base/loaders</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!dojoRequirePlugin) {
				dojoRequirePlugin = dojoRequirePlugin_;
				checkDojoRequirePlugin = checkDojoRequirePlugin_;
				transformToAmd = transformToAmd_;
			}
			<span class="hljs-keyword">return</span> {
				sync: sync,
				requested: requested,
				arrived: arrived,
				nonmodule: nonmodule,
				executing: executing,
				executed: executed,
				syncExecStack: syncExecStack,
				modules: modules,
				execQ: execQ,
				getModule: getModule,
				injectModule: injectModule,
				setArrived: setArrived,
				signal: signal,
				finishExec: finishExec,
				execModule: execModule,
				dojoRequirePlugin: dojoRequirePlugin,
				getLegacyMode: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">return</span> legacyMode;
				},
				guardCheckComplete: guardCheckComplete
			};
		};
		<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>in legacy sync mode, the loader needs a minimal XHR library</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> locationProtocol = location.protocol,
				locationHost = location.host;
			req.isXdUrl = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(url)</span> {</span>
				<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\./</span>.test(url)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>begins with a dot is always relative to page URL; therefore not xdomain</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
				}
				<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\/\//</span>.test(url)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>for v1.6- backcompat, url starting with // indicates xdomain</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>get protocol and host
\/+ takes care of the typical file protocol that looks like file:///drive/path/to/file
locationHost is falsy if file protocol =&gt; if locationProtocol matches and is “file:”, || will return false</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> match = url.match(<span class="hljs-regexp">/^([^\/\:]+\:)\/+([^\/]+)/</span>);
				<span class="hljs-keyword">return</span> match &amp;&amp; (match[<span class="hljs-number">1</span>] !== locationProtocol || locationHost &amp;&amp; match[<span class="hljs-number">2</span>] !== locationHost);
			};</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>note: to get the file:// protocol to work in FF, you must set security.fileuri.strict_origin_policy to false in about:config</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-number">1</span> || has.add(<span class="hljs-string">'dojo-xhr-factory'</span>, <span class="hljs-number">1</span>);
			has.add(<span class="hljs-string">'dojo-force-activex-xhr'</span>, <span class="hljs-number">1</span> &amp;&amp; !doc.addEventListener &amp;&amp; window.location.protocol === <span class="hljs-string">'file:'</span>);
			has.add(<span class="hljs-string">'native-xhr'</span>, <span class="hljs-keyword">typeof</span> XMLHttpRequest !== <span class="hljs-string">'undefined'</span>);
			<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'native-xhr'</span>) &amp;&amp; !has(<span class="hljs-string">'dojo-force-activex-xhr'</span>)) {
				getXhr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> XMLHttpRequest();
				};
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>if in the browser an old IE; find an xhr</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> XMLHTTP_PROGIDS = [
					<span class="hljs-string">'Msxml2.XMLHTTP'</span>,
					<span class="hljs-string">'Microsoft.XMLHTTP'</span>,
					<span class="hljs-string">'Msxml2.XMLHTTP.4.0'</span>
				], progid, i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>;) {
					<span class="hljs-keyword">try</span> {
						progid = XMLHTTP_PROGIDS[i++];
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> ActiveXObject(progid)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>this progid works; therefore, use it from now on</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">break</span>;
						}
					} <span class="hljs-keyword">catch</span> (e) {}
				}
				getXhr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveXObject(progid);
				};
			}
			req.getXhr = getXhr;
			has.add(<span class="hljs-string">'dojo-gettext-api'</span>, <span class="hljs-number">1</span>);
			req.getText = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(url, async, onLoad)</span> {</span>
				<span class="hljs-keyword">var</span> xhr = getXhr();
				xhr.open(<span class="hljs-string">'GET'</span>, fixupUrl(url), <span class="hljs-literal">false</span>);
				xhr.send(<span class="hljs-literal">null</span>);
				<span class="hljs-keyword">if</span> (xhr.status === <span class="hljs-number">200</span> || !location.host &amp;&amp; !xhr.status) {
					<span class="hljs-keyword">if</span> (onLoad) {
						onLoad(xhr.responseText, async);
					}
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">throw</span> makeError(<span class="hljs-string">'xhrFailed'</span>, xhr.status);
				}
				<span class="hljs-keyword">return</span> xhr.responseText;
			};
		}
	} <span class="hljs-keyword">else</span> {
		req.async = <span class="hljs-number">1</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>loader eval</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> eval_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'return eval(arguments[0]);'</span>);
	req.eval = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text, hint)</span> {</span>
		<span class="hljs-keyword">return</span> eval_(text + <span class="hljs-string">'\r\n////@ sourceURL='</span> + hint);
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>loader micro events API</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> listenerQueues = {}, error = <span class="hljs-string">'error'</span>,
		signal = req.signal = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type, args)</span> {</span>
			<span class="hljs-keyword">var</span> queue = listenerQueues[type];</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>notice we run a copy of the queue; this allows listeners to add/remove
other listeners without affecting this particular signal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			forEach(queue &amp;&amp; queue.slice(<span class="hljs-number">0</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(listener)</span> {</span>
				listener.apply(<span class="hljs-literal">null</span>, isArray(args) ? args : [args]);
			});
		}, on = req.on = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type, listener)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>notice a queue is not created until a client actually connects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> queue = listenerQueues[type] || (listenerQueues[type] = []);
			queue.push(listener);
			<span class="hljs-keyword">return</span> {
				remove: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; queue.length; i++) {
						<span class="hljs-keyword">if</span> (queue[i] === listener) {
							queue.splice(i, <span class="hljs-number">1</span>);
							<span class="hljs-keyword">return</span>;
						}
					}
				}
			};
		};</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded
lexical variables hold key loader data structures to help with minification; these may be completely,
one-time initialized by defaultConfig for optimized/built versions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> aliases = [],
		paths = {}, pathsMapProg = [],
		packs = {}, map = req.map = {}, mapProgs = [],
		modules = {}, cacheBust = <span class="hljs-string">''</span>,
		cache = {}, urlKeyPrefix = <span class="hljs-string">'url:'</span>,
		pendingCacheInsert = {}, dojoSniffConfig = {};
	<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
		<span class="hljs-keyword">var</span> consumePendingCacheInsert = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(referenceModule)</span> {</span>
			<span class="hljs-keyword">var</span> p, item, match, now, m;
			<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> pendingCacheInsert) {
				item = pendingCacheInsert[p];
				match = p.match(<span class="hljs-regexp">/^url\:(.+)/</span>);
				<span class="hljs-keyword">if</span> (match) {
					cache[urlKeyPrefix + toUrl(match[<span class="hljs-number">1</span>], referenceModule)] = item;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p === <span class="hljs-string">'*now'</span>) {
					now = item;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p !== <span class="hljs-string">'*noref'</span>) {
					m = getModuleInfo(p, referenceModule);
					cache[m.mid] = cache[urlKeyPrefix + m.url] = item;
				}
			}
			<span class="hljs-keyword">if</span> (now) {
				now(createRequire(referenceModule));
			}
			pendingCacheInsert = {};
		}, escapeString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(s)</span> {</span>
				<span class="hljs-keyword">return</span> s.replace(<span class="hljs-regexp">/([\.$?*|{}\(\)\[\]\\\/\+^])/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(c)</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-string">'\\'</span> + c;
				});
			}, computeMapProg = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(map, dest)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>This routine takes a map as represented by a JavaScript object and initializes dest, a vector of
quads of (map-key, map-value, refex-for-map-key, length-of-map-key), sorted decreasing by length-
of-map-key. The regex looks for the map-key followed by either “/“ or end-of-string at the beginning
of a the search source. Notice the map-value is irrelevent to the algorithm</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dest.splice(<span class="hljs-number">0</span>, dest.length);
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> map) {
					dest.push([
						p,
						map[p],
						<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^'</span> + escapeString(p) + <span class="hljs-string">'(/|$)'</span>),
						p.length
					]);
				}
				dest.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(lhs, rhs)</span> {</span>
					<span class="hljs-keyword">return</span> rhs[<span class="hljs-number">3</span>] - lhs[<span class="hljs-number">3</span>];
				});
				<span class="hljs-keyword">return</span> dest;
			}, fixupPackageInfo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(packageInfo)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>calculate the precise (name, location, main, mappings) for a package</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> name = packageInfo.name;
				<span class="hljs-keyword">if</span> (!name) {</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>packageInfo must be a string that gives the name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					name = packageInfo;
					packageInfo = {
						name: name
					};
				}
				packageInfo = mix({
					main: <span class="hljs-string">'main'</span>
				}, packageInfo);
				packageInfo.location = packageInfo.location ? packageInfo.location : name;</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>packageMap is depricated in favor of AMD map</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (packageInfo.packageMap) {
					map[name] = packageInfo.packageMap;
				}
				<span class="hljs-keyword">if</span> (!packageInfo.main.indexOf(<span class="hljs-string">'./'</span>)) {
					packageInfo.main = packageInfo.main.substring(<span class="hljs-number">2</span>);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>now that we’ve got a fully-resolved package object, push it into the configuration</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				packs[name] = packageInfo;
			}, delayedModuleConfig = [],
			config = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(config, booting, referenceModule)</span> {</span>
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> config) {
					<span class="hljs-keyword">if</span> (p === <span class="hljs-string">'waitSeconds'</span>) {
						req.waitms = (config[p] || <span class="hljs-number">0</span>) * <span class="hljs-number">1000</span>;
					}
					<span class="hljs-keyword">if</span> (p === <span class="hljs-string">'cacheBust'</span>) {
						cacheBust = config[p] ? isString(config[p]) ? config[p] : <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
							.getTime() + <span class="hljs-string">''</span> : <span class="hljs-string">''</span>;
					}
					<span class="hljs-keyword">if</span> (p === <span class="hljs-string">'baseUrl'</span> || p === <span class="hljs-string">'combo'</span>) {
						req[p] = config[p];
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp;&amp; p === <span class="hljs-string">'async'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>falsy or “sync” =&gt; legacy sync loader
“xd” =&gt; sync but loading xdomain tree and therefore loading asynchronously (not configurable, set automatically by the loader)
“legacyAsync” =&gt; permanently in “xd” by choice
“debugAtAllCosts” =&gt; trying to load everything via script injection (not implemented)
otherwise, must be truthy =&gt; AMD
legacyMode: sync | legacyAsync | xd | false</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> mode = config[p];
						req.legacyMode = legacyMode = isString(mode) &amp;&amp; <span class="hljs-regexp">/sync|legacyAsync/</span>.test(mode) ? mode : !mode ? sync : <span class="hljs-literal">false</span>;
						req.async = !legacyMode;
					}
					<span class="hljs-keyword">if</span> (config[p] !== hasCache) {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>accumulate raw config info for client apps which can use this to pass their own config</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						req.rawConfig[p] = config[p];
						p !== <span class="hljs-string">'has'</span> &amp;&amp; has.add(<span class="hljs-string">'config-'</span> + p, config[p], <span class="hljs-number">0</span>, booting);
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>make sure baseUrl exists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!req.baseUrl) {
					req.baseUrl = <span class="hljs-string">'./'</span>;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>make sure baseUrl ends with a slash</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/\/$/</span>.test(req.baseUrl)) {
					req.baseUrl += <span class="hljs-string">'/'</span>;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>now do the special work for has, packages, packagePaths, paths, aliases, and cache</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> config.has) {
					has.add(p, config.has[p], <span class="hljs-number">0</span>, booting);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>for each package found in any packages config item, augment the packs map owned by the loader</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				forEach(config.packages, fixupPackageInfo);</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>for each packagePath found in any packagePaths config item, augment the packageConfig
packagePaths is depricated; remove in 2.0</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">for</span> (baseUrl <span class="hljs-keyword">in</span> config.packagePaths) {
					forEach(config.packagePaths[baseUrl], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(packageInfo)</span> {</span>
						<span class="hljs-keyword">var</span> location = baseUrl + <span class="hljs-string">'/'</span> + packageInfo;
						<span class="hljs-keyword">if</span> (isString(packageInfo)) {
							packageInfo = {
								name: packageInfo
							};
						}
						packageInfo.location = location;
						fixupPackageInfo(packageInfo);
					});
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>notice that computeMapProg treats the dest as a reference; therefore, if/when that variable
is published (see dojo-publish-privates), the published variable will always hold a valid value.
this must come after all package processing since package processing may mutate map</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				computeMapProg(mix(map, config.map), mapProgs);
				forEach(mapProgs, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(item)</span> {</span>
					item[<span class="hljs-number">1</span>] = computeMapProg(item[<span class="hljs-number">1</span>], []);
					<span class="hljs-keyword">if</span> (item[<span class="hljs-number">0</span>] === <span class="hljs-string">'*'</span>) {
						mapProgs.star = item[<span class="hljs-number">1</span>];
					}
				});</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>push in any paths and recompute the internal pathmap</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				computeMapProg(mix(paths, config.paths), pathsMapProg);</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>aliases</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				forEach(config.aliases, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pair)</span> {</span>
					<span class="hljs-keyword">if</span> (isString(pair[<span class="hljs-number">0</span>])) {
						pair[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^'</span> + escapeString(pair[<span class="hljs-number">0</span>]) + <span class="hljs-string">'$'</span>);
					}
					aliases.push(pair);
				});
				<span class="hljs-keyword">if</span> (booting) {
					delayedModuleConfig.push({
						config: config.config
					});
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> config.config) {
						<span class="hljs-keyword">var</span> module = getModule(p, referenceModule);
						module.config = mix(module.config || {}, config.config[p]);
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>push in any new cache values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (config.cache) {
					consumePendingCacheInsert();
					pendingCacheInsert = config.cache;
					<span class="hljs-keyword">if</span> (config.cache[<span class="hljs-string">'*noref'</span>]) {
						consumePendingCacheInsert();
					}
				}
				signal(<span class="hljs-string">'config'</span>, [
					config,
					req.rawConfig
				]);
			};</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>execute the various sniffs; userConfig can override and value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'dojo-cdn'</span>) || <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>the sniff regex looks for a src attribute ending in dojo.js, optionally preceeded with a path.
match[3] returns the path to dojo.js (if any) without the trailing slash. This is used for the
dojo location on CDN deployments and baseUrl when either/both of these are not provided
explicitly in the config data; this is the 1.6- behavior.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> scripts = doc.getElementsByTagName(<span class="hljs-string">'script'</span>),
				i = <span class="hljs-number">0</span>,
				script, dojoDir, src, match;
			<span class="hljs-keyword">while</span> (i &lt; scripts.length) {
				script = scripts[i++];
				<span class="hljs-keyword">if</span> ((src = script.getAttribute(<span class="hljs-string">'src'</span>)) &amp;&amp; (match = src.match(<span class="hljs-regexp">/(((.*)\/)|^)dojo\.js(\W|$)/i</span>))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>sniff dojoDir and baseUrl</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					dojoDir = match[<span class="hljs-number">3</span>] || <span class="hljs-string">''</span>;
					defaultConfig.baseUrl = defaultConfig.baseUrl || dojoDir;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>sniff configuration on attribute in script element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					src = script.getAttribute(<span class="hljs-string">'data-dojo-config'</span>) || script.getAttribute(<span class="hljs-string">'djConfig'</span>);
					<span class="hljs-keyword">if</span> (src) {
						dojoSniffConfig = req.eval(<span class="hljs-string">'({ '</span> + src + <span class="hljs-string">' })'</span>, <span class="hljs-string">'data-dojo-config'</span>);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>sniff requirejs attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {
						<span class="hljs-keyword">var</span> dataMain = script.getAttribute(<span class="hljs-string">'data-main'</span>);
						<span class="hljs-keyword">if</span> (dataMain) {
							dojoSniffConfig.deps = dojoSniffConfig.deps || [dataMain];
						}
					}
					<span class="hljs-keyword">break</span>;
				}
			}
		}
		<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>pass down doh.testConfig from parent as if it were a data-dojo-config</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">try</span> {
				<span class="hljs-keyword">if</span> (window.parent !== window &amp;&amp; window.parent.require) {
					<span class="hljs-keyword">var</span> doh = window.parent.require(<span class="hljs-string">'doh'</span>);
					doh &amp;&amp; mix(dojoSniffConfig, doh.testConfig);
				}
			} <span class="hljs-keyword">catch</span> (e) {}
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>configure the loader; let the user override defaults</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		req.rawConfig = {};
		config(defaultConfig, <span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>do this before setting userConfig/sniffConfig to allow userConfig/sniff overrides</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'dojo-cdn'</span>)) {
			packs.dojo.location = dojoDir;
			<span class="hljs-keyword">if</span> (dojoDir) {
				dojoDir += <span class="hljs-string">'/'</span>;
			}
			packs.dijit.location = dojoDir + <span class="hljs-string">'../dijit/'</span>;
			packs.dojox.location = dojoDir + <span class="hljs-string">'../dojox/'</span>;
		}
		config(userConfig, <span class="hljs-number">1</span>);
		config(dojoSniffConfig, <span class="hljs-number">1</span>);
	} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>no config API, assume defaultConfig has everything the loader needs…for the entire lifetime of the application</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		paths = defaultConfig.paths;
		pathsMapProg = defaultConfig.pathsMapProg;
		packs = defaultConfig.packs;
		aliases = defaultConfig.aliases;
		mapProgs = defaultConfig.mapProgs;
		modules = defaultConfig.modules;
		cache = defaultConfig.cache;
		cacheBust = defaultConfig.cacheBust;</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>remember the default config for other processes (e.g., dojo/config)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		req.rawConfig = defaultConfig;
	}
	<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {
		req.combo = req.combo || {
			add: noop
		};
		<span class="hljs-keyword">var</span> comboPending = <span class="hljs-number">0</span>,
			combosPending = [],
			comboPendingTimer = <span class="hljs-literal">null</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>build the loader machinery iaw configuration, including has feature tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> injectDependencies = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>checkComplete!=0 holds the idle signal; we’re not idle if we’re injecting dependencies</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		guardCheckComplete(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			forEach(module.deps, injectModule);
			<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &amp;&amp; comboPending &amp;&amp; !comboPendingTimer) {
				comboPendingTimer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					comboPending = <span class="hljs-number">0</span>;
					comboPendingTimer = <span class="hljs-literal">null</span>;
					req.combo.done(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mids, url)</span> {</span>
						<span class="hljs-keyword">var</span> onLoadCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>defQ is a vector of module definitions 1-to-1, onto mids</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							runDefQ(<span class="hljs-number">0</span>, mids);
							checkComplete();
						};
						combosPending.push(mids);
						injectingModule = mids;
						req.injectUrl(url, onLoadCallback, mids);
						injectingModule = <span class="hljs-number">0</span>;
					}, req);
				}, <span class="hljs-number">0</span>);
			}
		});
	}, contextRequire = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a1, a2, a3, referenceModule, contextRequire)</span> {</span>
			<span class="hljs-keyword">var</span> module, syntheticMid;
			<span class="hljs-keyword">if</span> (isString(a1)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>signature is (moduleId)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				module = getModule(a1, referenceModule, <span class="hljs-literal">true</span>);
				<span class="hljs-keyword">if</span> (module &amp;&amp; module.executed) {
					<span class="hljs-keyword">return</span> module.result;
				}
				<span class="hljs-keyword">throw</span> makeError(<span class="hljs-string">'undefinedModule'</span>, a1);
			}
			<span class="hljs-keyword">if</span> (!isArray(a1)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>a1 is a configuration</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				config(a1, <span class="hljs-number">0</span>, referenceModule);</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>juggle args; (a2, a3) may be (dependencies, callback)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				a1 = a2;
				a2 = a3;
			}
			<span class="hljs-keyword">if</span> (isArray(a1)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>signature is (requestList [,callback])</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!a1.length) {
					a2 &amp;&amp; a2();
				} <span class="hljs-keyword">else</span> {
					syntheticMid = <span class="hljs-string">'require*'</span> + uid();</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>resolve the request list with respect to the reference module</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> mid, deps = [], i = <span class="hljs-number">0</span>; i &lt; a1.length;) {
						mid = a1[i++];
						deps.push(getModule(mid, referenceModule));
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>construct a synthetic module to control execution of the requestList, and, optionally, callback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					module = mix(makeModuleInfo(<span class="hljs-string">''</span>, syntheticMid, <span class="hljs-number">0</span>, <span class="hljs-string">''</span>), {
						injected: arrived,
						deps: deps,
						def: a2 || noop,
						<span class="hljs-built_in">require</span>: referenceModule ? referenceModule.require : req,
						gc: <span class="hljs-number">1</span>
					});
					modules[module.mid] = module;</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>checkComplete!=0 holds the idle signal; we’re not idle if we’re injecting dependencies</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					injectDependencies(module);</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>try to immediately execute
if already traversing a factory tree, then strict causes circular dependency to abort the execution; maybe
it’s possible to execute this require later after the current traversal completes and avoid the circular dependency.
…but <em>always</em> insist on immediate in synch mode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> strict = checkCompleteGuard &amp;&amp; legacyMode !== sync;
					guardCheckComplete(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						execModule(module, strict);
					});
					<span class="hljs-keyword">if</span> (!module.executed) {</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>some deps weren’t on board or circular dependency detected and strict; therefore, push into the execQ</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						execQ.push(module);
					}
					checkComplete();
				}
			}
			<span class="hljs-keyword">return</span> contextRequire;
		}, createRequire = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module)</span> {</span>
			<span class="hljs-keyword">if</span> (!module) {
				<span class="hljs-keyword">return</span> req;
			}
			<span class="hljs-keyword">var</span> result = module.require;
			<span class="hljs-keyword">if</span> (!result) {
				result = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a1, a2, a3)</span> {</span>
					<span class="hljs-keyword">return</span> contextRequire(a1, a2, a3, module, result);
				};
				module.require = mix(result, req);
				result.module = module;
				result.toUrl = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span>
					<span class="hljs-keyword">return</span> toUrl(name, module);
				};
				result.toAbsMid = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid)</span> {</span>
					<span class="hljs-keyword">return</span> toAbsMid(mid, module);
				};
				<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {
					result.undef = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid)</span> {</span>
						req.undef(mid, module);
					};
				}
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
					result.syncLoadNls = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid)</span> {</span>
						<span class="hljs-keyword">var</span> nlsModuleInfo = getModuleInfo(mid, module),
							nlsModule = modules[nlsModuleInfo.mid];
						<span class="hljs-keyword">if</span> (!nlsModule || !nlsModule.executed) {
							cached = cache[nlsModuleInfo.mid] || cache[urlKeyPrefix + nlsModuleInfo.url];
							<span class="hljs-keyword">if</span> (cached) {
								evalModuleText(cached);
								nlsModule = modules[nlsModuleInfo.mid];
							}
						}
						<span class="hljs-keyword">return</span> nlsModule &amp;&amp; nlsModule.executed &amp;&amp; nlsModule.result;
					};
				}
			}
			<span class="hljs-keyword">return</span> result;
		}, execQ = [],
		defQ = [],
		waiting = {}, setRequested = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module)</span> {</span>
			module.injected = requested;
			waiting[module.mid] = <span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span> (module.url) {
				waiting[module.url] = module.pack || <span class="hljs-number">1</span>;
			}
			startTimer();
		}, setArrived = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module)</span> {</span>
			module.injected = arrived;
			<span class="hljs-keyword">delete</span> waiting[module.mid];
			<span class="hljs-keyword">if</span> (module.url) {
				<span class="hljs-keyword">delete</span> waiting[module.url];
			}
			<span class="hljs-keyword">if</span> (isEmpty(waiting)) {
				clearTimer();
				<span class="hljs-number">1</span> &amp;&amp; legacyMode === xd &amp;&amp; (legacyMode = sync);
			}
		}, execComplete = req.idle = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			<span class="hljs-keyword">return</span> !defQ.length &amp;&amp; isEmpty(waiting) &amp;&amp; !execQ.length &amp;&amp; !checkCompleteGuard;
		}, runMapProg = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(targetMid, map)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>search for targetMid in map; return the map item if found; falsy otherwise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (map) {
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; map.length; i++) {
					<span class="hljs-keyword">if</span> (map[i][<span class="hljs-number">2</span>].test(targetMid)) {
						<span class="hljs-keyword">return</span> map[i];
					}
				}
			}
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		}, compactPath = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(path)</span> {</span>
			<span class="hljs-keyword">var</span> result = [],
				segment, lastSegment;
			path = path.replace(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">'/'</span>)
				.split(<span class="hljs-string">'/'</span>);
			<span class="hljs-keyword">while</span> (path.length) {
				segment = path.shift();
				<span class="hljs-keyword">if</span> (segment === <span class="hljs-string">'..'</span> &amp;&amp; result.length &amp;&amp; lastSegment !== <span class="hljs-string">'..'</span>) {
					result.pop();
					lastSegment = result[result.length - <span class="hljs-number">1</span>];
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (segment !== <span class="hljs-string">'.'</span>) {
					result.push(lastSegment = segment);
				} <span class="hljs-comment">// else ignore "."</span>
			}
			<span class="hljs-keyword">return</span> result.join(<span class="hljs-string">'/'</span>);
		}, makeModuleInfo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pid, mid, pack, url)</span> {</span>
			<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
				<span class="hljs-keyword">var</span> xd = req.isXdUrl(url);
				<span class="hljs-keyword">return</span> {
					pid: pid,
					mid: mid,
					pack: pack,
					url: url,
					executed: <span class="hljs-number">0</span>,
					def: <span class="hljs-number">0</span>,
					isXd: xd,
					isAmd: !! (xd || packs[pid] &amp;&amp; packs[pid].isAmd)
				};
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> {
					pid: pid,
					mid: mid,
					pack: pack,
					url: url,
					executed: <span class="hljs-number">0</span>,
					def: <span class="hljs-number">0</span>
				};
			}
		}, getModuleInfo_ = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, alwaysCreate)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)
alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> pid, pack, midInPackage, mapProg, mapItem, url, result, isRelative, requestedMid;
			requestedMid = mid;
			isRelative = <span class="hljs-regexp">/^\./</span>.test(mid);
			<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/(^\/)|(\:)|(\.js$)/</span>.test(mid) || isRelative &amp;&amp; !referenceModule) {</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page
whatever it is, it’s not a module but just a URL of some sort
note: pid===0 indicates the routine is returning an unmodified mid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> makeModuleInfo(<span class="hljs-number">0</span>, mid, <span class="hljs-number">0</span>, mid);
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>relative module ids are relative to the referenceModule; get rid of any dots</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				mid = compactPath(isRelative ? referenceModule.mid + <span class="hljs-string">'/../'</span> + mid : mid);
				<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\./</span>.test(mid)) {
					<span class="hljs-keyword">throw</span> makeError(<span class="hljs-string">'irrationalPath'</span>, mid);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>at this point, mid is an absolute mid
map the mid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (referenceModule) {
					mapItem = runMapProg(referenceModule.mid, mapProgs);
				}
				mapItem = mapItem || mapProgs.star;
				mapItem = mapItem &amp;&amp; runMapProg(mid, mapItem[<span class="hljs-number">1</span>]);
				<span class="hljs-keyword">if</span> (mapItem) {
					mid = mapItem[<span class="hljs-number">1</span>] + mid.substring(mapItem[<span class="hljs-number">3</span>]);
				}
				match = mid.match(<span class="hljs-regexp">/^([^\/]+)(\/(.+))?$/</span>);
				pid = match ? match[<span class="hljs-number">1</span>] : <span class="hljs-string">''</span>;
				<span class="hljs-keyword">if</span> (pack = packs[pid]) {
					mid = pid + <span class="hljs-string">'/'</span> + (midInPackage = match[<span class="hljs-number">3</span>] || pack.main);
				} <span class="hljs-keyword">else</span> {
					pid = <span class="hljs-string">''</span>;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>search aliases</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> candidateLength = <span class="hljs-number">0</span>,
					candidate = <span class="hljs-number">0</span>;
				forEach(aliases, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pair)</span> {</span>
					<span class="hljs-keyword">var</span> match = mid.match(pair[<span class="hljs-number">0</span>]);
					<span class="hljs-keyword">if</span> (match &amp;&amp; match.length &gt; candidateLength) {
						candidate = isFunction(pair[<span class="hljs-number">1</span>]) ? mid.replace(pair[<span class="hljs-number">0</span>], pair[<span class="hljs-number">1</span>]) : pair[<span class="hljs-number">1</span>];
					}
				});
				<span class="hljs-keyword">if</span> (candidate) {
					<span class="hljs-keyword">return</span> getModuleInfo_(candidate, <span class="hljs-number">0</span>, packs, modules, baseUrl, mapProgs, pathsMapProg, alwaysCreate);
				}
				result = modules[mid];
				<span class="hljs-keyword">if</span> (result) {
					<span class="hljs-keyword">return</span> alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the
fully resolved (i.e., all relative indicators and package mapping resolved) module id
note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			mapItem = runMapProg(mid, pathsMapProg);
			<span class="hljs-keyword">if</span> (mapItem) {
				url = mapItem[<span class="hljs-number">1</span>] + mid.substring(mapItem[<span class="hljs-number">3</span>]);
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid) {
				url = pack.location + <span class="hljs-string">'/'</span> + midInPackage;
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (has(<span class="hljs-string">'config-tlmSiblingOfDojo'</span>)) {
				url = <span class="hljs-string">'../'</span> + mid;
			} <span class="hljs-keyword">else</span> {
				url = mid;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>if result is not absolute, add baseUrl</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/(^\/)|(\:)/</span>.test(url)) {
				url = baseUrl + url;
			}
			url += <span class="hljs-string">'.js'</span>;
			<span class="hljs-keyword">return</span> makeModuleInfo(pid, mid, pack, compactPath(url));
		}, getModuleInfo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid, referenceModule)</span> {</span>
			<span class="hljs-keyword">return</span> getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, mapProgs, pathsMapProg);
		}, resolvePluginResourceId = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(plugin, prid, referenceModule)</span> {</span>
			<span class="hljs-keyword">return</span> plugin.normalize ? plugin.normalize(prid, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid)</span> {</span>
				<span class="hljs-keyword">return</span> toAbsMid(mid, referenceModule);
			}) : toAbsMid(prid, referenceModule);
		}, dynamicPluginUidGenerator = <span class="hljs-number">0</span>,
		getModule = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid, referenceModule, immediate)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>compute and optionally construct (if necessary) the module implied by the mid with respect to referenceModule</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> match, plugin, prid, result;
			match = mid.match(<span class="hljs-regexp">/^(.+?)\!(.*)$/</span>);
			<span class="hljs-keyword">if</span> (match) {</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>name was <plugin-module>!<plugin-resource-id></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				plugin = getModule(match[<span class="hljs-number">1</span>], referenceModule, immediate);
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp;&amp; legacyMode === sync &amp;&amp; !plugin.executed) {
					injectModule(plugin);
					<span class="hljs-keyword">if</span> (plugin.injected === arrived &amp;&amp; !plugin.executed) {
						guardCheckComplete(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							execModule(plugin);
						});
					}
					<span class="hljs-keyword">if</span> (plugin.executed) {
						promoteModuleToPlugin(plugin);
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>we are in xdomain mode for some reason</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						execQ.unshift(plugin);
					}
				}
				<span class="hljs-keyword">if</span> (plugin.executed === executed &amp;&amp; !plugin.load) {</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>executed the module not knowing it was a plugin</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					promoteModuleToPlugin(plugin);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>if the plugin has not been loaded, then can’t resolve the prid and  must assume this plugin is dynamic until we find out otherwise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (plugin.load) {
					prid = resolvePluginResourceId(plugin, match[<span class="hljs-number">2</span>], referenceModule);
					mid = plugin.mid + <span class="hljs-string">'!'</span> + (plugin.dynamic ? ++dynamicPluginUidGenerator + <span class="hljs-string">'!'</span> : <span class="hljs-string">''</span>) + prid;
				} <span class="hljs-keyword">else</span> {
					prid = match[<span class="hljs-number">2</span>];
					mid = plugin.mid + <span class="hljs-string">'!'</span> + ++dynamicPluginUidGenerator + <span class="hljs-string">'!waitingForPlugin'</span>;
				}
				result = {
					plugin: plugin,
					mid: mid,
					req: createRequire(referenceModule),
					prid: prid
				};
			} <span class="hljs-keyword">else</span> {
				result = getModuleInfo(mid, referenceModule);
			}
			<span class="hljs-keyword">return</span> modules[result.mid] || !immediate &amp;&amp; (modules[result.mid] = result);
		}, toAbsMid = req.toAbsMid = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid, referenceModule)</span> {</span>
			<span class="hljs-keyword">return</span> getModuleInfo(mid, referenceModule)
				.mid;
		}, toUrl = req.toUrl = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, referenceModule)</span> {</span>
			<span class="hljs-keyword">var</span> moduleInfo = getModuleInfo(name + <span class="hljs-string">'/x'</span>, referenceModule),
				url = moduleInfo.url;
			<span class="hljs-keyword">return</span> fixupUrl(moduleInfo.pid === <span class="hljs-number">0</span> ? name : url.substring(<span class="hljs-number">0</span>, url.length - <span class="hljs-number">5</span>));
		}, nonModuleProps = {
			injected: arrived,
			executed: executed,
			def: nonmodule,
			result: nonmodule
		}, makeCjs = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid)</span> {</span>
			<span class="hljs-keyword">return</span> modules[mid] = mix({
				mid: mid
			}, nonModuleProps);
		}, cjsRequireModule = makeCjs(<span class="hljs-string">'require'</span>),
		cjsExportsModule = makeCjs(<span class="hljs-string">'exports'</span>),
		cjsModuleModule = makeCjs(<span class="hljs-string">'module'</span>),
		runFactory = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module, args)</span> {</span>
			req.trace(<span class="hljs-string">'loader-run-factory'</span>, [module.mid]);
			<span class="hljs-keyword">var</span> factory = module.def,
				result;
			<span class="hljs-number">1</span> &amp;&amp; syncExecStack.unshift(module);
			<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'config-dojo-loader-catches'</span>)) {
				<span class="hljs-keyword">try</span> {
					result = isFunction(factory) ? factory.apply(<span class="hljs-literal">null</span>, args) : factory;
				} <span class="hljs-keyword">catch</span> (e) {
					signal(error, module.result = makeError(<span class="hljs-string">'factoryThrew'</span>, [
						module,
						e
					]));
				}
			} <span class="hljs-keyword">else</span> {
				result = isFunction(factory) ? factory.apply(<span class="hljs-literal">null</span>, args) : factory;
			}
			module.result = result === <span class="hljs-literal">undefined</span> &amp;&amp; module.cjs ? module.cjs.exports : result;
			<span class="hljs-number">1</span> &amp;&amp; syncExecStack.shift(module);
		}, abortExec = {}, defOrder = <span class="hljs-number">0</span>,
		promoteModuleToPlugin = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pluginModule)</span> {</span>
			<span class="hljs-keyword">var</span> plugin = pluginModule.result;
			pluginModule.dynamic = plugin.dynamic;
			pluginModule.normalize = plugin.normalize;
			pluginModule.load = plugin.load;
			<span class="hljs-keyword">return</span> pluginModule;
		}, resolvePluginLoadQ = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(plugin)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>plugins is a newly executed module that has a loadQ waiting to run
step 1: traverse the loadQ and fixup the mid and prid; remember the map from original mid to new mid
recall the original mid was created before the plugin was on board and therefore it was impossible to
compute the final mid; accordingly, prid may or may not change, but the mid will definitely change</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> map = {};
			forEach(plugin.loadQ, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pseudoPluginResource)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>manufacture and insert the real module in modules</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> prid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module),
					mid = plugin.dynamic ? pseudoPluginResource.mid.replace(<span class="hljs-regexp">/waitingForPlugin$/</span>, prid) : plugin.mid + <span class="hljs-string">'!'</span> + prid,
					pluginResource = mix(mix({}, pseudoPluginResource), {
						mid: mid,
						prid: prid,
						injected: <span class="hljs-number">0</span>
					});
				<span class="hljs-keyword">if</span> (!modules[mid]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>create a new (the real) plugin resource and inject it normally now that the plugin is on board</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					injectPlugin(modules[mid] = pluginResource);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>else this was a duplicate request for the same (plugin, rid) for a nondynamic plugin
pluginResource is really just a placeholder with the wrong mid (because we couldn’t calculate it until the plugin was on board)
mark is as arrived and delete it from modules; the real module was requested above</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				map[pseudoPluginResource.mid] = modules[mid];
				setArrived(pseudoPluginResource);
				<span class="hljs-keyword">delete</span> modules[pseudoPluginResource.mid];
			});
			plugin.loadQ = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>step2: replace all references to any placeholder modules with real modules</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> substituteModules = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module)</span> {</span>
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> replacement, deps = module.deps || [], i = <span class="hljs-number">0</span>; i &lt; deps.length; i++) {
					replacement = map[deps[i].mid];
					<span class="hljs-keyword">if</span> (replacement) {
						deps[i] = replacement;
					}
				}
			};
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> modules) {
				substituteModules(modules[p]);
			}
			forEach(execQ, substituteModules);
		}, finishExec = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module)</span> {</span>
			req.trace(<span class="hljs-string">'loader-finish-exec'</span>, [module.mid]);
			module.executed = executed;
			module.defOrder = defOrder++;
			<span class="hljs-number">1</span> &amp;&amp; forEach(module.provides, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> {</span>
				cb();
			});
			<span class="hljs-keyword">if</span> (module.loadQ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>the module was a plugin</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				promoteModuleToPlugin(module);
				resolvePluginLoadQ(module);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>remove all occurences of this module from the execQ</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; execQ.length;) {
				<span class="hljs-keyword">if</span> (execQ[i] === module) {
					execQ.splice(i, <span class="hljs-number">1</span>);
				} <span class="hljs-keyword">else</span> {
					i++;
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>delete references to synthetic modules</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^require\*/</span>.test(module.mid)) {
				<span class="hljs-keyword">delete</span> modules[module.mid];
			}
		}, circleTrace = [],
		execModule = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module, strict)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>run the dependency vector, then run the factory for module</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (module.executed === executing) {
				req.trace(<span class="hljs-string">'loader-circular-dependency'</span>, [circleTrace.concat(module.mid)
					.join(<span class="hljs-string">'-&gt;'</span>)
				]);
				<span class="hljs-keyword">return</span> !module.def || strict ? abortExec : module.cjs &amp;&amp; module.cjs.exports;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>at this point the module is either not executed or fully executed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!module.executed) {
				<span class="hljs-keyword">if</span> (!module.def) {
					<span class="hljs-keyword">return</span> abortExec;
				}
				<span class="hljs-keyword">var</span> mid = module.mid,
					deps = module.deps || [],
					arg, argResult, args = [],
					i = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {
					circleTrace.push(mid);
					req.trace(<span class="hljs-string">'loader-exec-module'</span>, [
						<span class="hljs-string">'exec'</span>,
						circleTrace.length,
						mid
					]);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>for circular dependencies, assume the first module encountered was executed OK
modules that circularly depend on a module that has not run its factory will get
the premade cjs.exports===module.result. They can take a reference to this object and/or
add properties to it. When the module finally runs its factory, the factory can
read/write/replace this object. Notice that so long as the object isn’t replaced, any
reference taken earlier while walking the deps list is still valid.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				module.executed = executing;
				<span class="hljs-keyword">while</span> (i &lt; deps.length) {
					arg = deps[i++];
					argResult = arg === cjsRequireModule ? createRequire(module) : arg === cjsExportsModule ? module.cjs.exports : arg === cjsModuleModule ? module.cjs : execModule(arg, strict);
					<span class="hljs-keyword">if</span> (argResult === abortExec) {
						module.executed = <span class="hljs-number">0</span>;
						req.trace(<span class="hljs-string">'loader-exec-module'</span>, [
							<span class="hljs-string">'abort'</span>,
							mid
						]);
						<span class="hljs-number">0</span> &amp;&amp; circleTrace.pop();
						<span class="hljs-keyword">return</span> abortExec;
					}
					args.push(argResult);
				}
				runFactory(module, args);
				finishExec(module);
				<span class="hljs-number">0</span> &amp;&amp; circleTrace.pop();
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>at this point the module is guaranteed fully executed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> module.result;
		}, checkCompleteGuard = <span class="hljs-number">0</span>,
		guardCheckComplete = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(proc)</span> {</span>
			<span class="hljs-keyword">try</span> {
				checkCompleteGuard++;
				proc();
			} <span class="hljs-keyword">finally</span> {
				checkCompleteGuard--;
			}
			<span class="hljs-keyword">if</span> (execComplete()) {
				signal(<span class="hljs-string">'idle'</span>, []);
			}
		}, checkComplete = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>keep going through the execQ as long as at least one factory is executed
plugins, recursion, cached modules all make for many execution path possibilities</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (checkCompleteGuard) {
				<span class="hljs-keyword">return</span>;
			}
			guardCheckComplete(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
				checkDojoRequirePlugin();
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> currentDefOrder, module, i = <span class="hljs-number">0</span>; i &lt; execQ.length;) {
					currentDefOrder = defOrder;
					module = execQ[i];
					execModule(module);
					<span class="hljs-keyword">if</span> (currentDefOrder !== defOrder) {</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>defOrder was bumped one or more times indicating something was executed (note, this indicates
the execQ was modified, maybe a lot (for example a later module causes an earlier module to execute)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						checkDojoRequirePlugin();
						i = <span class="hljs-number">0</span>;
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>nothing happened; check the next module in the exec queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						i++;
					}
				}
			});
		};
	<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {
		req.undef = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(moduleId, referenceModule)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>In order to reload a module, it must be undefined (this routine) and then re-requested.
This is useful for testing frameworks (at least).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> module = getModule(moduleId, referenceModule);
			setArrived(module);
			<span class="hljs-keyword">delete</span> modules[module.mid];
		};
	}
	<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
		<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'dojo-loader-eval-hint-url'</span>) === <span class="hljs-literal">undefined</span>) {
			has.add(<span class="hljs-string">'dojo-loader-eval-hint-url'</span>, <span class="hljs-number">1</span>);
		}
		<span class="hljs-keyword">var</span> fixupUrl = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(url)</span> {</span>
			url += <span class="hljs-string">''</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>make sure url is a Javascript string (some paths may be a Java string)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> url + (cacheBust ? (<span class="hljs-regexp">/\?/</span>.test(url) ? <span class="hljs-string">'&amp;'</span> : <span class="hljs-string">'?'</span>) + cacheBust : <span class="hljs-string">''</span>);
		}, injectPlugin = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>injects the plugin module given by module; may have to inject the plugin itself</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> plugin = module.plugin;
				<span class="hljs-keyword">if</span> (plugin.executed === executed &amp;&amp; !plugin.load) {</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>executed the module not knowing it was a plugin</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					promoteModuleToPlugin(plugin);
				}
				<span class="hljs-keyword">var</span> onLoad = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(def)</span> {</span>
					module.result = def;
					setArrived(module);
					finishExec(module);
					checkComplete();
				};
				<span class="hljs-keyword">if</span> (plugin.load) {
					plugin.load(module.prid, module.req, onLoad);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (plugin.loadQ) {
					plugin.loadQ.push(module);
				} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>the unshift instead of push is important: we don’t want plugins to execute as
dependencies of some other module because this may cause circles when the plugin
loadQ is run; also, generally, we want plugins to run early since they may load
several other modules and therefore can potentially unblock many modules</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					plugin.loadQ = [module];
					execQ.unshift(plugin);
					injectModule(plugin);
				}
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>for IE, injecting a module may result in a recursive execution if the module is in the cache</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			cached = <span class="hljs-number">0</span>,
			injectingModule = <span class="hljs-number">0</span>,
			injectingCachedModule = <span class="hljs-number">0</span>,
			evalModuleText = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text, module)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>see def() for the injectingCachedModule bracket; it simply causes a short, safe curcuit</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'config-stripStrict'</span>)) {
					text = text.replace(<span class="hljs-regexp">/"use strict"/g</span>, <span class="hljs-string">''</span>);
				}
				injectingCachedModule = <span class="hljs-number">1</span>;
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'config-dojo-loader-catches'</span>)) {
					<span class="hljs-keyword">try</span> {
						<span class="hljs-keyword">if</span> (text === cached) {
							cached.call(<span class="hljs-literal">null</span>);
						} <span class="hljs-keyword">else</span> {
							req.eval(text, has(<span class="hljs-string">'dojo-loader-eval-hint-url'</span>) ? module.url : module.mid);
						}
					} <span class="hljs-keyword">catch</span> (e) {
						signal(error, makeError(<span class="hljs-string">'evalModuleThrew'</span>, module));
					}
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">if</span> (text === cached) {
						cached.call(<span class="hljs-literal">null</span>);
					} <span class="hljs-keyword">else</span> {
						req.eval(text, has(<span class="hljs-string">'dojo-loader-eval-hint-url'</span>) ? module.url : module.mid);
					}
				}
				injectingCachedModule = <span class="hljs-number">0</span>;
			}, injectModule = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>Inject the module. In the browser environment, this means appending a script element into
the document; in other environments, it means loading a file.</p>
<p>If in synchronous mode, then get the module synchronously if it’s not xdomainLoading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> mid = module.mid,
					url = module.url;
				<span class="hljs-keyword">if</span> (module.executed || module.injected || waiting[mid] || module.url &amp;&amp; (module.pack &amp;&amp; waiting[module.url] === module.pack || waiting[module.url] === <span class="hljs-number">1</span>)) {
					<span class="hljs-keyword">return</span>;
				}
				setRequested(module);
				<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {
					<span class="hljs-keyword">var</span> viaCombo = <span class="hljs-number">0</span>;
					<span class="hljs-keyword">if</span> (module.plugin &amp;&amp; module.plugin.isCombo) {</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>a combo plugin; therefore, must be handled by combo service
the prid should have already been converted to a URL (if required by the plugin) during
the normalze process; in any event, there is no way for the loader to know how to
to the conversion; therefore the third argument is zero</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						req.combo.add(module.plugin.mid, module.prid, <span class="hljs-number">0</span>, req);
						viaCombo = <span class="hljs-number">1</span>;
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!module.plugin) {
						viaCombo = req.combo.add(<span class="hljs-number">0</span>, module.mid, module.url, req);
					}
					<span class="hljs-keyword">if</span> (viaCombo) {
						comboPending = <span class="hljs-number">1</span>;
						<span class="hljs-keyword">return</span>;
					}
				}
				<span class="hljs-keyword">if</span> (module.plugin) {
					injectPlugin(module);
					<span class="hljs-keyword">return</span>;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>else a normal module (not a plugin)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> onLoadCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					runDefQ(module);
					<span class="hljs-keyword">if</span> (module.injected !== arrived) {</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>the script that contained the module arrived and has been executed yet
nothing was added to the defQ (so it wasn’t an AMD module) and the module
wasn’t marked as arrived by dojo.provide (so it wasn’t a v1.6- module);
therefore, it must not have been a module; adjust state accordingly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						setArrived(module);
						mix(module, nonModuleProps);
						req.trace(<span class="hljs-string">'loader-define-nonmodule'</span>, [module.url]);
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp;&amp; legacyMode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>must call checkComplete even in for sync loader because we may be in xdomainLoading mode;
but, if xd loading, then don’t call checkComplete until out of the current sync traversal
in order to preserve order of execution of the dojo.required modules</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						!syncExecStack.length &amp;&amp; checkComplete();
					} <span class="hljs-keyword">else</span> {
						checkComplete();
					}
				};
				cached = cache[mid] || cache[urlKeyPrefix + module.url];
				<span class="hljs-keyword">if</span> (cached) {
					req.trace(<span class="hljs-string">'loader-inject'</span>, [
						<span class="hljs-string">'cache'</span>,
						module.mid,
						url
					]);
					evalModuleText(cached, module);
					onLoadCallback();
					<span class="hljs-keyword">return</span>;
				}
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp;&amp; legacyMode) {
					<span class="hljs-keyword">if</span> (module.isXd) {</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>switch to async mode temporarily; if current legacyMode!=sync, then is must be one of {legacyAsync, xd, false}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						legacyMode === sync &amp;&amp; (legacyMode = xd); <span class="hljs-comment">// fall through and load via script injection</span>
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (module.isAmd &amp;&amp; legacyMode !== sync) {} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>mode may be sync, xd/legacyAsync, or async; module may be AMD or legacy; but module is always located on the same domain</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> xhrCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text)</span> {</span>
							<span class="hljs-keyword">if</span> (legacyMode === sync) {</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>the top of syncExecStack gives the current synchronously executing module; the loader needs
to know this if it has to switch to async loading in the middle of evaluating a legacy module
this happens when a modules dojo.require’s a module that must be loaded async because it’s xdomain
(using unshift/shift because there is no back() methods for Javascript arrays)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								syncExecStack.unshift(module);
								evalModuleText(text, module);
								syncExecStack.shift();</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>maybe the module was an AMD module</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								runDefQ(module);</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>legacy modules never get to defineModule() =&gt; cjs and injected never set; also evaluation implies executing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (!module.cjs) {
									setArrived(module);
									finishExec(module);
								}
								<span class="hljs-keyword">if</span> (module.finish) {</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>while synchronously evaluating this module, dojo.require was applied referencing a module
that had to be loaded async; therefore, the loader stopped answering all dojo.require
requests so they could be answered completely in the correct sequence; module.finish gives
the list of dojo.requires that must be re-applied once all target modules are available;
make a synthetic module to execute the dojo.require’s in the correct order
compute a guarnateed-unique mid for the synthetic finish module; remember the finish vector; remove it from the reference module
TODO: can we just leave the module.finish…what’s it hurting?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-keyword">var</span> finishMid = mid + <span class="hljs-string">'*finish'</span>,
										finish = module.finish;
									<span class="hljs-keyword">delete</span> module.finish;
									def(finishMid, [
										<span class="hljs-string">'dojo'</span>, (<span class="hljs-string">'dojo/require!'</span> + finish.join(<span class="hljs-string">','</span>))
										.replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">'/'</span>)
									], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo)</span> {</span>
										forEach(finish, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid)</span> {</span>
											dojo.require(mid);
										});
									});</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>unshift, not push, which causes the current traversal to be reattempted from the top</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									execQ.unshift(getModule(finishMid));
								}
								onLoadCallback();
							} <span class="hljs-keyword">else</span> {
								text = transformToAmd(module, text);
								<span class="hljs-keyword">if</span> (text) {
									evalModuleText(text, module);
									onLoadCallback();
								} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>if transformToAmd returned falsy, then the module was already AMD and it can be script-injected
do so to improve debugability(even though it means another download…which probably won’t happen with a good browser cache)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									injectingModule = module;
									req.injectUrl(fixupUrl(url), onLoadCallback, module);
									injectingModule = <span class="hljs-number">0</span>;
								}
							}
						};
						req.trace(<span class="hljs-string">'loader-inject'</span>, [
							<span class="hljs-string">'xhr'</span>,
							module.mid,
							url,
							legacyMode !== sync
						]);
						<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'config-dojo-loader-catches'</span>)) {
							<span class="hljs-keyword">try</span> {
								req.getText(url, legacyMode !== sync, xhrCallback);
							} <span class="hljs-keyword">catch</span> (e) {
								signal(error, makeError(<span class="hljs-string">'xhrInjectFailed'</span>, [
									module,
									e
								]));
							}
						} <span class="hljs-keyword">else</span> {
							req.getText(url, legacyMode !== sync, xhrCallback);
						}
						<span class="hljs-keyword">return</span>;
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>else async mode or fell through in xdomain loading mode; either way, load by script injection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				req.trace(<span class="hljs-string">'loader-inject'</span>, [
					<span class="hljs-string">'script'</span>,
					module.mid,
					url
				]);
				injectingModule = module;
				req.injectUrl(fixupUrl(url), onLoadCallback, module);
				injectingModule = <span class="hljs-number">0</span>;
			}, defineModule = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module, deps, def)</span> {</span>
				req.trace(<span class="hljs-string">'loader-define-module'</span>, [
					module.mid,
					deps
				]);
				<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &amp;&amp; module.plugin &amp;&amp; module.plugin.isCombo) {</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>the module is a plugin resource loaded by the combo service
note: check for module.plugin should be enough since normal plugin resources should
not follow this path; module.plugin.isCombo is future-proofing belt and suspenders</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					module.result = isFunction(def) ? def() : def;
					setArrived(module);
					finishExec(module);
					<span class="hljs-keyword">return</span> module;
				}
				<span class="hljs-keyword">var</span> mid = module.mid;
				<span class="hljs-keyword">if</span> (module.injected === arrived) {
					signal(error, makeError(<span class="hljs-string">'multipleDefine'</span>, module));
					<span class="hljs-keyword">return</span> module;
				}
				mix(module, {
					deps: deps,
					def: def,
					cjs: {
						id: module.mid,
						uri: module.url,
						exports: module.result = {},
						setExports: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports)</span> {</span>
							module.cjs.exports = exports;
						},
						config: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							<span class="hljs-keyword">return</span> module.config;
						}
					}
				});</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>resolve deps with respect to this module</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; deps.length; i++) {
					deps[i] = getModule(deps[i], module);
				}
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp;&amp; legacyMode &amp;&amp; !waiting[mid]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>the module showed up without being asked for; it was probably in a <script> element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					injectDependencies(module);
					execQ.push(module);
					checkComplete();
				}
				setArrived(module);
				<span class="hljs-keyword">if</span> (!isFunction(def) &amp;&amp; !deps.length) {
					module.result = def;
					finishExec(module);
				}
				<span class="hljs-keyword">return</span> module;
			}, runDefQ = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(referenceModule, mids)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>defQ is an array of [id, dependencies, factory]
mids (if any) is a vector of mids given by a combo service</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> definedModules = [],
					module, args;
				<span class="hljs-keyword">while</span> (defQ.length) {
					args = defQ.shift();
					mids &amp;&amp; (args[<span class="hljs-number">0</span>] = mids.shift());</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>explicit define indicates possible multiple modules in a single file; delay injecting dependencies until defQ fully
processed since modules earlier in the queue depend on already-arrived modules that are later in the queue
TODO: what if no args[0] and no referenceModule</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					module = args[<span class="hljs-number">0</span>] &amp;&amp; getModule(args[<span class="hljs-number">0</span>]) || referenceModule;
					definedModules.push([
						module,
						args[<span class="hljs-number">1</span>],
						args[<span class="hljs-number">2</span>]
					]);
				}
				consumePendingCacheInsert(referenceModule);
				forEach(definedModules, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(args)</span> {</span>
					injectDependencies(defineModule.apply(<span class="hljs-literal">null</span>, args));
				});
			};
	}
	<span class="hljs-keyword">var</span> timerId = <span class="hljs-number">0</span>,
		clearTimer = noop,
		startTimer = noop;
	<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>Timer machinery that monitors how long the loader is waiting and signals an error when the timer runs out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		clearTimer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			timerId &amp;&amp; clearTimeout(timerId);
			timerId = <span class="hljs-number">0</span>;
		}, startTimer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			clearTimer();
			<span class="hljs-keyword">if</span> (req.waitms) {
				timerId = window.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					clearTimer();
					signal(error, makeError(<span class="hljs-string">'timeout'</span>, waiting));
				}, req.waitms);
			}
		};
	}
	<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>the typically unnecessary !! in front of doc.attachEvent is due to an opera bug; see    #15096</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		has.add(<span class="hljs-string">'ie-event-behavior'</span>, !! doc.attachEvent &amp;&amp; (<span class="hljs-keyword">typeof</span> opera === <span class="hljs-string">'undefined'</span> || opera.toString() !== <span class="hljs-string">'[object Opera]'</span>));
	}
	<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp;&amp; (<span class="hljs-number">1</span> || <span class="hljs-number">1</span>)) {
		<span class="hljs-keyword">var</span> domOn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, eventName, ieEventName, handler)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>Add an event listener to a DOM node using the API appropriate for the current browser;
return a function that will disconnect the listener.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!has(<span class="hljs-string">'ie-event-behavior'</span>)) {
				node.addEventListener(eventName, handler, <span class="hljs-literal">false</span>);
				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					node.removeEventListener(eventName, handler, <span class="hljs-literal">false</span>);
				};
			} <span class="hljs-keyword">else</span> {
				node.attachEvent(ieEventName, handler);
				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					node.detachEvent(ieEventName, handler);
				};
			}
		}, windowOnLoadListener = domOn(window, <span class="hljs-string">'load'</span>, <span class="hljs-string">'onload'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
				req.pageLoaded = <span class="hljs-number">1</span>;
				doc.readyState !== <span class="hljs-string">'complete'</span> &amp;&amp; (doc.readyState = <span class="hljs-string">'complete'</span>);
				windowOnLoadListener();
			});
		<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>if the loader is on the page, there must be at least one script element
getting its parent and then doing insertBefore solves the “Operation Aborted”
error in IE from appending to a node that isn’t properly closed; see
dojo/tests/_base/loader/requirejs/simple-badbase.html for an example</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> sibling = doc.getElementsByTagName(<span class="hljs-string">'script'</span>)[<span class="hljs-number">0</span>],
				insertPoint = sibling.parentNode;
			req.injectUrl = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(url, callback, owner)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>insert a script element to the insert-point element with src=url;
apply callback upon detecting the script has loaded.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> node = owner.node = doc.createElement(<span class="hljs-string">'script'</span>),
					onLoad = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
						e = e || window.event;
						<span class="hljs-keyword">var</span> node = e.target || e.srcElement;
						<span class="hljs-keyword">if</span> (e.type === <span class="hljs-string">'load'</span> || <span class="hljs-regexp">/complete|loaded/</span>.test(node.readyState)) {
							loadDisconnector();
							errorDisconnector();
							callback &amp;&amp; callback();
						}
					}, loadDisconnector = domOn(node, <span class="hljs-string">'load'</span>, <span class="hljs-string">'onreadystatechange'</span>, onLoad),
					errorDisconnector = domOn(node, <span class="hljs-string">'error'</span>, <span class="hljs-string">'onerror'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
						loadDisconnector();
						errorDisconnector();
						signal(error, makeError(<span class="hljs-string">'scriptError'</span>, [
							url,
							e
						]));
					});
				node.type = <span class="hljs-string">'text/javascript'</span>;
				node.charset = <span class="hljs-string">'utf-8'</span>;
				node.src = url;
				insertPoint.insertBefore(node, sibling);
				<span class="hljs-keyword">return</span> node;
			};
		}
	}
	<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
		req.log = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			<span class="hljs-keyword">try</span> {
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) {
					console.log(<span class="hljs-built_in">arguments</span>[i]);
				}
			} <span class="hljs-keyword">catch</span> (e) {}
		};
	} <span class="hljs-keyword">else</span> {
		req.log = noop;
	}
	<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {
		<span class="hljs-keyword">var</span> trace = req.trace = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(group, args)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>/
Tracing interface by group.</p>
<p>Sends the contents of args to the console iff (req.trace.on &amp;&amp; req.trace[group])</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (trace.on &amp;&amp; trace.group[group]) {
				signal(<span class="hljs-string">'trace'</span>, [
					group,
					args
				]);
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> arg, dump = [], text = <span class="hljs-string">'trace:'</span> + group + (args.length ? <span class="hljs-string">':'</span> + args[<span class="hljs-number">0</span>] : <span class="hljs-string">''</span>), i = <span class="hljs-number">1</span>; i &lt; args.length;) {
					arg = args[i++];
					<span class="hljs-keyword">if</span> (isString(arg)) {
						text += <span class="hljs-string">', '</span> + arg;
					} <span class="hljs-keyword">else</span> {
						dump.push(arg);
					}
				}
				req.log(text);
				dump.length &amp;&amp; dump.push(<span class="hljs-string">'.'</span>);
				req.log.apply(req, dump);
			}
		};
		mix(trace, {
			on: <span class="hljs-number">1</span>,
			group: {},
			set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(group, value)</span> {</span>
				<span class="hljs-keyword">if</span> (isString(group)) {
					trace.group[group] = value;
				} <span class="hljs-keyword">else</span> {
					mix(trace.group, group);
				}
			}
		});
		trace.set(mix(mix(mix({}, defaultConfig.trace), userConfig.trace), dojoSniffConfig.trace));
		on(<span class="hljs-string">'config'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(config)</span> {</span>
			config.trace &amp;&amp; trace.set(config.trace);
		});
	} <span class="hljs-keyword">else</span> {
		req.trace = noop;
	}
	<span class="hljs-keyword">var</span> def = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid, dependencies, factory)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>/
Advises the loader of a module factory. //Implements <a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition</a>.
/
note
CommonJS factory scan courtesy of <a href="http://requirejs.org">http://requirejs.org</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> arity = <span class="hljs-built_in">arguments</span>.length,
			defaultDeps = [
				<span class="hljs-string">'require'</span>,
				<span class="hljs-string">'exports'</span>,
				<span class="hljs-string">'module'</span>
			],</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>the predominate signature…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			args = [
				<span class="hljs-number">0</span>,
				mid,
				dependencies
			];
		<span class="hljs-keyword">if</span> (arity === <span class="hljs-number">1</span>) {
			args = [
				<span class="hljs-number">0</span>,
				isFunction(mid) ? defaultDeps : [],
				mid
			];
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arity === <span class="hljs-number">2</span> &amp;&amp; isString(mid)) {
			args = [
				mid,
				isFunction(dependencies) ? defaultDeps : [],
				dependencies
			];
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arity === <span class="hljs-number">3</span>) {
			args = [
				mid,
				dependencies,
				factory
			];
		}
		<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">1</span>] === defaultDeps) {
			args[<span class="hljs-number">2</span>].toString()
				.replace(<span class="hljs-regexp">/(\/\*([\s\S]*?)\*\/|\/\/(.*)$)/gm</span>, <span class="hljs-string">''</span>)
				.replace(<span class="hljs-regexp">/require\(["']([\w\!\-_\.\/]+)["']\)/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(match, dep)</span> {</span>
					args[<span class="hljs-number">1</span>].push(dep);
				});
		}
		req.trace(<span class="hljs-string">'loader-define'</span>, args.slice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>));
		<span class="hljs-keyword">var</span> targetModule = args[<span class="hljs-number">0</span>] &amp;&amp; getModule(args[<span class="hljs-number">0</span>]),
			module;
		<span class="hljs-keyword">if</span> (targetModule &amp;&amp; !waiting[targetModule.mid]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>given a mid that hasn’t been requested; therefore, defined through means other than injecting
consequent to a require() or define() application; examples include defining modules on-the-fly
due to some code path or including a module in a script element. In any case,
there is no callback waiting to finish processing and nothing to trigger the defQ and the
dependencies are never requested; therefore, do it here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			injectDependencies(defineModule(targetModule, args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>]));
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!has(<span class="hljs-string">'ie-event-behavior'</span>) || !<span class="hljs-number">1</span> || injectingCachedModule) {</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>not IE path: anonymous module and therefore must have been injected; therefore, onLoad will fire immediately
after script finishes being evaluated and the defQ can be run from that callback to detect the module id</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			defQ.push(args);
		} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>IE path: possibly anonymous module and therefore injected; therefore, cannot depend on 1-to-1,
in-order exec of onLoad with script eval (since it’s IE) and must manually detect here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			targetModule = targetModule || injectingModule;
			<span class="hljs-keyword">if</span> (!targetModule) {
				<span class="hljs-keyword">for</span> (mid <span class="hljs-keyword">in</span> waiting) {
					module = modules[mid];
					<span class="hljs-keyword">if</span> (module &amp;&amp; module.node &amp;&amp; module.node.readyState === <span class="hljs-string">'interactive'</span>) {
						targetModule = module;
						<span class="hljs-keyword">break</span>;
					}
				}
				<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &amp;&amp; !targetModule) {
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; combosPending.length; i++) {
						targetModule = combosPending[i];
						<span class="hljs-keyword">if</span> (targetModule.node &amp;&amp; targetModule.node.readyState === <span class="hljs-string">'interactive'</span>) {
							<span class="hljs-keyword">break</span>;
						}
						targetModule = <span class="hljs-number">0</span>;
					}
				}
			}
			<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &amp;&amp; isArray(targetModule)) {
				injectDependencies(defineModule(getModule(targetModule.shift()), args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>]));
				<span class="hljs-keyword">if</span> (!targetModule.length) {
					combosPending.splice(i, <span class="hljs-number">1</span>);
				}
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetModule) {
				consumePendingCacheInsert(targetModule);
				injectDependencies(defineModule(targetModule, args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>]));
			} <span class="hljs-keyword">else</span> {
				signal(error, makeError(<span class="hljs-string">'ieDefineFailed'</span>, args[<span class="hljs-number">0</span>]));
			}
			checkComplete();
		}
	};
	def.amd = {
		vendor: <span class="hljs-string">'dojotoolkit.org'</span>
	};
	<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {
		req.def = def;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>allow config to override default implemention of named functions; this is useful for
non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.
also useful for testing and monkey patching loader</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	mix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>now that req is fully initialized and won’t change, we can hook it up to the error signal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	on(error, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg)</span> {</span>
		<span class="hljs-keyword">try</span> {
			console.error(arg);
			<span class="hljs-keyword">if</span> (arg <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>) {
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> arg) {
					console.log(p + <span class="hljs-string">':'</span>, arg[p]);
				}
				console.log(<span class="hljs-string">'.'</span>);
			}
		} <span class="hljs-keyword">catch</span> (e) {}
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>always publish these</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	mix(req, {
		uid: uid,
		cache: cache,
		packs: packs
	});
	<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {
		mix(req, {
			paths: paths,
			aliases: aliases,
			modules: modules,
			legacyMode: legacyMode,
			execQ: execQ,
			defQ: defQ,
			waiting: waiting,
			packs: packs,
			mapProgs: mapProgs,
			pathsMapProg: pathsMapProg,
			listenerQueues: listenerQueues,
			computeMapProg: computeMapProg,
			runMapProg: runMapProg,
			compactPath: compactPath,
			getModuleInfo: getModuleInfo_
		});
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>the loader can be defined exactly once; look for global define which is the symbol AMD loaders are
<em>required</em> to define (as opposed to require, which is optional)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (global.define) {
		<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
			signal(error, makeError(<span class="hljs-string">'defineAlreadyDefined'</span>, <span class="hljs-number">0</span>));
		}
		<span class="hljs-keyword">return</span>;
	} <span class="hljs-keyword">else</span> {
		global.define = def;
		global.require = req;
		<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {
			<span class="hljs-built_in">require</span> = req;
		}
	}
	<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &amp;&amp; req.combo &amp;&amp; req.combo.plugins) {
		<span class="hljs-keyword">var</span> plugins = req.combo.plugins,
			pluginName;
		<span class="hljs-keyword">for</span> (pluginName <span class="hljs-keyword">in</span> plugins) {
			mix(mix(getModule(pluginName), plugins[pluginName]), {
				isCombo: <span class="hljs-number">1</span>,
				executed: <span class="hljs-string">'executed'</span>,
				load: <span class="hljs-number">1</span>
			});
		}
	}
	<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
		forEach(delayedModuleConfig, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(c)</span> {</span>
			config(c);
		});
		<span class="hljs-keyword">var</span> bootDeps = dojoSniffConfig.deps || userConfig.deps || defaultConfig.deps,
			bootCallback = dojoSniffConfig.callback || userConfig.callback || defaultConfig.callback;
		req.boot = bootDeps || bootCallback ? [
			bootDeps || [],
			bootCallback
		] : <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">if</span> (!<span class="hljs-number">1</span>) {
		!req.async &amp;&amp; req([<span class="hljs-string">'dojo'</span>]);
		req.boot &amp;&amp; req.apply(<span class="hljs-literal">null</span>, req.boot);
	}
}(<span class="hljs-keyword">this</span>.dojoConfig || <span class="hljs-keyword">this</span>.djConfig || <span class="hljs-keyword">this</span>.require || {}, {
	async: <span class="hljs-number">0</span>,
	hasCache: {
		<span class="hljs-string">'config-selectorEngine'</span>: <span class="hljs-string">'acme'</span>,
		<span class="hljs-string">'config-tlmSiblingOfDojo'</span>: <span class="hljs-number">1</span>,
		<span class="hljs-string">'dojo-built'</span>: <span class="hljs-number">1</span>,
		<span class="hljs-string">'dojo-loader'</span>: <span class="hljs-number">1</span>,
		dom: <span class="hljs-number">1</span>,
		<span class="hljs-string">'host-browser'</span>: <span class="hljs-number">1</span>
	},
	packages: [{
		location: <span class="hljs-string">'../dijit'</span>,
		name: <span class="hljs-string">'dijit'</span>
	}, {
		location: <span class="hljs-string">'../dojox'</span>,
		name: <span class="hljs-string">'dojox'</span>
	}, {
		location: <span class="hljs-string">'.'</span>,
		name: <span class="hljs-string">'dojo'</span>
	}]
}));
<span class="hljs-built_in">require</span>({
	cache: {
		<span class="hljs-string">'dojo/_base/fx'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'./config'</span>,
				<span class="hljs-string">'./lang'</span>,
				<span class="hljs-string">'../Evented'</span>,
				<span class="hljs-string">'./Color'</span>,
				<span class="hljs-string">'./connect'</span>,
				<span class="hljs-string">'./sniff'</span>,
				<span class="hljs-string">'../dom'</span>,
				<span class="hljs-string">'../dom-style'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, config, lang, Evented, Color, connect, has, dom, style)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>module:
    dojo/_base/fx
notes:
    Animation loosely package based on Dan Pupius’ work, contributed under CLA; see
    <a href="http://pupius.co.uk/js/Toolkit.Drawing.js">http://pupius.co.uk/js/Toolkit.Drawing.js</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> _mixin = lang.mixin;</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>Module export</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> basefx = {};
				<span class="hljs-keyword">var</span> _Line = basefx._Line = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(start, end)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>summary:
    Object used to generate values from a start value to an end value
start: int
    Beginning value for range
end: int
    Ending value for range</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">this</span>.start = start;
					<span class="hljs-keyword">this</span>.end = end;
				};
				_Line.prototype.getValue = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>summary:
    Returns the point on the line
n:
    a floating point number greater than 0 and less than 1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.end - <span class="hljs-keyword">this</span>.start) * n + <span class="hljs-keyword">this</span>.start; <span class="hljs-comment">// Decimal</span>
				};
				<span class="hljs-keyword">var</span> Animation = basefx.Animation = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(args)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>summary:
    A generic animation class that fires callbacks into its handlers
    object at various states.
description:
    A generic animation class that fires callbacks into its handlers
    object at various states. Nearly all dojo animation functions
    return an instance of this method, usually without calling the
    .play() method beforehand. Therefore, you will likely need to
    call .play() on instances of <code>Animation</code> when one is
    returned.
args: Object
    The ‘magic argument’, mixing all the properties into this
    animation instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					_mixin(<span class="hljs-keyword">this</span>, args);
					<span class="hljs-keyword">if</span> (lang.isArray(<span class="hljs-keyword">this</span>.curve)) {
						<span class="hljs-keyword">this</span>.curve = <span class="hljs-keyword">new</span> _Line(<span class="hljs-keyword">this</span>.curve[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.curve[<span class="hljs-number">1</span>]);
					}
				};
				Animation.prototype = <span class="hljs-keyword">new</span> Evented();
				lang.extend(Animation, {
					duration: <span class="hljs-number">350</span>,
					repeat: <span class="hljs-number">0</span>,
					rate: <span class="hljs-number">20</span>,
					_percent: <span class="hljs-number">0</span>,
					_startRepeatCount: <span class="hljs-number">0</span>,
					_getStep: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">var</span> _p = <span class="hljs-keyword">this</span>._percent,
							_e = <span class="hljs-keyword">this</span>.easing;
						<span class="hljs-keyword">return</span> _e ? _e(_p) : _p;
					},
					_fire: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt, args)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>summary:
    Convenience function.  Fire event “evt” and pass it the
    arguments specified in “args”.
description:
    Convenience function.  Fire event “evt” and pass it the
    arguments specified in “args”.
    Fires the callback in the scope of this Animation
    instance.
evt:
    The event to fire.
args:
    The arguments to pass to the event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> a = args || [];
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[evt]) {
							<span class="hljs-keyword">if</span> (config.debugAtAllCosts) {
								<span class="hljs-keyword">this</span>[evt].apply(<span class="hljs-keyword">this</span>, a);
							} <span class="hljs-keyword">else</span> {
								<span class="hljs-keyword">try</span> {
									<span class="hljs-keyword">this</span>[evt].apply(<span class="hljs-keyword">this</span>, a);
								} <span class="hljs-keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>squelch and log because we shouldn’t allow exceptions in
synthetic event handlers to cause the internal timer to run
amuck, potentially pegging the CPU. I’m not a fan of this
squelch, but hopefully logging will make it clear what’s
going on</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									console.error(<span class="hljs-string">'exception in animation handler for:'</span>, evt);
									console.error(e);
								}
							}
						}
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// Animation</span>
					},
					play: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(delay, gotoStart)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <p>summary:
    Start the animation.
delay:
    How many milliseconds to delay before starting.
gotoStart:
    If true, starts the animation from the beginning; otherwise,
    starts it from its current position.
returns: Animation
    The instance to allow chaining.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> _t = <span class="hljs-keyword">this</span>;
						<span class="hljs-keyword">if</span> (_t._delayTimer) {
							_t._clearTimer();
						}
						<span class="hljs-keyword">if</span> (gotoStart) {
							_t._stopTimer();
							_t._active = _t._paused = <span class="hljs-literal">false</span>;
							_t._percent = <span class="hljs-number">0</span>;
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_t._active &amp;&amp; !_t._paused) {
							<span class="hljs-keyword">return</span> _t;
						}
						_t._fire(<span class="hljs-string">'beforeBegin'</span>, [_t.node]);
						<span class="hljs-keyword">var</span> de = delay || _t.delay,
							_p = lang.hitch(_t, <span class="hljs-string">'_play'</span>, gotoStart);
						<span class="hljs-keyword">if</span> (de &gt; <span class="hljs-number">0</span>) {
							_t._delayTimer = setTimeout(_p, de);
							<span class="hljs-keyword">return</span> _t;
						}
						_p();
						<span class="hljs-keyword">return</span> _t; <span class="hljs-comment">// Animation</span>
					},
					_play: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(gotoStart)</span> {</span>
						<span class="hljs-keyword">var</span> _t = <span class="hljs-keyword">this</span>;
						<span class="hljs-keyword">if</span> (_t._delayTimer) {
							_t._clearTimer();
						}
						_t._startTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
							.valueOf();
						<span class="hljs-keyword">if</span> (_t._paused) {
							_t._startTime -= _t.duration * _t._percent;
						}
						_t._active = <span class="hljs-literal">true</span>;
						_t._paused = <span class="hljs-literal">false</span>;
						<span class="hljs-keyword">var</span> value = _t.curve.getValue(_t._getStep());
						<span class="hljs-keyword">if</span> (!_t._percent) {
							<span class="hljs-keyword">if</span> (!_t._startRepeatCount) {
								_t._startRepeatCount = _t.repeat;
							}
							_t._fire(<span class="hljs-string">'onBegin'</span>, [value]);
						}
						_t._fire(<span class="hljs-string">'onPlay'</span>, [value]);
						_t._cycle();
						<span class="hljs-keyword">return</span> _t; <span class="hljs-comment">// Animation</span>
					},
					pause: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>summary:
    Pauses a running animation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> _t = <span class="hljs-keyword">this</span>;
						<span class="hljs-keyword">if</span> (_t._delayTimer) {
							_t._clearTimer();
						}
						_t._stopTimer();
						<span class="hljs-keyword">if</span> (!_t._active) {
							<span class="hljs-keyword">return</span> _t; <span class="hljs-comment">/*Animation*/</span>
						}
						_t._paused = <span class="hljs-literal">true</span>;
						_t._fire(<span class="hljs-string">'onPause'</span>, [_t.curve.getValue(_t._getStep())]);
						<span class="hljs-keyword">return</span> _t; <span class="hljs-comment">// Animation</span>
					},
					gotoPercent: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(percent, andPlay)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <p>summary:
    Sets the progress of the animation.
percent:
    A percentage in decimal notation (between and including 0.0 and 1.0).
andPlay:
    If true, play the animation after setting the progress.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> _t = <span class="hljs-keyword">this</span>;
						_t._stopTimer();
						_t._active = _t._paused = <span class="hljs-literal">true</span>;
						_t._percent = percent;
						<span class="hljs-keyword">if</span> (andPlay) {
							_t.play();
						}
						<span class="hljs-keyword">return</span> _t; <span class="hljs-comment">// Animation</span>
					},
					stop: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(gotoEnd)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <p>summary:
    Stops a running animation.
gotoEnd:
    If true, the animation will end.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> _t = <span class="hljs-keyword">this</span>;
						<span class="hljs-keyword">if</span> (_t._delayTimer) {
							_t._clearTimer();
						}
						<span class="hljs-keyword">if</span> (!_t._timer) {
							<span class="hljs-keyword">return</span> _t; <span class="hljs-comment">/* Animation */</span>
						}
						_t._stopTimer();
						<span class="hljs-keyword">if</span> (gotoEnd) {
							_t._percent = <span class="hljs-number">1</span>;
						}
						_t._fire(<span class="hljs-string">'onStop'</span>, [_t.curve.getValue(_t._getStep())]);
						_t._active = _t._paused = <span class="hljs-literal">false</span>;
						<span class="hljs-keyword">return</span> _t; <span class="hljs-comment">// Animation</span>
					},
					status: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <p>summary:
    Returns a string token representation of the status of
    the animation, one of: “paused”, “playing”, “stopped”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._active) {
							<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._paused ? <span class="hljs-string">'paused'</span> : <span class="hljs-string">'playing'</span>; <span class="hljs-comment">// String</span>
						}
						<span class="hljs-keyword">return</span> <span class="hljs-string">'stopped'</span>; <span class="hljs-comment">// String</span>
					},
					_cycle: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">var</span> _t = <span class="hljs-keyword">this</span>;
						<span class="hljs-keyword">if</span> (_t._active) {
							<span class="hljs-keyword">var</span> curr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
								.valueOf();</pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <p>Allow durations of 0 (instant) by setting step to 1 - see #13798</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> step = _t.duration === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : (curr - _t._startTime) / _t.duration;
							<span class="hljs-keyword">if</span> (step &gt;= <span class="hljs-number">1</span>) {
								step = <span class="hljs-number">1</span>;
							}
							_t._percent = step;</pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <p>Perform easing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (_t.easing) {
								step = _t.easing(step);
							}
							_t._fire(<span class="hljs-string">'onAnimate'</span>, [_t.curve.getValue(step)]);
							<span class="hljs-keyword">if</span> (_t._percent &lt; <span class="hljs-number">1</span>) {
								_t._startTimer();
							} <span class="hljs-keyword">else</span> {
								_t._active = <span class="hljs-literal">false</span>;
								<span class="hljs-keyword">if</span> (_t.repeat &gt; <span class="hljs-number">0</span>) {
									_t.repeat--;
									_t.play(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
								} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_t.repeat === -<span class="hljs-number">1</span>) {
									_t.play(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
								} <span class="hljs-keyword">else</span> {
									<span class="hljs-keyword">if</span> (_t._startRepeatCount) {
										_t.repeat = _t._startRepeatCount;
										_t._startRepeatCount = <span class="hljs-number">0</span>;
									}
								}
								_t._percent = <span class="hljs-number">0</span>;
								_t._fire(<span class="hljs-string">'onEnd'</span>, [_t.node]);
								!_t.repeat &amp;&amp; _t._stopTimer();
							}
						}
						<span class="hljs-keyword">return</span> _t; <span class="hljs-comment">// Animation</span>
					},
					_clearTimer: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>summary:
    Clear the play delay timer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						clearTimeout(<span class="hljs-keyword">this</span>._delayTimer);
						<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._delayTimer;
					}
				});</pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p>the local timer, stubbed into all Animation instances</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> ctr = <span class="hljs-number">0</span>,
					timer = <span class="hljs-literal">null</span>,
					runner = {
						run: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>}
					};
				lang.extend(Animation, {
					_startTimer: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._timer) {
							<span class="hljs-keyword">this</span>._timer = connect.connect(runner, <span class="hljs-string">'run'</span>, <span class="hljs-keyword">this</span>, <span class="hljs-string">'_cycle'</span>);
							ctr++;
						}
						<span class="hljs-keyword">if</span> (!timer) {
							timer = setInterval(lang.hitch(runner, <span class="hljs-string">'run'</span>), <span class="hljs-keyword">this</span>.rate);
						}
					},
					_stopTimer: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._timer) {
							connect.disconnect(<span class="hljs-keyword">this</span>._timer);
							<span class="hljs-keyword">this</span>._timer = <span class="hljs-literal">null</span>;
							ctr--;
						}
						<span class="hljs-keyword">if</span> (ctr &lt;= <span class="hljs-number">0</span>) {
							clearInterval(timer);
							timer = <span class="hljs-literal">null</span>;
							ctr = <span class="hljs-number">0</span>;
						}
					}
				});
				<span class="hljs-keyword">var</span> _makeFadeable = has(<span class="hljs-string">'ie'</span>) ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <p>only set the zoom if the “tickle” value would be the same as the
default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> ns = node.style;</pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <p>don’t set the width to auto if it didn’t already cascade that way.
We don’t want to f anyones designs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!ns.width.length &amp;&amp; style.get(node, <span class="hljs-string">'width'</span>) === <span class="hljs-string">'auto'</span>) {
							ns.width = <span class="hljs-string">'auto'</span>;
						}
					} : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>};
				basefx._fade = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(args)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>summary:
    Returns an animation that will fade the node defined by
    args.node from the start to end values passed (args.start
    args.end) (end is mandatory, start is optional)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					args.node = dom.byId(args.node);
					<span class="hljs-keyword">var</span> fArgs = _mixin({
						properties: {}
					}, args),
						props = fArgs.properties.opacity = {};
					props.start = !(<span class="hljs-string">'start'</span> <span class="hljs-keyword">in</span> fArgs) ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">return</span> +style.get(fArgs.node, <span class="hljs-string">'opacity'</span>) || <span class="hljs-number">0</span>;
					} : fArgs.start;
					props.end = fArgs.end;
					<span class="hljs-keyword">var</span> anim = basefx.animateProperty(fArgs);
					connect.connect(anim, <span class="hljs-string">'beforeBegin'</span>, lang.partial(_makeFadeable, fArgs.node));
					<span class="hljs-keyword">return</span> anim; <span class="hljs-comment">// Animation</span>
				};
				<span class="hljs-comment">/*=====
                 var __FadeArgs = declare(null, {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>node: DOMNode|String
    The node referenced in the animation
duration: Integer?
    Duration of the animation in milliseconds.
easing: Function?
    An easing function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                 });
                 =====*/
				basefx.fadeIn = function (args) {</pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <p>summary:
    Returns an animation that will fade node defined in ‘args’ from
    its current opacity to fully opaque.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> basefx._fade(_mixin({
						end: <span class="hljs-number">1</span>
					}, args)); <span class="hljs-comment">// Animation</span>
				};
				basefx.fadeOut = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(args)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>summary:
    Returns an animation that will fade node defined in ‘args’
    from its current opacity to fully transparent.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> basefx._fade(_mixin({
						end: <span class="hljs-number">0</span>
					}, args)); <span class="hljs-comment">// Animation</span>
				};
				basefx._defaultEasing = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>summary:
    The default easing function for Animation(s)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> + <span class="hljs-built_in">Math</span>.sin((n + <span class="hljs-number">1.5</span>) * <span class="hljs-built_in">Math</span>.PI) / <span class="hljs-number">2</span>; <span class="hljs-comment">// Decimal</span>
				};
				<span class="hljs-keyword">var</span> PropLine = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(properties)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <p>PropLine is an internal class which is used to model the values of
an a group of CSS properties across an animation lifecycle. In
particular, the “getValue” function handles getting interpolated
values between start and end for a particular CSS value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">this</span>._properties = properties;
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> properties) {
						<span class="hljs-keyword">var</span> prop = properties[p];
						<span class="hljs-keyword">if</span> (prop.start <span class="hljs-keyword">instanceof</span> Color) {</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <p>create a reusable temp color object to keep intermediate results</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							prop.tempColor = <span class="hljs-keyword">new</span> Color();
						}
					}
				};
				PropLine.prototype.getValue = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(r)</span> {</span>
					<span class="hljs-keyword">var</span> ret = {};
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>._properties) {
						<span class="hljs-keyword">var</span> prop = <span class="hljs-keyword">this</span>._properties[p],
							start = prop.start;
						<span class="hljs-keyword">if</span> (start <span class="hljs-keyword">instanceof</span> Color) {
							ret[p] = Color.blendColors(start, prop.end, r, prop.tempColor)
								.toCss();
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!lang.isArray(start)) {
							ret[p] = (prop.end - start) * r + start + (p !== <span class="hljs-string">'opacity'</span> ? prop.units || <span class="hljs-string">'px'</span> : <span class="hljs-number">0</span>);
						}
					}
					<span class="hljs-keyword">return</span> ret;
				};
				<span class="hljs-comment">/*=====
                 var __AnimArgs = declare(__FadeArgs, {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              <p>properties: Object?
    A hash map of style properties to Objects describing the transition,
    such as the properties of _Line with an additional ‘units’ property</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                 properties: {}</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>
              <p>TODOC: add event callbacks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                 });
                 =====*/
				basefx.animateProperty = function (args) {</pre></div></div>
            
        </li>
        
        
        <li id="section-159">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-159">&#182;</a>
              </div>
              <p>summary:
    Returns an animation that will transition the properties of
    node defined in <code>args</code> depending how they are defined in
    <code>args.properties</code></p>
<p>description:
    Foundation of most <code>dojo/_base/fx</code>
    animations. It takes an object of “properties” corresponding to
    style properties, and animates them in parallel over a set
    duration.</p>
<p>example:
    A simple animation that changes the width of the specified node.
|    basefx.animateProperty({
|        node: “nodeId”,
|        properties: { width: 400 },
|    }).play();
    Dojo figures out the start value for the width and converts the
    integer specified for the width to the more expressive but
    verbose form <code>{ width: { end: &#39;400&#39;, units: &#39;px&#39; } }</code> which you
    can also specify directly. Defaults to ‘px’ if omitted.</p>
<p>example:
    Animate width, height, and padding over 2 seconds… the
    pedantic way:
|    basefx.animateProperty({ node: node, duration:2000,
|        properties: {
|            width: { start: ‘200’, end: ‘400’, units:”px” },
|            height: { start:’200’, end: ‘400’, units:”px” },
|            paddingTop: { start:’5’, end:’50’, units:”px” }
|        }
|    }).play();
    Note ‘paddingTop’ is used over ‘padding-top’. Multi-name CSS properties
    are written using “mixed case”, as the hyphen is illegal as an object key.</p>
<p>example:
    Plug in a different easing function and register a callback for
    when the animation ends. Easing functions accept values between
    zero and one and return a value on that basis. In this case, an
    exponential-in curve.
|    basefx.animateProperty({
|        node: “nodeId”,
|        // dojo figures out the start value
|        properties: { width: { end: 400 } },
|        easing: function(n){
|            return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
|        },
|        onEnd: function(node){
|            // called when the animation finishes. The animation
|            // target is passed to this function
|        }
|    }).play(500); // delay playing half a second</p>
<p>example:
    Like all <code>Animation</code>s, animateProperty returns a handle to the
    Animation instance, which fires the events common to Dojo FX. Use <code>aspect.after</code>
    to access these events outside of the Animation definition:
|    var anim = basefx.animateProperty({
|        node:”someId”,
|        properties:{
|            width:400, height:500
|        }
|    });
|    aspect.after(anim, “onEnd”, function(){
|        console.log(“animation ended”);
|    }, true);
|    // play the animation now:
|    anim.play();</p>
<p>example:
    Each property can be a function whose return value is substituted along.
    Additionally, each measurement (eg: start, end) can be a function. The node
    reference is passed directly to callbacks.
|    basefx.animateProperty({
|        node:”mine”,
|        properties:{
|            height:function(node){
|                // shrink this node by 50%
|                return domGeom.position(node).h / 2
|            },
|            width:{
|                start:function(node){ return 100; },
|                end:function(node){ return 200; }
|            }
|        }
|    }).play();</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> n = args.node = dom.byId(args.node);
					<span class="hljs-keyword">if</span> (!args.easing) {
						args.easing = dojo._defaultEasing;
					}
					<span class="hljs-keyword">var</span> anim = <span class="hljs-keyword">new</span> Animation(args);
					connect.connect(anim, <span class="hljs-string">'beforeBegin'</span>, anim, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">var</span> pm = {};
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.properties) {</pre></div></div>
            
        </li>
        
        
        <li id="section-160">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-160">&#182;</a>
              </div>
              <p>Make shallow copy of properties into pm because we overwrite
some values below. In particular if start/end are functions
we don’t want to overwrite them or the functions won’t be
called if the animation is reused.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (p === <span class="hljs-string">'width'</span> || p === <span class="hljs-string">'height'</span>) {
								<span class="hljs-keyword">this</span>.node.display = <span class="hljs-string">'block'</span>;
							}
							<span class="hljs-keyword">var</span> prop = <span class="hljs-keyword">this</span>.properties[p];
							<span class="hljs-keyword">if</span> (lang.isFunction(prop)) {
								prop = prop(n);
							}
							prop = pm[p] = _mixin({}, lang.isObject(prop) ? prop : {
								end: prop
							});
							<span class="hljs-keyword">if</span> (lang.isFunction(prop.start)) {
								prop.start = prop.start(n);
							}
							<span class="hljs-keyword">if</span> (lang.isFunction(prop.end)) {
								prop.end = prop.end(n);
							}
							<span class="hljs-keyword">var</span> isColor = p.toLowerCase()
								.indexOf(<span class="hljs-string">'color'</span>) &gt;= <span class="hljs-number">0</span>;

							<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span><span class="hljs-params">(node, p)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-161">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-161">&#182;</a>
              </div>
              <p>domStyle.get(node, “height”) can return “auto” or “” on IE; this is more reliable:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">var</span> v = {
									height: node.offsetHeight,
									width: node.offsetWidth
								}[p];
								<span class="hljs-keyword">if</span> (v !== <span class="hljs-literal">undefined</span>) {
									<span class="hljs-keyword">return</span> v;
								}
								v = style.get(node, p);
								<span class="hljs-keyword">return</span> p === <span class="hljs-string">'opacity'</span> ? +v : isColor ? v : <span class="hljs-built_in">parseFloat</span>(v);
							}
							<span class="hljs-keyword">if</span> (!(<span class="hljs-string">'end'</span> <span class="hljs-keyword">in</span> prop)) {
								prop.end = getStyle(n, p);
							} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(<span class="hljs-string">'start'</span> <span class="hljs-keyword">in</span> prop)) {
								prop.start = getStyle(n, p);
							}
							<span class="hljs-keyword">if</span> (isColor) {
								prop.start = <span class="hljs-keyword">new</span> Color(prop.start);
								prop.end = <span class="hljs-keyword">new</span> Color(prop.end);
							} <span class="hljs-keyword">else</span> {
								prop.start = p === <span class="hljs-string">'opacity'</span> ? +prop.start : <span class="hljs-built_in">parseFloat</span>(prop.start);
							}
						}
						<span class="hljs-keyword">this</span>.curve = <span class="hljs-keyword">new</span> PropLine(pm);
					});
					connect.connect(anim, <span class="hljs-string">'onAnimate'</span>, lang.hitch(style, <span class="hljs-string">'set'</span>, anim.node));
					<span class="hljs-keyword">return</span> anim; <span class="hljs-comment">// Animation</span>
				};
				basefx.anim = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, properties, duration, easing, onEnd, delay)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-162">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-162">&#182;</a>
              </div>
              <p>summary:
    A simpler interface to <code>animateProperty()</code>, also returns
    an instance of <code>Animation</code> but begins the animation
    immediately, unlike nearly every other Dojo animation API.
description:
    Simpler (but somewhat less powerful) version
    of <code>animateProperty</code>.  It uses defaults for many basic properties
    and allows for positional parameters to be used in place of the
    packed “property bag” which is used for other Dojo animation
    methods.</p>
<pre><code>The `Animation` object returned will be already playing, so
calling play() on it again is (usually) a no-op.
</code></pre><p>node:
    a DOM node or the id of a node to animate CSS properties on
duration:
    The number of milliseconds over which the animation
    should run. Defaults to the global animation default duration
    (350ms).
easing:
    An easing function over which to calculate acceleration
    and deceleration of the animation through its duration.
    A default easing algorithm is provided, but you may
    plug in any you wish. A large selection of easing algorithms
    are available in <code>dojo/fx/easing</code>.
onEnd:
    A function to be called when the animation finishes
    running.
delay:
    The number of milliseconds to delay beginning the
    animation by. The default is 0.
example:
    Fade out a node
|    basefx.anim(“id”, { opacity: 0 });
example:
    Fade out a node over a full second
|    basefx.anim(“id”, { opacity: 0 }, 1000);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> basefx.animateProperty({
						node: node,
						duration: duration || Animation.prototype.duration,
						properties: properties,
						easing: easing,
						onEnd: onEnd
					})
						.play(delay || <span class="hljs-number">0</span>);
				};
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
					_mixin(dojo, basefx);</pre></div></div>
            
        </li>
        
        
        <li id="section-163">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-163">&#182;</a>
              </div>
              <p>Alias to drop come 2.0:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					dojo._Animation = Animation;
				}
				<span class="hljs-keyword">return</span> basefx;
			});
		},
		<span class="hljs-string">'dojo/dom-form'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./_base/lang'</span>,
				<span class="hljs-string">'./dom'</span>,
				<span class="hljs-string">'./io-query'</span>,
				<span class="hljs-string">'./json'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(lang, dom, ioq, json)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-164">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-164">&#182;</a>
              </div>
              <p>module:
    dojo/dom-form</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setValue</span><span class="hljs-params">(obj, name, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-165">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-165">&#182;</a>
              </div>
              <p>summary:
    For the named property in object, set the value. If a value
    already exists and it is a string, convert the value to be an
    array of values.
Skip it if there is no value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
						<span class="hljs-keyword">return</span>;
					}
					<span class="hljs-keyword">var</span> val = obj[name];
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-166">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-166">&#182;</a>
              </div>
              <p>inline’d type check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						obj[name] = [
							val,
							value
						];
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lang.isArray(val)) {
						val.push(value);
					} <span class="hljs-keyword">else</span> {
						obj[name] = value;
					}
				}
				<span class="hljs-keyword">var</span> exclude = <span class="hljs-string">'file|submit|image|reset|button'</span>;
				<span class="hljs-keyword">var</span> form = {
					fieldToObject: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fieldToObject</span><span class="hljs-params">(inputNode)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-167">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-167">&#182;</a>
              </div>
              <p>summary:
    Serialize a form field to a JavaScript object.
description:
    Returns the value encoded in a form field as
    as a string or an array of strings. Disabled form elements
    and unchecked radio and checkboxes are skipped.    Multi-select
    elements are returned as an array of string values.
inputNode: DOMNode|String
returns: Object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> ret = <span class="hljs-literal">null</span>;
						inputNode = dom.byId(inputNode);
						<span class="hljs-keyword">if</span> (inputNode) {
							<span class="hljs-keyword">var</span> _in = inputNode.name,
								type = (inputNode.type || <span class="hljs-string">''</span>)
									.toLowerCase();
							<span class="hljs-keyword">if</span> (_in &amp;&amp; type &amp;&amp; !inputNode.disabled) {
								<span class="hljs-keyword">if</span> (type === <span class="hljs-string">'radio'</span> || type === <span class="hljs-string">'checkbox'</span>) {
									<span class="hljs-keyword">if</span> (inputNode.checked) {
										ret = inputNode.value;
									}
								} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inputNode.multiple) {
									ret = [];
									<span class="hljs-keyword">var</span> nodes = [inputNode.firstChild];
									<span class="hljs-keyword">while</span> (nodes.length) {
										<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> node = nodes.pop(); node; node = node.nextSibling) {
											<span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span> &amp;&amp; node.tagName.toLowerCase() === <span class="hljs-string">'option'</span>) {
												<span class="hljs-keyword">if</span> (node.selected) {
													ret.push(node.value);
												}
											} <span class="hljs-keyword">else</span> {
												<span class="hljs-keyword">if</span> (node.nextSibling) {
													nodes.push(node.nextSibling);
												}
												<span class="hljs-keyword">if</span> (node.firstChild) {
													nodes.push(node.firstChild);
												}
												<span class="hljs-keyword">break</span>;
											}
										}
									}
								} <span class="hljs-keyword">else</span> {
									ret = inputNode.value;
								}
							}
						}
						<span class="hljs-keyword">return</span> ret; <span class="hljs-comment">// Object</span>
					},
					toObject: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formToObject</span><span class="hljs-params">(formNode)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-168">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-168">&#182;</a>
              </div>
              <p>summary:
    Serialize a form node to a JavaScript object.
description:
    Returns the values encoded in an HTML form as
    string properties in an object which it then returns. Disabled form
    elements, buttons, and other non-value form elements are skipped.
    Multi-select elements are returned as an array of string values.
formNode: DOMNode|String
example:
    This form:
    |    <form id="test_form">
    |        <input type="text" name="blah" value="blah">
    |        <input type="text" name="no_value" value="blah" disabled>
    |        <input type="button" name="no_value2" value="blah">
    |        <select type="select" multiple name="multi" size="5">
    |            <option value="blah">blah</option>
    |            <option value="thud" selected>thud</option>
    |            <option value="thonk" selected>thonk</option>
    |        </select>
    |    </form></p>
<pre><code>yields <span class="hljs-keyword">this</span> object structure as the result of a call to
formToObject():

|    {
|        blah: <span class="hljs-string">"blah"</span>,
|        multi: [
|            <span class="hljs-string">"thud"</span>,
|            <span class="hljs-string">"thonk"</span>
|        ]
|    };
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> ret = {}, elems = dom.byId(formNode)
								.elements;
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = elems.length; i &lt; l; ++i) {
							<span class="hljs-keyword">var</span> item = elems[i],
								_in = item.name,
								type = (item.type || <span class="hljs-string">''</span>)
									.toLowerCase();
							<span class="hljs-keyword">if</span> (_in &amp;&amp; type &amp;&amp; exclude.indexOf(type) &lt; <span class="hljs-number">0</span> &amp;&amp; !item.disabled) {
								setValue(ret, _in, form.fieldToObject(item));
								<span class="hljs-keyword">if</span> (type === <span class="hljs-string">'image'</span>) {
									ret[_in + <span class="hljs-string">'.x'</span>] = ret[_in + <span class="hljs-string">'.y'</span>] = ret[_in].x = ret[_in].y = <span class="hljs-number">0</span>;
								}
							}
						}
						<span class="hljs-keyword">return</span> ret; <span class="hljs-comment">// Object</span>
					},
					toQuery: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formToQuery</span><span class="hljs-params">(formNode)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-169">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-169">&#182;</a>
              </div>
              <p>summary:
    Returns a URL-encoded string representing the form passed as either a
    node or string ID identifying the form to serialize
formNode: DOMNode|String
returns: String</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> ioq.objectToQuery(form.toObject(formNode)); <span class="hljs-comment">// String</span>
					},
					toJson: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formToJson</span><span class="hljs-params">(formNode, prettyPrint)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-170">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-170">&#182;</a>
              </div>
              <p>summary:
    Create a serialized JSON string from a form node or string
    ID identifying the form to serialize
formNode: DOMNode|String
prettyPrint: Boolean?
returns: String</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> json.stringify(form.toObject(formNode), <span class="hljs-literal">null</span>, prettyPrint ? <span class="hljs-number">4</span> : <span class="hljs-number">0</span>); <span class="hljs-comment">// String</span>
					}
				};
				<span class="hljs-keyword">return</span> form;
			});
		},
		<span class="hljs-string">'dojo/i18n'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./_base/kernel'</span>,
				<span class="hljs-string">'require'</span>,
				<span class="hljs-string">'./has'</span>,
				<span class="hljs-string">'./_base/array'</span>,
				<span class="hljs-string">'./_base/config'</span>,
				<span class="hljs-string">'./_base/lang'</span>,
				<span class="hljs-string">'./_base/xhr'</span>,
				<span class="hljs-string">'./json'</span>,
				<span class="hljs-string">'module'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, require, has, array, config, lang, xhr, json, module)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-171">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-171">&#182;</a>
              </div>
              <p>module:
    dojo/i18n</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				has.add(<span class="hljs-string">'dojo-preload-i18n-Api'</span>, <span class="hljs-number">1</span>);
				<span class="hljs-number">1</span> || has.add(<span class="hljs-string">'dojo-v1x-i18n-Api'</span>, <span class="hljs-number">1</span>);
				<span class="hljs-keyword">var</span> thisModule = dojo.i18n = {}, nlsRe = <span class="hljs-regexp">/(^.*(^|\/)nls)(\/|$)([^\/]*)\/?([^\/]*)/</span>,
					getAvailableLocales = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root, locale, bundlePath, bundleName)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-172">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-172">&#182;</a>
              </div>
              <p>summary:
    return a vector of module ids containing all available locales with respect to the target locale
    For example, assuming:</p>
<pre><code>- the root bundle indicates specific bundles <span class="hljs-keyword">for</span> <span class="hljs-string">"fr"</span> and <span class="hljs-string">"fr-ca"</span>,
-  bundlePath is <span class="hljs-string">"myPackage/nls"</span>
- bundleName is <span class="hljs-string">"myBundle"</span>

Then a locale argument of <span class="hljs-string">"fr-ca"</span> would <span class="hljs-keyword">return</span>

    [<span class="hljs-string">"myPackage/nls/myBundle"</span>, <span class="hljs-string">"myPackage/nls/fr/myBundle"</span>, <span class="hljs-string">"myPackage/nls/fr-ca/myBundle"</span>]

Notice that bundles are returned least-specific to most-specific, starting <span class="hljs-keyword">with</span> the root.

If root===<span class="hljs-literal">false</span> indicates we<span class="hljs-string">'re working with a pre-AMD i18n bundle that doesn'</span>t tell about the available locales;
therefore, assume everything is available and get <span class="hljs-number">404</span> errors that indicate a particular localization is not available
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> result = [bundlePath + bundleName], localeParts = locale.split(<span class="hljs-string">'-'</span>), current = <span class="hljs-string">''</span>, i = <span class="hljs-number">0</span>; i &lt; localeParts.length; i++) {
							current += (current ? <span class="hljs-string">'-'</span> : <span class="hljs-string">''</span>) + localeParts[i];
							<span class="hljs-keyword">if</span> (!root || root[current]) {
								result.push(bundlePath + current + <span class="hljs-string">'/'</span> + bundleName);
							}
						}
						<span class="hljs-keyword">return</span> result;
					}, cache = {}, getBundleName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(moduleName, bundleName, locale)</span> {</span>
						locale = locale ? locale.toLowerCase() : dojo.locale;
						moduleName = moduleName.replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">'/'</span>);
						bundleName = bundleName.replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">'/'</span>);
						<span class="hljs-keyword">return</span> <span class="hljs-regexp">/root/i</span>.test(locale) ? moduleName + <span class="hljs-string">'/nls/'</span> + bundleName : moduleName + <span class="hljs-string">'/nls/'</span> + locale + <span class="hljs-string">'/'</span> + bundleName;
					}, getL10nName = dojo.getL10nName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(moduleName, bundleName, locale)</span> {</span>
						<span class="hljs-keyword">return</span> moduleName = module.id + <span class="hljs-string">'!'</span> + getBundleName(moduleName, bundleName, locale);
					}, doLoad = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(require, bundlePathAndName, bundlePath, bundleName, locale, load)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-173">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-173">&#182;</a>
              </div>
              <p>summary:
    get the root bundle which instructs which other bundles are required to construct the localized bundle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-built_in">require</span>([bundlePathAndName], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root)</span> {</span>
							<span class="hljs-keyword">var</span> current = lang.clone(root.root),
								availableLocales = getAvailableLocales(!root._v1x &amp;&amp; root, locale, bundlePath, bundleName);
							<span class="hljs-built_in">require</span>(availableLocales, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; availableLocales.length; i++) {
									current = lang.mixin(lang.clone(current), <span class="hljs-built_in">arguments</span>[i]);
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-174">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-174">&#182;</a>
              </div>
              <p>target may not have been resolve (e.g., maybe only “fr” exists when “fr-ca” was requested)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">var</span> target = bundlePathAndName + <span class="hljs-string">'/'</span> + locale;
								cache[target] = current;
								load();
							});
						});
					}, normalize = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, toAbsMid)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-175">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-175">&#182;</a>
              </div>
              <p>summary:
    id may be relative.
    preload has form <code>*preload*&lt;path&gt;/nls/&lt;module&gt;*&lt;flattened locales&gt;</code> and
    therefore never looks like a relative</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-regexp">/^\./</span>.test(id) ? toAbsMid(id) : id;
					}, getLocalesToLoad = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(targetLocale)</span> {</span>
						<span class="hljs-keyword">var</span> list = config.extraLocale || [];
						list = lang.isArray(list) ? list : [list];
						list.push(targetLocale);
						<span class="hljs-keyword">return</span> list;
					}, load = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, require, load)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-176">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-176">&#182;</a>
              </div>
              <p>summary:
    id is in one of the following formats</p>
<pre><code><span class="hljs-number">1.</span> &lt;path&gt;<span class="hljs-regexp">/nls/</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">bundle</span>&gt;</span>
    =&gt; load the bundle, localized to config.locale; load all bundles localized to
    config.extraLocale (if any); return the loaded bundle localized to config.locale.

2. <span class="hljs-tag">&lt;<span class="hljs-title">path</span>&gt;</span>/nls/<span class="hljs-tag">&lt;<span class="hljs-title">locale</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">bundle</span>&gt;</span>
    =&gt; load then return the bundle localized to <span class="hljs-tag">&lt;<span class="hljs-title">locale</span>&gt;</span>

3. *preload*<span class="hljs-tag">&lt;<span class="hljs-title">path</span>&gt;</span>/nls/<span class="hljs-tag">&lt;<span class="hljs-title">module</span>&gt;</span>*<span class="hljs-tag">&lt;<span class="hljs-title">JSON</span> <span class="hljs-attribute">array</span> <span class="hljs-attribute">of</span> <span class="hljs-attribute">available</span> <span class="hljs-attribute">locales</span>&gt;</span>
    =&gt; for config.locale and all config.extraLocale, load all bundles found
    in the best-matching bundle rollup. A value of 1 is returned, which
    is meaningless other than to say the plugin is executing the requested
    preloads

In cases 1 and 2, <span class="hljs-tag">&lt;<span class="hljs-title">path</span>&gt;</span> is always normalized to an absolute module id upon entry; see
normalize. In case 3, it <span class="hljs-tag">&lt;<span class="hljs-title">path</span>&gt;</span> is assumed to be absolute; this is arranged by the builder.

To load a bundle means to insert the bundle into the plugin's cache and publish the bundle
value to the loader. Given <span class="hljs-tag">&lt;<span class="hljs-title">path</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-title">bundle</span>&gt;</span>, and a particular <span class="hljs-tag">&lt;<span class="hljs-title">locale</span>&gt;</span>, the cache key

    <span class="hljs-tag">&lt;<span class="hljs-title">path</span>&gt;</span>/nls/<span class="hljs-tag">&lt;<span class="hljs-title">bundle</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">locale</span>&gt;</span>

will hold the value. Similarly, then plugin will publish this value to the loader by

    define("<span class="hljs-tag">&lt;<span class="hljs-title">path</span>&gt;</span>/nls/<span class="hljs-tag">&lt;<span class="hljs-title">bundle</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">locale</span>&gt;</span>", <span class="hljs-tag">&lt;<span class="hljs-title">bundle-value</span>&gt;</span>);

Given this algorithm, other machinery can provide fast load paths be preplacing
values in the plugin's cache, which is public. When a load is demanded the
cache is inspected before starting any loading. Explicitly placing values in the plugin
cache is an advanced/experimental feature that should not be needed; use at your own risk.

For the normal AMD algorithm, the root bundle is loaded first, which instructs the
plugin what additional localized bundles are required for a particular locale. These
additional locales are loaded and a mix of the root and each progressively-specific
locale is returned. For example:

1. The client demands "dojo/i18n!some/path/nls/someBundle

2. The loader demands load(some/path/nls/someBundle)

3. This plugin require's "some/path/nls/someBundle", which is the root bundle.

4. Assuming config.locale is "ab-cd-ef" and the root bundle indicates that localizations
are available for "ab" and "ab-cd-ef" (note the missing "ab-cd", then the plugin
requires "some/path/nls/ab/someBundle" and "some/path/nls/ab-cd-ef/someBundle"

5. Upon receiving all required bundles, the plugin constructs the value of the bundle
ab-cd-ef as...

        mixin(mixin(mixin({}, require("some/path/nls/someBundle"),
              require("some/path/nls/ab/someBundle")),
            require("some/path/nls/ab-cd-ef/someBundle"));

This value is inserted into the cache and published to the loader at the
key/module-id some/path/nls/someBundle/ab-cd-ef.

The special preload signature (case 3) instructs the plugin to stop servicing all normal requests
(further preload requests will be serviced) until all ongoing preloading has completed.

The preload signature instructs the plugin that a special rollup module is available that contains
one or more flattened, localized bundles. The JSON array of available locales indicates which locales
are available. Here is an example:

    *preload*some/path/nls/someModule*["root", "ab", "ab-cd-ef"]

This indicates the following rollup modules are available:

    some/path/nls/someModule_ROOT
    some/path/nls/someModule_ab
    some/path/nls/someModule_ab-cd-ef

Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.
For example, assume someModule contained the bundles some/bundle/path/someBundle and
some/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:

    define({
        some/bundle/path/someBundle:<span class="hljs-tag">&lt;<span class="hljs-title">value</span> <span class="hljs-attribute">of</span> <span class="hljs-attribute">someBundle</span>, <span class="hljs-attribute">flattened</span> <span class="hljs-attribute">with</span> <span class="hljs-attribute">respect</span> <span class="hljs-attribute">to</span> <span class="hljs-attribute">locale</span> <span class="hljs-attribute">ab</span>&gt;</span>,
        some/bundle/path/someOtherBundle:<span class="hljs-tag">&lt;<span class="hljs-title">value</span> <span class="hljs-attribute">of</span> <span class="hljs-attribute">someOtherBundle</span>, <span class="hljs-attribute">flattened</span> <span class="hljs-attribute">with</span> <span class="hljs-attribute">respect</span> <span class="hljs-attribute">to</span> <span class="hljs-attribute">locale</span> <span class="hljs-attribute">ab</span>&gt;</span>,
    });

E.g., given this design, preloading for locale=="ab" can execute the following algorithm:

    require(["some/path/nls/someModule_ab"], function(rollup){
        for(var p in rollup){
            var id = p + "/ab",
            cache[id] = rollup[p];
            define(id, rollup[p]);
        }
    });

Similarly, if "ab-cd" is requested, the algorithm can determine that "ab" is the best available and
load accordingly.

The builder will write such rollups for every layer if a non-empty localeList  profile property is
provided. Further, the builder will include the following cache entry in the cache associated with
any layer.

    "*now":function(r){r(['dojo/i18n!*preload*<span class="hljs-tag">&lt;<span class="hljs-title">path</span>&gt;</span>/nls/<span class="hljs-tag">&lt;<span class="hljs-title">module</span>&gt;</span>*<span class="hljs-tag">&lt;<span class="hljs-title">JSON</span> <span class="hljs-attribute">array</span> <span class="hljs-attribute">of</span> <span class="hljs-attribute">available</span> <span class="hljs-attribute">locales</span>&gt;</span>']);}

The *now special cache module instructs the loader to apply the provided function to context-require
with respect to the particular layer being defined. This causes the plugin to hold all normal service
requests until all preloading is complete.

Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case
where the target locale has a single segment and a layer depends on a single bundle:

Without Preloads:

1. Layer loads root bundle.
2. bundle is demanded; plugin loads single localized bundle.

With Preloads:

1. Layer causes preloading of target bundle.
2. bundle is demanded; service is delayed until preloading complete; bundle is returned.

In each case a single transaction is required to load the target bundle. In cases where multiple bundles
are required and/or the locale has multiple segments, preloads still requires a single transaction whereas
the normal path requires an additional transaction for each additional bundle/locale-segment. However all
of these additional transactions can be done concurrently. Owing to this analysis, the entire preloading
algorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'dojo-preload-i18n-Api'</span>)) {
							<span class="hljs-keyword">var</span> split = id.split(<span class="hljs-string">'*'</span>),
								preloadDemand = split[<span class="hljs-number">1</span>] === <span class="hljs-string">'preload'</span>;
							<span class="hljs-keyword">if</span> (preloadDemand) {
								<span class="hljs-keyword">if</span> (!cache[id]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-177">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-177">&#182;</a>
              </div>
              <p>use cache[id] to prevent multiple preloads of the same preload; this shouldn’t happen, but
who knows what over-aggressive human optimizers may attempt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									cache[id] = <span class="hljs-number">1</span>;
									preloadL10n(split[<span class="hljs-number">2</span>], json.parse(split[<span class="hljs-number">3</span>]), <span class="hljs-number">1</span>, <span class="hljs-built_in">require</span>);
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-178">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-178">&#182;</a>
              </div>
              <p>don’t stall the loader!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								load(<span class="hljs-number">1</span>);
							}
							<span class="hljs-keyword">if</span> (preloadDemand || waitForPreloads(id, <span class="hljs-built_in">require</span>, load)) {
								<span class="hljs-keyword">return</span>;
							}
						}
						<span class="hljs-keyword">var</span> match = nlsRe.exec(id),
							bundlePath = match[<span class="hljs-number">1</span>] + <span class="hljs-string">'/'</span>,
							bundleName = match[<span class="hljs-number">5</span>] || match[<span class="hljs-number">4</span>],
							bundlePathAndName = bundlePath + bundleName,
							localeSpecified = match[<span class="hljs-number">5</span>] &amp;&amp; match[<span class="hljs-number">4</span>],
							targetLocale = localeSpecified || dojo.locale,
							loadTarget = bundlePathAndName + <span class="hljs-string">'/'</span> + targetLocale,
							loadList = localeSpecified ? [targetLocale] : getLocalesToLoad(targetLocale),
							remaining = loadList.length,
							finish = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								<span class="hljs-keyword">if</span> (!--remaining) {
									load(lang.delegate(cache[loadTarget]));
								}
							};
						array.forEach(loadList, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(locale)</span> {</span>
							<span class="hljs-keyword">var</span> target = bundlePathAndName + <span class="hljs-string">'/'</span> + locale;
							<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'dojo-preload-i18n-Api'</span>)) {
								checkForLegacyModules(target);
							}
							<span class="hljs-keyword">if</span> (!cache[target]) {
								doLoad(<span class="hljs-built_in">require</span>, bundlePathAndName, bundlePath, bundleName, locale, finish);
							} <span class="hljs-keyword">else</span> {
								finish();
							}
						});
					};
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'dojo-unit-tests'</span>)) {
					<span class="hljs-keyword">var</span> unitTests = thisModule.unitTests = [];
				}
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'dojo-preload-i18n-Api'</span>) || <span class="hljs-number">1</span>) {
					<span class="hljs-keyword">var</span> normalizeLocale = thisModule.normalizeLocale = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(locale)</span> {</span>
						<span class="hljs-keyword">var</span> result = locale ? locale.toLowerCase() : dojo.locale;
						<span class="hljs-keyword">return</span> result === <span class="hljs-string">'root'</span> ? <span class="hljs-string">'ROOT'</span> : result;
					}, isXd = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid, contextRequire)</span> {</span>
							<span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">1</span> ? contextRequire.isXdUrl(<span class="hljs-built_in">require</span>.toUrl(mid + <span class="hljs-string">'.js'</span>)) : <span class="hljs-literal">true</span>;
						}, preloading = <span class="hljs-number">0</span>,
						preloadWaitQueue = [],
						preloadL10n = thisModule._preloadLocalizations = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(bundlePrefix, localesGenerated, guaranteedAmdFormat, contextRequire)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-179">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-179">&#182;</a>
              </div>
              <p>summary:
    Load available flattened resource bundles associated with a particular module for dojo/locale and all dojo/config.extraLocale (if any)
description:
    Only called by built layer files. The entire locale hierarchy is loaded. For example,
    if locale==”ab-cd”, then ROOT, “ab”, and “ab-cd” are loaded. This is different than v1.6-
    in that the v1.6- would only load ab-cd…which was <em>always</em> flattened.</p>
<pre><code>If guaranteedAmdFormat is <span class="hljs-literal">true</span>, then the module can be loaded <span class="hljs-keyword">with</span> <span class="hljs-built_in">require</span> thereby circumventing the detection algorithm
and the extra possible extra transaction.
</code></pre><p>If this function is called from legacy code, then guaranteedAmdFormat and contextRequire will be undefined. Since the function
needs a require in order to resolve module ids, fall back to the context-require associated with this dojo/i18n module, which
itself may have been mapped.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							contextRequire = contextRequire || <span class="hljs-built_in">require</span>;

							<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doRequire</span><span class="hljs-params">(mid, callback)</span> {</span>
								<span class="hljs-keyword">if</span> (isXd(mid, contextRequire) || guaranteedAmdFormat) {
									contextRequire([mid], callback);
								} <span class="hljs-keyword">else</span> {
									syncRequire([mid], callback, contextRequire);
								}
							}

							<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachLocale</span><span class="hljs-params">(locale, func)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-180">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-180">&#182;</a>
              </div>
              <p>given locale= “ab-cd-ef”, calls func on “ab-cd-ef”, “ab-cd”, “ab”, “ROOT”; stops calling the first time func returns truthy</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">var</span> parts = locale.split(<span class="hljs-string">'-'</span>);
								<span class="hljs-keyword">while</span> (parts.length) {
									<span class="hljs-keyword">if</span> (func(parts.join(<span class="hljs-string">'-'</span>))) {
										<span class="hljs-keyword">return</span>;
									}
									parts.pop();
								}
								func(<span class="hljs-string">'ROOT'</span>);
							}

							<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preload</span><span class="hljs-params">(locale)</span> {</span>
								locale = normalizeLocale(locale);
								forEachLocale(locale, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(loc)</span> {</span>
									<span class="hljs-keyword">if</span> (array.indexOf(localesGenerated, loc) &gt;= <span class="hljs-number">0</span>) {
										<span class="hljs-keyword">var</span> mid = bundlePrefix.replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">'/'</span>) + <span class="hljs-string">'_'</span> + loc;
										preloading++;
										doRequire(mid, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(rollup)</span> {</span>
											<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> rollup) {
												cache[<span class="hljs-built_in">require</span>.toAbsMid(p) + <span class="hljs-string">'/'</span> + loc] = rollup[p];
											}
											--preloading;
											<span class="hljs-keyword">while</span> (!preloading &amp;&amp; preloadWaitQueue.length) {
												load.apply(<span class="hljs-literal">null</span>, preloadWaitQueue.shift());
											}
										});
										<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
									}
									<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
								});
							}
							preload();
							array.forEach(dojo.config.extraLocale, preload);
						}, waitForPreloads = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, require, load)</span> {</span>
							<span class="hljs-keyword">if</span> (preloading) {
								preloadWaitQueue.push([
									id,
									<span class="hljs-built_in">require</span>,
									load
								]);
							}
							<span class="hljs-keyword">return</span> preloading;
						}, checkForLegacyModules = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>};
				}
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-181">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-181">&#182;</a>
              </div>
              <p>this code path assumes the dojo loader and won’t work with a standard AMD loader</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> amdValue = {}, evalBundle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'__bundle'</span>, <span class="hljs-string">'__checkForLegacyModules'</span>, <span class="hljs-string">'__mid'</span>, <span class="hljs-string">'__amdValue'</span>, <span class="hljs-string">'var define = function(mid, factory){define.called = 1; __amdValue.result = factory || mid;},'</span> + <span class="hljs-string">'\t   require = function(){define.called = 1;};'</span> + <span class="hljs-string">'try{'</span> + <span class="hljs-string">'define.called = 0;'</span> + <span class="hljs-string">'eval(__bundle);'</span> + <span class="hljs-string">'if(define.called==1)'</span> + <span class="hljs-string">'return __amdValue;'</span> + <span class="hljs-string">'if((__checkForLegacyModules = __checkForLegacyModules(__mid)))'</span> + <span class="hljs-string">'return __checkForLegacyModules;'</span> + <span class="hljs-string">'}catch(e){}'</span> + <span class="hljs-string">'try{'</span> + <span class="hljs-string">'return eval(\'(\'+__bundle+\')\');'</span> + <span class="hljs-string">'}catch(e){'</span> + <span class="hljs-string">'return e;'</span> + <span class="hljs-string">'}'</span>),
						syncRequire = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(deps, callback, require)</span> {</span>
							<span class="hljs-keyword">var</span> results = [];
							array.forEach(deps, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid)</span> {</span>
								<span class="hljs-keyword">var</span> url = <span class="hljs-built_in">require</span>.toUrl(mid + <span class="hljs-string">'.js'</span>);

								<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span><span class="hljs-params">(text)</span> {</span>
									<span class="hljs-keyword">var</span> result = evalBundle(text, checkForLegacyModules, mid, amdValue);
									<span class="hljs-keyword">if</span> (result === amdValue) {</pre></div></div>
            
        </li>
        
        
        <li id="section-182">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-182">&#182;</a>
              </div>
              <p>the bundle was an AMD module; re-inject it through the normal AMD path
we gotta do this since it could be an anonymous module and simply evaluating
the text here won’t provide the loader with the context to know what
module is being defined()’d. With browser caching, this should be free; further
this entire code path can be circumvented by using the AMD format to begin with</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										results.push(cache[url] = amdValue.result);
									} <span class="hljs-keyword">else</span> {
										<span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>) {
											console.error(<span class="hljs-string">'failed to evaluate i18n bundle; url='</span> + url, result);
											result = {};
										}</pre></div></div>
            
        </li>
        
        
        <li id="section-183">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-183">&#182;</a>
              </div>
              <p>nls/<locale>/<bundle-name> indicates not the root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										results.push(cache[url] = <span class="hljs-regexp">/nls\/[^\/]+\/[^\/]+$/</span>.test(url) ? result : {
											root: result,
											_v1x: <span class="hljs-number">1</span>
										});
									}
								}
								<span class="hljs-keyword">if</span> (cache[url]) {
									results.push(cache[url]);
								} <span class="hljs-keyword">else</span> {
									<span class="hljs-keyword">var</span> bundle = <span class="hljs-built_in">require</span>.syncLoadNls(mid);</pre></div></div>
            
        </li>
        
        
        <li id="section-184">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-184">&#182;</a>
              </div>
              <p>don’t need to check for legacy since syncLoadNls returns a module if the module
(1) was already loaded, or (2) was in the cache. In case 1, if syncRequire is called
from getLocalization —&gt; load, then load will have called checkForLegacyModules() before
calling syncRequire; if syncRequire is called from preloadLocalizations, then we
don’t care about checkForLegacyModules() because that will be done when a particular
bundle is actually demanded. In case 2, checkForLegacyModules() is never relevant
because cached modules are always v1.7+ built modules.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-keyword">if</span> (bundle) {
										results.push(bundle);
									} <span class="hljs-keyword">else</span> {
										<span class="hljs-keyword">if</span> (!xhr) {
											<span class="hljs-keyword">try</span> {
												<span class="hljs-built_in">require</span>.getText(url, <span class="hljs-literal">true</span>, load);
											} <span class="hljs-keyword">catch</span> (e) {
												results.push(cache[url] = {});
											}
										} <span class="hljs-keyword">else</span> {
											xhr.get({
												url: url,
												sync: <span class="hljs-literal">true</span>,
												load: load,
												error: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
													results.push(cache[url] = {});
												}
											});
										}
									}
								}
							});
							callback &amp;&amp; callback.apply(<span class="hljs-literal">null</span>, results);
						};
					checkForLegacyModules = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-185">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-185">&#182;</a>
              </div>
              <p>legacy code may have already loaded [e.g] the raw bundle x/y/z at x.y.z; when true, push into the cache</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> result, names = target.split(<span class="hljs-string">'/'</span>), object = dojo.global[names[<span class="hljs-number">0</span>]], i = <span class="hljs-number">1</span>; object &amp;&amp; i &lt; names.length - <span class="hljs-number">1</span>; object = object[names[i++]]) {}
						<span class="hljs-keyword">if</span> (object) {
							result = object[names[i]];
							<span class="hljs-keyword">if</span> (!result) {</pre></div></div>
            
        </li>
        
        
        <li id="section-186">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-186">&#182;</a>
              </div>
              <p>fallback for incorrect bundle build of 1.6</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								result = object[names[i].replace(<span class="hljs-regexp">/-/g</span>, <span class="hljs-string">'_'</span>)];
							}
							<span class="hljs-keyword">if</span> (result) {
								cache[target] = result;
							}
						}
						<span class="hljs-keyword">return</span> result;
					};
					thisModule.getLocalization = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(moduleName, bundleName, locale)</span> {</span>
						<span class="hljs-keyword">var</span> result, l10nName = getBundleName(moduleName, bundleName, locale);
						load(l10nName, !isXd(l10nName, <span class="hljs-built_in">require</span>) ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(deps, callback)</span> {</span>
							syncRequire(deps, callback, <span class="hljs-built_in">require</span>);
						} : <span class="hljs-built_in">require</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(result_)</span> {</span>
							result = result_;
						});
						<span class="hljs-keyword">return</span> result;
					};
					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'dojo-unit-tests'</span>)) {
						unitTests.push(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(doh)</span> {</span>
							doh.register(<span class="hljs-string">'tests.i18n.unit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(t)</span> {</span>
								<span class="hljs-keyword">var</span> check;
								check = evalBundle(<span class="hljs-string">'{prop:1}'</span>, checkForLegacyModules, <span class="hljs-string">'nonsense'</span>, amdValue);
								t.is({
									prop: <span class="hljs-number">1</span>
								}, check);
								t.is(<span class="hljs-literal">undefined</span>, check[<span class="hljs-number">1</span>]);
								check = evalBundle(<span class="hljs-string">'({prop:1})'</span>, checkForLegacyModules, <span class="hljs-string">'nonsense'</span>, amdValue);
								t.is({
									prop: <span class="hljs-number">1</span>
								}, check);
								t.is(<span class="hljs-literal">undefined</span>, check[<span class="hljs-number">1</span>]);
								check = evalBundle(<span class="hljs-string">'{\'prop-x\':1}'</span>, checkForLegacyModules, <span class="hljs-string">'nonsense'</span>, amdValue);
								t.is({
									<span class="hljs-string">'prop-x'</span>: <span class="hljs-number">1</span>
								}, check);
								t.is(<span class="hljs-literal">undefined</span>, check[<span class="hljs-number">1</span>]);
								check = evalBundle(<span class="hljs-string">'({\'prop-x\':1})'</span>, checkForLegacyModules, <span class="hljs-string">'nonsense'</span>, amdValue);
								t.is({
									<span class="hljs-string">'prop-x'</span>: <span class="hljs-number">1</span>
								}, check);
								t.is(<span class="hljs-literal">undefined</span>, check[<span class="hljs-number">1</span>]);
								check = evalBundle(<span class="hljs-string">'define({\'prop-x\':1})'</span>, checkForLegacyModules, <span class="hljs-string">'nonsense'</span>, amdValue);
								t.is(amdValue, check);
								t.is({
									<span class="hljs-string">'prop-x'</span>: <span class="hljs-number">1</span>
								}, amdValue.result);
								check = evalBundle(<span class="hljs-string">'define(\'some/module\', {\'prop-x\':1})'</span>, checkForLegacyModules, <span class="hljs-string">'nonsense'</span>, amdValue);
								t.is(amdValue, check);
								t.is({
									<span class="hljs-string">'prop-x'</span>: <span class="hljs-number">1</span>
								}, amdValue.result);
								check = evalBundle(<span class="hljs-string">'this is total nonsense and should throw an error'</span>, checkForLegacyModules, <span class="hljs-string">'nonsense'</span>, amdValue);
								t.is(check <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>, <span class="hljs-literal">true</span>);
							});
						});
					}
				}
				<span class="hljs-keyword">return</span> lang.mixin(thisModule, {
					dynamic: <span class="hljs-literal">true</span>,
					normalize: normalize,
					load: load,
					cache: cache
				});
			});
		},
		<span class="hljs-string">'dojo/promise/tracer'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'../_base/lang'</span>,
				<span class="hljs-string">'./Promise'</span>,
				<span class="hljs-string">'../Evented'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(lang, Promise, Evented)</span> {</span>
<span class="hljs-pi">				'use strict'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-187">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-187">&#182;</a>
              </div>
              <p>module:
    dojo/promise/tracer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             return {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-188">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-188">&#182;</a>
              </div>
              <p>summary:
    Trace promise fulfillment.
description:
    Trace promise fulfillment. Calling <code>.trace()</code> or <code>.traceError()</code> on a
    promise enables tracing. Will emit <code>resolved</code>, <code>rejected</code> or <code>progress</code>
    events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
             on: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(type, listener)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-189">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-189">&#182;</a>
              </div>
              <p>summary:
    Subscribe to traces.
description:
    See <code>dojo/Evented#on()</code>.
type: String
    <code>resolved</code>, <code>rejected</code>, or <code>progress</code>
listener: Function
    The listener is passed the traced value and any arguments
    that were used with the <code>.trace()</code> call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             }
             };
             =====*/
				var evented = new Evented();
				var emit = evented.emit;
				evented.emit = null;</pre></div></div>
            
        </li>
        
        
        <li id="section-190">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-190">&#182;</a>
              </div>
              <p>Emit events asynchronously since they should not change the promise state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">emitAsync</span><span class="hljs-params">(args)</span> {</span>
					setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						emit.apply(evented, args);
					}, <span class="hljs-number">0</span>);
				}
				Promise.prototype.trace = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-191">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-191">&#182;</a>
              </div>
              <p>summary:
    Trace the promise.
description:
    Tracing allows you to transparently log progress,
    resolution and rejection of promises, without affecting the
    promise itself. Any arguments passed to <code>trace()</code> are
    emitted in trace events. See <code>dojo/promise/tracer</code> on how
    to handle traces.
returns: dojo/promise/Promise
    The promise instance <code>trace()</code> is called on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> args = lang._toArray(<span class="hljs-built_in">arguments</span>);
					<span class="hljs-keyword">this</span>.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> {</span>
						emitAsync([
							<span class="hljs-string">'resolved'</span>,
							value
						].concat(args));
					}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> {</span>
						emitAsync([
							<span class="hljs-string">'rejected'</span>,
							error
						].concat(args));
					}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(update)</span> {</span>
						emitAsync([
							<span class="hljs-string">'progress'</span>,
							update
						].concat(args));
					});
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
				};
				Promise.prototype.traceRejected = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-192">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-192">&#182;</a>
              </div>
              <p>summary:
    Trace rejection of the promise.
description:
    Tracing allows you to transparently log progress,
    resolution and rejection of promises, without affecting the
    promise itself. Any arguments passed to <code>trace()</code> are
    emitted in trace events. See <code>dojo/promise/tracer</code> on how
    to handle traces.
returns: dojo/promise/Promise
    The promise instance <code>traceRejected()</code> is called on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> args = lang._toArray(<span class="hljs-built_in">arguments</span>);
					<span class="hljs-keyword">this</span>.otherwise(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> {</span>
						emitAsync([
							<span class="hljs-string">'rejected'</span>,
							error
						].concat(args));
					});
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
				};
				<span class="hljs-keyword">return</span> evented;
			});
		},
		<span class="hljs-string">'dojo/errors/RequestError'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([<span class="hljs-string">'./create'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(create)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-193">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-193">&#182;</a>
              </div>
              <p>module:
    dojo/errors/RequestError</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             return function(){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-194">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-194">&#182;</a>
              </div>
              <p>summary:
    TODOC</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				return create('RequestError', function (message, response) {
					this.response = response;
				});
			});
		},
		'dojo/_base/html': function () {
			define('dojo/_base/html', [
				'./kernel',
				'../dom',
				'../dom-style',
				'../dom-attr',
				'../dom-prop',
				'../dom-class',
				'../dom-construct',
				'../dom-geometry'
			], function (dojo, dom, style, attr, prop, cls, ctr, geom) {</pre></div></div>
            
        </li>
        
        
        <li id="section-195">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-195">&#182;</a>
              </div>
              <p>module:
    dojo/dom</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             return {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-196">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-196">&#182;</a>
              </div>
              <p>summary:
    This module is a stub for the core dojo DOM API.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/</pre></div></div>
            
        </li>
        
        
        <li id="section-197">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-197">&#182;</a>
              </div>
              <p>mix-in dom</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo.byId = dom.byId;
				dojo.isDescendant = dom.isDescendant;
				dojo.setSelectable = dom.setSelectable;</pre></div></div>
            
        </li>
        
        
        <li id="section-198">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-198">&#182;</a>
              </div>
              <p>mix-in dom-attr</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo.getAttr = attr.get;
				dojo.setAttr = attr.set;
				dojo.hasAttr = attr.has;
				dojo.removeAttr = attr.remove;
				dojo.getNodeProp = attr.getNodeProp;
				dojo.attr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, name, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-199">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-199">&#182;</a>
              </div>
              <p>summary:
    Gets or sets an attribute on an HTML element.
description:
    Handles normalized getting and setting of attributes on DOM
    Nodes. If 2 arguments are passed, and a the second argument is a
    string, acts as a getter.</p>
<pre><code>If a third argument is passed, or <span class="hljs-keyword">if</span> the second argument is a
map of attributes, acts as a setter.

When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the <span class="hljs-keyword">default</span>
behavior will be removed and the <span class="hljs-keyword">new</span> behavior will be added
using `dojo.connect()`, meaning that event handler properties
will be normalized and that some caveats <span class="hljs-keyword">with</span> regards to
non-standard behaviors <span class="hljs-keyword">for</span> onsubmit apply. Namely that you
should cancel form submission using `dojo.stopEvent()` on the
passed event object instead of returning a boolean value from
the handler itself.
</code></pre><p>node: DOMNode|String
    id or reference to the element to get or set the attribute on
name: String|Object
    the name of the attribute to get or set.
value: String?
    The value to set for the attribute
returns:
    when used as a getter, the value of the requested attribute
    or null if that attribute does not have a specified or
    default value;</p>
<pre><code>when used as a setter, the DOM node
</code></pre><p>example:
|    // get the current value of the “foo” attribute on a node
|    dojo.attr(dojo.byId(“nodeId”), “foo”);
|    // or we can just pass the id:
|    dojo.attr(“nodeId”, “foo”);</p>
<p>example:
|    // use attr() to set the tab index
|    dojo.attr(“nodeId”, “tabIndex”, 3);
|</p>
<p>example:
Set multiple values at once, including event handlers:
|    dojo.attr(“formId”, {
|        “foo”: “bar”,
|        “tabIndex”: -1,
|        “method”: “POST”,
|        “onsubmit”: function(e){
|            // stop submitting the form. Note that the IE behavior
|            // of returning true or false will have no effect here
|            // since our handler is connect()ed to the built-in
|            // onsubmit behavior and so we need to use
|            // dojo.stopEvent() to ensure that the submission
|            // doesn’t proceed.
|            dojo.stopEvent(e);
|
|            // submit the form with Ajax
|            dojo.xhrPost({ form: “formId” });
|        }
|    });</p>
<p>example:
Style is s special case: Only set with an object hash of styles
|    dojo.attr(“someNode”,{
|        id:”bar”,
|        style:{
|            width:”200px”, height:”100px”, color:”#000”
|        }
|    });</p>
<p>example:
Again, only set style as an object hash of styles:
|    var obj = { color:”#fff”, backgroundColor:”#000” };
|    dojo.attr(“someNode”, “style”, obj);
|
|    // though shorter to use <code>dojo.style()</code> in this case:
|    dojo.style(“someNode”, obj);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) {
						<span class="hljs-keyword">return</span> attr[<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">'string'</span> ? <span class="hljs-string">'get'</span> : <span class="hljs-string">'set'</span>](node, name);
					}
					<span class="hljs-keyword">return</span> attr.set(node, name, value);
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-200">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-200">&#182;</a>
              </div>
              <p>mix-in dom-class</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo.hasClass = cls.contains;
				dojo.addClass = cls.add;
				dojo.removeClass = cls.remove;
				dojo.toggleClass = cls.toggle;
				dojo.replaceClass = cls.replace;</pre></div></div>
            
        </li>
        
        
        <li id="section-201">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-201">&#182;</a>
              </div>
              <p>mix-in dom-construct</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo._toDom = dojo.toDom = ctr.toDom;
				dojo.place = ctr.place;
				dojo.create = ctr.create;
				dojo.empty = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
					ctr.empty(node);
				};
				dojo._destroyElement = dojo.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
					ctr.destroy(node);
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-202">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-202">&#182;</a>
              </div>
              <p>mix-in dom-geometry</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo._getPadExtents = dojo.getPadExtents = geom.getPadExtents;
				dojo._getBorderExtents = dojo.getBorderExtents = geom.getBorderExtents;
				dojo._getPadBorderExtents = dojo.getPadBorderExtents = geom.getPadBorderExtents;
				dojo._getMarginExtents = dojo.getMarginExtents = geom.getMarginExtents;
				dojo._getMarginSize = dojo.getMarginSize = geom.getMarginSize;
				dojo._getMarginBox = dojo.getMarginBox = geom.getMarginBox;
				dojo.setMarginBox = geom.setMarginBox;
				dojo._getContentBox = dojo.getContentBox = geom.getContentBox;
				dojo.setContentSize = geom.setContentSize;
				dojo._isBodyLtr = dojo.isBodyLtr = geom.isBodyLtr;
				dojo._docScroll = dojo.docScroll = geom.docScroll;
				dojo._getIeDocumentElementOffset = dojo.getIeDocumentElementOffset = geom.getIeDocumentElementOffset;
				dojo._fixIeBiDiScrollLeft = dojo.fixIeBiDiScrollLeft = geom.fixIeBiDiScrollLeft;
				dojo.position = geom.position;
				dojo.marginBox = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">marginBox</span><span class="hljs-params">(node, box)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-203">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-203">&#182;</a>
              </div>
              <p>summary:
    Getter/setter for the margin-box of node.
description:
    Getter/setter for the margin-box of node.
    Returns an object in the expected format of box (regardless
    if box is passed). The object might look like:
    <code>{ l: 50, t: 200, w: 300: h: 150 }</code>
    for a node offset from its parent 50px to the left, 200px from
    the top with a margin width of 300px and a margin-height of
    150px.
node:
    id or reference to DOM Node to get/set box for
box:
    If passed, denotes that dojo.marginBox() should
    update/set the margin box for node. Box is an object in the
    above format. All properties are optional if passed.
example:
    Retrieve the margin box of a passed node
|    var box = dojo.marginBox(“someNodeId”);
|    console.dir(box);</p>
<p>example:
    Set a node’s margin box to the size of another node
|    var box = dojo.marginBox(“someNodeId”);
|    dojo.marginBox(“someOtherNode”, box);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> box ? geom.setMarginBox(node, box) : geom.getMarginBox(node); <span class="hljs-comment">// Object</span>
				};
				dojo.contentBox = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contentBox</span><span class="hljs-params">(node, box)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-204">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-204">&#182;</a>
              </div>
              <p>summary:
    Getter/setter for the content-box of node.
description:
    Returns an object in the expected format of box (regardless if box is passed).
    The object might look like:
    <code>{ l: 50, t: 200, w: 300: h: 150 }</code>
    for a node offset from its parent 50px to the left, 200px from
    the top with a content width of 300px and a content-height of
    150px. Note that the content box may have a much larger border
    or margin box, depending on the box model currently in use and
    CSS values set/inherited for node.
    While the getter will return top and left values, the
    setter only accepts setting the width and height.
node:
    id or reference to DOM Node to get/set box for
box:
    If passed, denotes that dojo.contentBox() should
    update/set the content box for node. Box is an object in the
    above format, but only w (width) and h (height) are supported.
    All properties are optional if passed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> box ? geom.setContentSize(node, box) : geom.getContentBox(node); <span class="hljs-comment">// Object</span>
				};
				dojo.coords = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, includeScroll)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-205">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-205">&#182;</a>
              </div>
              <p>summary:
    Deprecated: Use position() for border-box x/y/w/h
    or marginBox() for margin-box w/h/l/t.</p>
<pre><code>Returns an object that measures margin-box (w)idth/(h)eight
and absolute position x/y of the border-box. Also returned
is computed (l)eft and (t)op values in pixels from the
node&#39;s offsetParent as returned from marginBox().
Return value will be in the form:
</code></pre><p>|            { l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }
    Does not act as a setter. If includeScroll is passed, the x and
    y params are affected as one would expect in dojo.position().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					dojo.deprecated(<span class="hljs-string">'dojo.coords()'</span>, <span class="hljs-string">'Use dojo.position() or dojo.marginBox().'</span>);
					node = dom.byId(node);
					<span class="hljs-keyword">var</span> s = style.getComputedStyle(node),
						mb = geom.getMarginBox(node, s);
					<span class="hljs-keyword">var</span> abs = geom.position(node, includeScroll);
					mb.x = abs.x;
					mb.y = abs.y;
					<span class="hljs-keyword">return</span> mb; <span class="hljs-comment">// Object</span>
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-206">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-206">&#182;</a>
              </div>
              <p>mix-in dom-prop</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo.getProp = prop.get;
				dojo.setProp = prop.set;
				dojo.prop = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, name, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-207">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-207">&#182;</a>
              </div>
              <p>summary:
    Gets or sets a property on an HTML element.
description:
    Handles normalized getting and setting of properties on DOM
    Nodes. If 2 arguments are passed, and a the second argument is a
    string, acts as a getter.</p>
<pre><code>If a third argument is passed, or <span class="hljs-keyword">if</span> the second argument is a
map of attributes, acts as a setter.

When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the <span class="hljs-keyword">default</span>
behavior will be removed and the <span class="hljs-keyword">new</span> behavior will be added
using `dojo.connect()`, meaning that event handler properties
will be normalized and that some caveats <span class="hljs-keyword">with</span> regards to
non-standard behaviors <span class="hljs-keyword">for</span> onsubmit apply. Namely that you
should cancel form submission using `dojo.stopEvent()` on the
passed event object instead of returning a boolean value from
the handler itself.
</code></pre><p>node:
    id or reference to the element to get or set the property on
name:
    the name of the property to get or set.
value:
    The value to set for the property
returns:
    when used as a getter, the value of the requested property
    or null if that attribute does not have a specified or
    default value;</p>
<pre><code>when used as a setter, the DOM node
</code></pre><p>example:
|    // get the current value of the “foo” property on a node
|    dojo.prop(dojo.byId(“nodeId”), “foo”);
|    // or we can just pass the id:
|    dojo.prop(“nodeId”, “foo”);</p>
<p>example:
|    // use prop() to set the tab index
|    dojo.prop(“nodeId”, “tabIndex”, 3);
|</p>
<p>example:
Set multiple values at once, including event handlers:
|    dojo.prop(“formId”, {
|        “foo”: “bar”,
|        “tabIndex”: -1,
|        “method”: “POST”,
|        “onsubmit”: function(e){
|            // stop submitting the form. Note that the IE behavior
|            // of returning true or false will have no effect here
|            // since our handler is connect()ed to the built-in
|            // onsubmit behavior and so we need to use
|            // dojo.stopEvent() to ensure that the submission
|            // doesn’t proceed.
|            dojo.stopEvent(e);
|
|            // submit the form with Ajax
|            dojo.xhrPost({ form: “formId” });
|        }
|    });</p>
<p>example:
    Style is s special case: Only set with an object hash of styles
|    dojo.prop(“someNode”,{
|        id:”bar”,
|        style:{
|            width:”200px”, height:”100px”, color:”#000”
|        }
|    });</p>
<p>example:
    Again, only set style as an object hash of styles:
|    var obj = { color:”#fff”, backgroundColor:”#000” };
|    dojo.prop(“someNode”, “style”, obj);
|
|    // though shorter to use <code>dojo.style()</code> in this case:
|    dojo.style(“someNode”, obj);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) {
						<span class="hljs-keyword">return</span> prop[<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">'string'</span> ? <span class="hljs-string">'get'</span> : <span class="hljs-string">'set'</span>](node, name);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-208">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-208">&#182;</a>
              </div>
              <p>setter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> prop.set(node, name, value);
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-209">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-209">&#182;</a>
              </div>
              <p>mix-in dom-style</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo.getStyle = style.get;
				dojo.setStyle = style.set;
				dojo.getComputedStyle = style.getComputedStyle;
				dojo.__toPixelValue = dojo.toPixelValue = style.toPixelValue;
				dojo.style = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, name, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-210">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-210">&#182;</a>
              </div>
              <p>summary:
    Accesses styles on a node. If 2 arguments are
    passed, acts as a getter. If 3 arguments are passed, acts
    as a setter.
description:
    Getting the style value uses the computed style for the node, so the value
    will be a calculated value, not just the immediate node.style value.
    Also when getting values, use specific style names,
    like “borderBottomWidth” instead of “border” since compound values like
    “border” are not necessarily reflected as expected.
    If you want to get node dimensions, use <code>dojo.marginBox()</code>,
    <code>dojo.contentBox()</code> or <code>dojo.position()</code>.
node: DOMNode|String
    id or reference to node to get/set style for
name: String|Object?
    the style property to set in DOM-accessor format
    (“borderWidth”, not “border-width”) or an object with key/value
    pairs suitable for setting each property.
value: String?
    If passed, sets value on the node for style, handling
    cross-browser concerns.  When setting a pixel value,
    be sure to include “px” in the value. For instance, top: “200px”.
    Otherwise, in some cases, some browsers will not apply the style.
returns:
    when used as a getter, return the computed style of the node if passing in an ID or node,
    or return the normalized, computed value for the property when passing in a node and a style property
example:
    Passing only an ID or node returns the computed style object of
    the node:
|    dojo.style(“thinger”);
example:
    Passing a node and a style property returns the current
    normalized, computed value for that property:
|    dojo.style(“thinger”, “opacity”); // 1 by default</p>
<p>example:
    Passing a node, a style property, and a value changes the
    current display of the node and returns the new computed value
|    dojo.style(“thinger”, “opacity”, 0.5); // == 0.5</p>
<p>example:
    Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
|    dojo.style(“thinger”, {
|        “opacity”: 0.5,
|        “border”: “3px solid black”,
|        “height”: “300px”
|    });</p>
<p>example:
    When the CSS style property is hyphenated, the JavaScript property is camelCased.
    font-size becomes fontSize, and so on.
|    dojo.style(“thinger”,{
|        fontSize:”14pt”,
|        letterSpacing:”1.2em”
|    });</p>
<p>example:
    dojo/NodeList implements .style() using the same syntax, omitting the “node” parameter, calling
    dojo.style() on every element of the list. See: <code>dojo/query</code> and <code>dojo/NodeList</code>
|    dojo.query(“.someClassName”).style(“visibility”,”hidden”);
|    // or
|    dojo.query(“#baz &gt; div”).style({
|        opacity:0.75,
|        fontSize:”13pt”
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) {
					<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
						<span class="hljs-keyword">return</span> style.get(node);
					<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
						<span class="hljs-keyword">return</span> style[<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">'string'</span> ? <span class="hljs-string">'get'</span> : <span class="hljs-string">'set'</span>](node, name);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-211">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-211">&#182;</a>
              </div>
              <p>setter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> style.set(node, name, value);
				};
				<span class="hljs-keyword">return</span> dojo;
			});
		},
		<span class="hljs-string">'dojo/_base/kernel'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'../has'</span>,
				<span class="hljs-string">'./config'</span>,
				<span class="hljs-string">'require'</span>,
				<span class="hljs-string">'module'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(has, config, require, module)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-212">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-212">&#182;</a>
              </div>
              <p>module:
    dojo/_base/kernel
This module is the foundational module of the dojo boot sequence; it defines the dojo object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span></pre></div></div>
            
        </li>
        
        
        <li id="section-213">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-213">&#182;</a>
              </div>
              <p>loop variables for this module</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				i, p,</pre></div></div>
            
        </li>
        
        
        <li id="section-214">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-214">&#182;</a>
              </div>
              <p>create dojo, dijit, and dojox
FIXME: in 2.0 remove dijit, dojox being created by dojo</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					dijit = {}, dojox = {}, dojo = {
						config: config,
						global: <span class="hljs-keyword">this</span>,
						dijit: dijit,
						dojox: dojox
					};</pre></div></div>
            
        </li>
        
        
        <li id="section-215">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-215">&#182;</a>
              </div>
              <p>Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide
a _scopeName property for the dojo, dijit, and dojox root object so those packages can create
unique names in the global space.</p>
<p>Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,
where global when in fact they are either global under different names or not global at all. In v1.6-, the
config variable “scopeMap” was used to map names as used within a module to global names. This has been
subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,
only the “*” mapping is supported. See <a href="http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode">http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode</a> for details.</p>
<p>The following computations contort the packageMap for this dojo instance into a scopeMap.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> scopeMap = {
					dojo: [
						<span class="hljs-string">'dojo'</span>,
						dojo
					],
					dijit: [
						<span class="hljs-string">'dijit'</span>,
						dijit
					],
					dojox: [
						<span class="hljs-string">'dojox'</span>,
						dojox
					]
				}, packageMap = <span class="hljs-built_in">require</span>.map &amp;&amp; <span class="hljs-built_in">require</span>.map[module.id.match(<span class="hljs-regexp">/[^\/]+/</span>)[<span class="hljs-number">0</span>]],
					item;</pre></div></div>
            
        </li>
        
        
        <li id="section-216">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-216">&#182;</a>
              </div>
              <p>process all mapped top-level names for this instance of dojo</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> packageMap) {
					<span class="hljs-keyword">if</span> (scopeMap[p]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-217">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-217">&#182;</a>
              </div>
              <p>mapped dojo, dijit, or dojox</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						scopeMap[p][<span class="hljs-number">0</span>] = packageMap[p];
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-218">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-218">&#182;</a>
              </div>
              <p>some other top-level name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						scopeMap[p] = [
							packageMap[p], {}
						];
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-219">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-219">&#182;</a>
              </div>
              <p>publish those names to _scopeName and, optionally, the global namespace</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> scopeMap) {
					item = scopeMap[p];
					item[<span class="hljs-number">1</span>]._scopeName = item[<span class="hljs-number">0</span>];
					<span class="hljs-keyword">if</span> (!config.noGlobals) {
						<span class="hljs-keyword">this</span>[item[<span class="hljs-number">0</span>]] = item[<span class="hljs-number">1</span>];
					}
				}
				dojo.scopeMap = scopeMap;
				<span class="hljs-comment">/*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-220">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-220">&#182;</a>
              </div>
              <p>FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo.baseUrl = dojo.config.baseUrl = <span class="hljs-built_in">require</span>.baseUrl;
				dojo.isAsync = !<span class="hljs-number">1</span> || <span class="hljs-built_in">require</span>.async;
				dojo.locale = config.locale;
				<span class="hljs-keyword">var</span> rev = <span class="hljs-string">'$Rev: 29801 $'</span>.match(<span class="hljs-regexp">/\d+/</span>);
				dojo.version = {
					major: <span class="hljs-number">1</span>,
					minor: <span class="hljs-number">8</span>,
					patch: <span class="hljs-number">1</span>,
					flag: <span class="hljs-string">''</span>,
					revision: rev ? +rev[<span class="hljs-number">0</span>] : <span class="hljs-literal">NaN</span>,
					toString: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">var</span> v = dojo.version;
						<span class="hljs-keyword">return</span> v.major + <span class="hljs-string">'.'</span> + v.minor + <span class="hljs-string">'.'</span> + v.patch + v.flag + <span class="hljs-string">' ('</span> + v.revision + <span class="hljs-string">')'</span>; <span class="hljs-comment">// String</span>
					}
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-221">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-221">&#182;</a>
              </div>
              <p>If  1  is truthy, then as a dojo module is defined it should push it’s definitions
into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object
as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code
is migrated. Absent specific advice otherwise, set extend-dojo to truthy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-number">1</span> || has.add(<span class="hljs-string">'extend-dojo'</span>, <span class="hljs-number">1</span>);
				<span class="hljs-built_in">Function</span>(<span class="hljs-string">'d'</span>, <span class="hljs-string">'d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}'</span>)(dojo);
				<span class="hljs-comment">/*=====
             dojo.eval = function(scriptText){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-222">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-222">&#182;</a>
              </div>
              <p>summary:
    A legacy method created for use exclusively by internal Dojo methods. Do not use this method
    directly unless you understand its possibly-different implications on the platforms your are targeting.
description:
    Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
    that support indirect eval.</p>
<pre><code>As usual, IE does not. On IE, the only way to implement global eval is to
use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
This implementation uses the technique of executing eval in the scope of a function that is a single scope
frame below the global scope; thereby coming close to the global scope. Note carefully that

dojo.eval(&quot;var pi = 3.14;&quot;);

will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
to define a global variable using dojo.eval, write something like

dojo.eval(&quot;window.pi = 3.14;&quot;)
</code></pre><p>scriptText:
    The text to evaluation.
returns:
    The result of the evaluation. Often <code>undefined</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				if (0) {
					dojo.exit = function (exitcode) {
						quit(exitcode);
					};
				} else {
					dojo.exit = function () {};
				}
				1 || has.add('dojo-guarantee-console', 1);
				if (1) {
					typeof console !== 'undefined' || (console = {});</pre></div></div>
            
        </li>
        
        
        <li id="section-223">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-223">&#182;</a>
              </div>
              <p>Be careful to leave ‘log’ always at the end</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> cn = [
						<span class="hljs-string">'assert'</span>,
						<span class="hljs-string">'count'</span>,
						<span class="hljs-string">'debug'</span>,
						<span class="hljs-string">'dir'</span>,
						<span class="hljs-string">'dirxml'</span>,
						<span class="hljs-string">'error'</span>,
						<span class="hljs-string">'group'</span>,
						<span class="hljs-string">'groupEnd'</span>,
						<span class="hljs-string">'info'</span>,
						<span class="hljs-string">'profile'</span>,
						<span class="hljs-string">'profileEnd'</span>,
						<span class="hljs-string">'time'</span>,
						<span class="hljs-string">'timeEnd'</span>,
						<span class="hljs-string">'trace'</span>,
						<span class="hljs-string">'warn'</span>,
						<span class="hljs-string">'log'</span>
					];
					<span class="hljs-keyword">var</span> tn;
					i = <span class="hljs-number">0</span>;
					<span class="hljs-keyword">while</span> (tn = cn[i++]) {
						<span class="hljs-keyword">if</span> (!console[tn]) {
							(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								<span class="hljs-keyword">var</span> tcn = tn + <span class="hljs-string">''</span>;
								console[tcn] = <span class="hljs-string">'log'</span> <span class="hljs-keyword">in</span> console ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
									<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Array</span>.apply({}, <span class="hljs-built_in">arguments</span>);
									a.unshift(tcn + <span class="hljs-string">':'</span>);
									console.log(a.join(<span class="hljs-string">' '</span>));
								} : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>};
								console[tcn]._fake = <span class="hljs-literal">true</span>;
							}());
						}
					}
				}
				has.add(<span class="hljs-string">'dojo-debug-messages'</span>, !! config.isDebug);
				dojo.deprecated = dojo.experimental = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>};
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'dojo-debug-messages'</span>)) {
					dojo.deprecated = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(behaviour, extra, removal)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-224">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-224">&#182;</a>
              </div>
              <p>summary:
    Log a debug message to indicate that a behavior has been
    deprecated.
behaviour: String
    The API or behavior being deprecated. Usually in the form
    of “myApp.someFunction()”.
extra: String?
    Text to append to the message. Often provides advice on a
    new function or facility to achieve the same goal during
    the deprecation period.
removal: String?
    Text to indicate when in the future the behavior will be
    removed. Usually a version number.
example:
| dojo.deprecated(“myApp.getTemp()”, “use myApp.getLocaleTemp() instead”, “1.0”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> message = <span class="hljs-string">'DEPRECATED: '</span> + behaviour;
						<span class="hljs-keyword">if</span> (extra) {
							message += <span class="hljs-string">' '</span> + extra;
						}
						<span class="hljs-keyword">if</span> (removal) {
							message += <span class="hljs-string">' -- will be removed in version: '</span> + removal;
						}
						console.warn(message);
					};
					dojo.experimental = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(moduleName, extra)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-225">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-225">&#182;</a>
              </div>
              <p>summary:
    Marks code as experimental.
description:
    This can be used to mark a function, file, or module as
    experimental.     Experimental code is not ready to be used, and the
    APIs are subject to change without notice.    Experimental code may be
    completed deleted without going through the normal deprecation
    process.
moduleName: String
    The name of a module, or the name of a module file or a specific
    function
extra: String?
    some additional message for the user
example:
| dojo.experimental(“dojo.data.Result”);
example:
| dojo.experimental(“dojo.weather.toKelvin()”, “PENDING approval from NOAA”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> message = <span class="hljs-string">'EXPERIMENTAL: '</span> + moduleName + <span class="hljs-string">' -- APIs subject to change without notice.'</span>;
						<span class="hljs-keyword">if</span> (extra) {
							message += <span class="hljs-string">' '</span> + extra;
						}
						console.warn(message);
					};
				}
				<span class="hljs-number">1</span> || has.add(<span class="hljs-string">'dojo-modulePaths'</span>, <span class="hljs-number">1</span>);
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-226">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-226">&#182;</a>
              </div>
              <p>notice that modulePaths won’t be applied to any require’s before the dojo/_base/kernel factory is run;
this is the v1.6- behavior.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (config.modulePaths) {
						dojo.deprecated(<span class="hljs-string">'dojo.modulePaths'</span>, <span class="hljs-string">'use paths configuration'</span>);
						<span class="hljs-keyword">var</span> paths = {};
						<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> config.modulePaths) {
							paths[p.replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">'/'</span>)] = config.modulePaths[p];
						}
						<span class="hljs-built_in">require</span>({
							paths: paths
						});
					}
				}
				<span class="hljs-number">1</span> || has.add(<span class="hljs-string">'dojo-moduleUrl'</span>, <span class="hljs-number">1</span>);
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
					dojo.moduleUrl = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module, url)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-227">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-227">&#182;</a>
              </div>
              <p>summary:
    Returns a URL relative to a module.
example:
|    var pngPath = dojo.moduleUrl(“acme”,”images/small.png”);
|    console.dir(pngPath); // list the object properties
|    // create an image and set it’s source to pngPath’s value:
|    var img = document.createElement(“img”);
|    img.src = pngPath;
|    // add our image to the document
|    dojo.body().appendChild(img);
example:
    you may de-reference as far as you like down the package
    hierarchy.  This is sometimes handy to avoid lenghty relative
    urls or for building portable sub-packages. In this example,
    the <code>acme.widget</code> and <code>acme.util</code> directories may be located
    under different roots (see <code>dojo.registerModulePath</code>) but the
    the modules which reference them can be unaware of their
    relative locations on the filesystem:
|    // somewhere in a configuration block
|    dojo.registerModulePath(“acme.widget”, “../../acme/widget”);
|    dojo.registerModulePath(“acme.util”, “../../util”);
|
|    // …
|
|    // code in a module using acme resources
|    var tmpltPath = dojo.moduleUrl(“acme.widget”,”templates/template.html”);
|    var dataPath = dojo.moduleUrl(“acme.util”,”resources/data.json”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						dojo.deprecated(<span class="hljs-string">'dojo.moduleUrl()'</span>, <span class="hljs-string">'use require.toUrl'</span>, <span class="hljs-string">'2.0'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-228">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-228">&#182;</a>
              </div>
              <p>require.toUrl requires a filetype; therefore, just append the suffix “/<em>.</em>“ to guarantee a filetype, then
remove the suffix from the result. This way clients can request a url w/out a filetype. This should be
rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).
Notice * is an illegal filename so it won’t conflict with any real path map that may exist the paths config.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> result = <span class="hljs-literal">null</span>;
						<span class="hljs-keyword">if</span> (module) {
							result = <span class="hljs-built_in">require</span>.toUrl(module.replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">'/'</span>) + (url ? <span class="hljs-string">'/'</span> + url : <span class="hljs-string">''</span>) + <span class="hljs-string">'/*.*'</span>)
								.replace(<span class="hljs-regexp">/\/\*\.\*/</span>, <span class="hljs-string">''</span>) + (url ? <span class="hljs-string">''</span> : <span class="hljs-string">'/'</span>);
						}
						<span class="hljs-keyword">return</span> result;
					};
				}
				dojo._hasResource = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-229">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-229">&#182;</a>
              </div>
              <p>for backward compatibility with layers built with 1.6 tooling</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> dojo;
			});
		},
		<span class="hljs-string">'dojo/io-query'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([<span class="hljs-string">'./_base/lang'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(lang)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-230">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-230">&#182;</a>
              </div>
              <p>module:
    dojo/io-query</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> backstop = {};
				<span class="hljs-keyword">return</span> {
					objectToQuery: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectToQuery</span><span class="hljs-params">(map)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-231">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-231">&#182;</a>
              </div>
              <p>summary:
    takes a name/value mapping object and returns a string representing
    a URL-encoded version of that object.
example:
    this object:</p>
<p>|    {
|        blah: “blah”,
|        multi: [
|            “thud”,
|            “thonk”
|        ]
|    };</p>
<pre><code>yields the following query string:
</code></pre><p>|    “blah=blah&amp;multi=thud&amp;multi=thonk”
FIXME: need to implement encodeAscii!!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> enc = <span class="hljs-built_in">encodeURIComponent</span>,
							pairs = [];
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> map) {
							<span class="hljs-keyword">var</span> value = map[name];
							<span class="hljs-keyword">if</span> (value !== backstop[name]) {
								<span class="hljs-keyword">var</span> assign = enc(name) + <span class="hljs-string">'='</span>;
								<span class="hljs-keyword">if</span> (lang.isArray(value)) {
									<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = value.length; i &lt; l; ++i) {
										pairs.push(assign + enc(value[i]));
									}
								} <span class="hljs-keyword">else</span> {
									pairs.push(assign + enc(value));
								}
							}
						}
						<span class="hljs-keyword">return</span> pairs.join(<span class="hljs-string">'&amp;'</span>); <span class="hljs-comment">// String</span>
					},
					queryToObject: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryToObject</span><span class="hljs-params">(str)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-232">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-232">&#182;</a>
              </div>
              <p>summary:
    Create an object representing a de-serialized query section of a
    URL. Query keys with multiple values are returned in an array.</p>
<p>example:
    This string:</p>
<p>|        “foo=bar&amp;foo=baz&amp;thinger=%20spaces%20=blah&amp;zonk=blarg&amp;”</p>
<pre><code>results <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> object structure:
</code></pre><p>|        {
|            foo: [ “bar”, “baz” ],
|            thinger: “ spaces =blah”,
|            zonk: “blarg”
|        }</p>
<pre><code>Note that spaces and other urlencoded entities are correctly
handled.
</code></pre><p>FIXME: should we grab the URL string if we’re not passed one?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> dec = <span class="hljs-built_in">decodeURIComponent</span>,
							qp = str.split(<span class="hljs-string">'&amp;'</span>),
							ret = {}, name, val;
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = qp.length, item; i &lt; l; ++i) {
							item = qp[i];
							<span class="hljs-keyword">if</span> (item.length) {
								<span class="hljs-keyword">var</span> s = item.indexOf(<span class="hljs-string">'='</span>);
								<span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>) {
									name = dec(item);
									val = <span class="hljs-string">''</span>;
								} <span class="hljs-keyword">else</span> {
									name = dec(item.slice(<span class="hljs-number">0</span>, s));
									val = dec(item.slice(s + <span class="hljs-number">1</span>));
								}
								<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ret[name] === <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-233">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-233">&#182;</a>
              </div>
              <p>inline’d type check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									ret[name] = [ret[name]];
								}
								<span class="hljs-keyword">if</span> (lang.isArray(ret[name])) {
									ret[name].push(val);
								} <span class="hljs-keyword">else</span> {
									ret[name] = val;
								}
							}
						}
						<span class="hljs-keyword">return</span> ret; <span class="hljs-comment">// Object</span>
					}
				};
			});
		},
		<span class="hljs-string">'dojo/_base/Deferred'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'../Deferred'</span>,
				<span class="hljs-string">'../promise/Promise'</span>,
				<span class="hljs-string">'../errors/CancelError'</span>,
				<span class="hljs-string">'../has'</span>,
				<span class="hljs-string">'./lang'</span>,
				<span class="hljs-string">'../when'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, NewDeferred, Promise, CancelError, has, lang, when)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-234">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-234">&#182;</a>
              </div>
              <p>module:
    dojo/_base/Deferred</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> mutator = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>};
				<span class="hljs-keyword">var</span> freeze = <span class="hljs-built_in">Object</span>.freeze || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-235">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-235">&#182;</a>
              </div>
              <p>A deferred provides an API for creating and resolving a promise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> Deferred = dojo.Deferred = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(canceller)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-236">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-236">&#182;</a>
              </div>
              <p>summary:
    Deprecated.   This module defines the legacy dojo/_base/Deferred API.
    New code should use dojo/Deferred instead.
description:
    The Deferred API is based on the concept of promises that provide a
    generic interface into the eventual completion of an asynchronous action.
    The motivation for promises fundamentally is about creating a
    separation of concerns that allows one to achieve the same type of
    call patterns and logical data flow in asynchronous code as can be
    achieved in synchronous code. Promises allows one
    to be able to call a function purely with arguments needed for
    execution, without conflating the call with concerns of whether it is
    sync or async. One shouldn’t need to alter a call’s arguments if the
    implementation switches from sync to async (or vice versa). By having
    async functions return promises, the concerns of making the call are
    separated from the concerns of asynchronous interaction (which are
    handled by the promise).</p>
<pre><code>The Deferred is a type of promise that provides methods for fulfilling the
promise with a successful result or an error. The most important method for
working with Dojo&#39;s promises is the then() method, which follows the
CommonJS proposed promise API. An example of using a Dojo promise:

|    var resultingPromise = someAsyncOperation.then(function(result){
|        ... handle result ...
|    },
|    function(error){
|        ... handle error ...
|    });

The .then() call returns a new promise that represents the result of the
execution of the callback. The callbacks will never affect the original promises value.

The Deferred instances also provide the following functions for backwards compatibility:

- addCallback(handler)
- addErrback(handler)
- callback(result)
- errback(result)

Callbacks are allowed to return promises themselves, so
you can build complicated sequences of events with ease.

The creator of the Deferred may specify a canceller.  The canceller
is a function that will be called if Deferred.cancel is called
before the Deferred fires. You can use this to implement clean
aborting of an XMLHttpRequest, etc. Note that cancel will fire the
deferred with a CancelledError (unless your canceller returns
another kind of error), so the errbacks should be prepared to
handle that error for cancellable Deferreds.
</code></pre><p>example:
|    var deferred = new Deferred();
|    setTimeout(function(){ deferred.callback({success: true}); }, 1000);
|    return deferred;
example:
    Deferred objects are often used when making code asynchronous. It
    may be easiest to write functions in a synchronous manner and then
    split code using a deferred to trigger a response to a long-lived
    operation. For example, instead of register a callback function to
    denote when a rendering operation completes, the function can
    simply return a deferred:</p>
<pre><code>|    <span class="hljs-comment">// callback style:</span>
|    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderLotsOfData</span><span class="hljs-params">(data, callback)</span>{</span>
|        <span class="hljs-keyword">var</span> success = <span class="hljs-literal">false</span>
|        <span class="hljs-keyword">try</span>{
|            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x <span class="hljs-keyword">in</span> data){
|                renderDataitem(data[x]);
|            }
|            success = <span class="hljs-literal">true</span>;
|        }<span class="hljs-keyword">catch</span>(e){ }
|        <span class="hljs-keyword">if</span>(callback){
|            callback(success);
|        }
|    }

|    <span class="hljs-comment">// using callback style</span>
|    renderLotsOfData(someDataObj, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(success)</span>{</span>
|        <span class="hljs-comment">// handles success or failure</span>
|        <span class="hljs-keyword">if</span>(!success){
|            promptUserToRecover();
|        }
|    });
|    <span class="hljs-comment">// NOTE: no way to add another callback here!!</span>
</code></pre><p>example:
    Using a Deferred doesn’t simplify the sending code any, but it
    provides a standard interface for callers and senders alike,
    providing both with a simple way to service multiple callbacks for
    an operation and freeing both sides from worrying about details
    such as “did this get called already?”. With Deferreds, new
    callbacks can be added at any time.</p>
<pre><code>|    <span class="hljs-comment">// Deferred style:</span>
|    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderLotsOfData</span><span class="hljs-params">(data)</span>{</span>
|        <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> Deferred();
|        <span class="hljs-keyword">try</span>{
|            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x <span class="hljs-keyword">in</span> data){
|                renderDataitem(data[x]);
|            }
|            d.callback(<span class="hljs-literal">true</span>);
|        }<span class="hljs-keyword">catch</span>(e){
|            d.errback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"rendering failed"</span>));
|        }
|        <span class="hljs-keyword">return</span> d;
|    }

|    <span class="hljs-comment">// using Deferred style</span>
|    renderLotsOfData(someDataObj).then(<span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
|        promptUserToRecover();
|    });
|    <span class="hljs-comment">// NOTE: addErrback and addCallback both return the Deferred</span>
|    <span class="hljs-comment">// again, so we could chain adding callbacks or save the</span>
|    <span class="hljs-comment">// deferred for later should we need to be notified again.</span>
</code></pre><p>example:
    In this example, renderLotsOfData is synchronous and so both
    versions are pretty artificial. Putting the data display on a
    timeout helps show why Deferreds rock:</p>
<pre><code>|    // Deferred style and async func
|    function renderLotsOfData(data){
|        var d = new Deferred();
|        setTimeout(function(){
|            try{
|                for(var x in data){
|                    renderDataitem(data[x]);
|                }
|                d.callback(true);
|            }catch(e){
|                d.errback(new Error(&quot;rendering failed&quot;));
|            }
|        }, 100);
|        return d;
|    }

|    // using Deferred style
|    renderLotsOfData(someDataObj).then(null, function(){
|        promptUserToRecover();
|    });

Note that the caller doesn&#39;t have to change his code at all to
handle the asynchronous case.
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> result, finished, isError, head, nextListener;
					<span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">this</span>.promise = <span class="hljs-keyword">new</span> Promise();

					<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">complete</span><span class="hljs-params">(value)</span> {</span>
						<span class="hljs-keyword">if</span> (finished) {
							<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'This deferred has already been resolved'</span>);
						}
						result = value;
						finished = <span class="hljs-literal">true</span>;
						notify();
					}

					<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">var</span> mutated;
						<span class="hljs-keyword">while</span> (!mutated &amp;&amp; nextListener) {
							<span class="hljs-keyword">var</span> listener = nextListener;
							nextListener = nextListener.next;
							<span class="hljs-keyword">if</span> (mutated = listener.progress === mutator) {</pre></div></div>
            
        </li>
        
        
        <li id="section-237">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-237">&#182;</a>
              </div>
              <p>assignment and check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								finished = <span class="hljs-literal">false</span>;
							}
							<span class="hljs-keyword">var</span> func = isError ? listener.error : listener.resolved;
							<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'config-useDeferredInstrumentation'</span>)) {
								<span class="hljs-keyword">if</span> (isError &amp;&amp; NewDeferred.instrumentRejected) {
									NewDeferred.instrumentRejected(result, !! func);
								}
							}
							<span class="hljs-keyword">if</span> (func) {
								<span class="hljs-keyword">try</span> {
									<span class="hljs-keyword">var</span> newResult = func(result);
									<span class="hljs-keyword">if</span> (newResult &amp;&amp; <span class="hljs-keyword">typeof</span> newResult.then === <span class="hljs-string">'function'</span>) {
										newResult.then(lang.hitch(listener.deferred, <span class="hljs-string">'resolve'</span>), lang.hitch(listener.deferred, <span class="hljs-string">'reject'</span>), lang.hitch(listener.deferred, <span class="hljs-string">'progress'</span>));
										<span class="hljs-keyword">continue</span>;
									}
									<span class="hljs-keyword">var</span> unchanged = mutated &amp;&amp; newResult === <span class="hljs-literal">undefined</span>;
									<span class="hljs-keyword">if</span> (mutated &amp;&amp; !unchanged) {
										isError = newResult <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>;
									}
									listener.deferred[unchanged &amp;&amp; isError ? <span class="hljs-string">'reject'</span> : <span class="hljs-string">'resolve'</span>](unchanged ? result : newResult);
								} <span class="hljs-keyword">catch</span> (e) {
									listener.deferred.reject(e);
								}
							} <span class="hljs-keyword">else</span> {
								<span class="hljs-keyword">if</span> (isError) {
									listener.deferred.reject(result);
								} <span class="hljs-keyword">else</span> {
									listener.deferred.resolve(result);
								}
							}
						}
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-238">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-238">&#182;</a>
              </div>
              <p>calling resolve will resolve the promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">this</span>.resolve = <span class="hljs-keyword">this</span>.callback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-239">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-239">&#182;</a>
              </div>
              <p>summary:
    Fulfills the Deferred instance successfully with the provide value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">this</span>.fired = <span class="hljs-number">0</span>;
						<span class="hljs-keyword">this</span>.results = [
							value,
							<span class="hljs-literal">null</span>
						];
						complete(value);
					};</pre></div></div>
            
        </li>
        
        
        <li id="section-240">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-240">&#182;</a>
              </div>
              <p>calling error will indicate that the promise failed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">this</span>.reject = <span class="hljs-keyword">this</span>.errback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-241">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-241">&#182;</a>
              </div>
              <p>summary:
    Fulfills the Deferred instance as an error with the provided error</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						isError = <span class="hljs-literal">true</span>;
						<span class="hljs-keyword">this</span>.fired = <span class="hljs-number">1</span>;
						<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'config-useDeferredInstrumentation'</span>)) {
							<span class="hljs-keyword">if</span> (NewDeferred.instrumentRejected) {
								NewDeferred.instrumentRejected(error, !! nextListener);
							}
						}
						complete(error);
						<span class="hljs-keyword">this</span>.results = [
							<span class="hljs-literal">null</span>,
							error
						];
					};</pre></div></div>
            
        </li>
        
        
        <li id="section-242">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-242">&#182;</a>
              </div>
              <p>call progress to provide updates on the progress on the completion of the promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">this</span>.progress = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(update)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-243">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-243">&#182;</a>
              </div>
              <p>summary:
    Send progress events to all listeners</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> listener = nextListener;
						<span class="hljs-keyword">while</span> (listener) {
							<span class="hljs-keyword">var</span> progress = listener.progress;
							progress &amp;&amp; progress(update);
							listener = listener.next;
						}
					};
					<span class="hljs-keyword">this</span>.addCallbacks = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback, errback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-244">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-244">&#182;</a>
              </div>
              <p>summary:
    Adds callback and error callback for this deferred instance.
callback: Function?
    The callback attached to this deferred object.
errback: Function?
    The error callback attached to this deferred object.
returns:
    Returns this deferred object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">this</span>.then(callback, errback, mutator);
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// Deferred</span>
					};</pre></div></div>
            
        </li>
        
        
        <li id="section-245">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-245">&#182;</a>
              </div>
              <p>provide the implementation of the promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					promise.then = <span class="hljs-keyword">this</span>.then = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(resolvedCallback, errorCallback, progressCallback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-246">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-246">&#182;</a>
              </div>
              <p>summary:
    Adds a fulfilledHandler, errorHandler, and progressHandler to be called for
    completion of a promise. The fulfilledHandler is called when the promise
    is fulfilled. The errorHandler is called when a promise fails. The
    progressHandler is called for progress events. All arguments are optional
    and non-function values are ignored. The progressHandler is not only an
    optional argument, but progress events are purely optional. Promise
    providers are not required to ever create progress events.</p>
<pre><code>This <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">will</span> <span class="hljs-title">return</span> <span class="hljs-title">a</span> <span class="hljs-title">new</span> <span class="hljs-title">promise</span> <span class="hljs-title">that</span> <span class="hljs-title">is</span> <span class="hljs-title">fulfilled</span> <span class="hljs-title">when</span> <span class="hljs-title">the</span> <span class="hljs-title">given</span>
<span class="hljs-title">fulfilledHandler</span> <span class="hljs-title">or</span> <span class="hljs-title">errorHandler</span> <span class="hljs-title">callback</span> <span class="hljs-title">is</span> <span class="hljs-title">finished</span>. <span class="hljs-title">This</span> <span class="hljs-title">allows</span> <span class="hljs-title">promise</span>
<span class="hljs-title">operations</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">chained</span> <span class="hljs-title">together</span>. <span class="hljs-title">The</span> <span class="hljs-title">value</span> <span class="hljs-title">returned</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">callback</span>
<span class="hljs-title">handler</span> <span class="hljs-title">is</span> <span class="hljs-title">the</span> <span class="hljs-title">fulfillment</span> <span class="hljs-title">value</span> <span class="hljs-title">for</span> <span class="hljs-title">the</span> <span class="hljs-title">returned</span> <span class="hljs-title">promise</span>. <span class="hljs-title">If</span> <span class="hljs-title">the</span> <span class="hljs-title">callback</span>
<span class="hljs-title">throws</span> <span class="hljs-title">an</span> <span class="hljs-title">error</span>, <span class="hljs-title">the</span> <span class="hljs-title">returned</span> <span class="hljs-title">promise</span> <span class="hljs-title">will</span> <span class="hljs-title">be</span> <span class="hljs-title">moved</span> <span class="hljs-title">to</span> <span class="hljs-title">failed</span> <span class="hljs-title">state</span>.</span>
</code></pre><p>returns:
    Returns a new promise that represents the result of the
    execution of the callback. The callbacks will never affect the original promises value.
example:
    An example of using a CommonJS compliant promise:
    |    asyncComputeTheAnswerToEverything().
    |        then(addTwo).
    |        then(printResult, onError);
    |    &gt;44</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> returnDeferred = progressCallback === mutator ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> Deferred(promise.cancel);
						<span class="hljs-keyword">var</span> listener = {
							resolved: resolvedCallback,
							error: errorCallback,
							progress: progressCallback,
							deferred: returnDeferred
						};
						<span class="hljs-keyword">if</span> (nextListener) {
							head = head.next = listener;
						} <span class="hljs-keyword">else</span> {
							nextListener = head = listener;
						}
						<span class="hljs-keyword">if</span> (finished) {
							notify();
						}
						<span class="hljs-keyword">return</span> returnDeferred.promise; <span class="hljs-comment">// Promise</span>
					};
					<span class="hljs-keyword">var</span> deferred = <span class="hljs-keyword">this</span>;
					promise.cancel = <span class="hljs-keyword">this</span>.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-247">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-247">&#182;</a>
              </div>
              <p>summary:
    Cancels the asynchronous operation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!finished) {
							<span class="hljs-keyword">var</span> error = canceller &amp;&amp; canceller(deferred);
							<span class="hljs-keyword">if</span> (!finished) {
								<span class="hljs-keyword">if</span> (!(error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>)) {
									error = <span class="hljs-keyword">new</span> CancelError(error);
								}
								error.log = <span class="hljs-literal">false</span>;
								deferred.reject(error);
							}
						}
					};
					freeze(promise);
				};
				lang.extend(Deferred, {
					addCallback: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-248">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-248">&#182;</a>
              </div>
              <p>summary:
    Adds successful callback for this deferred instance.
returns:
    Returns this deferred object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addCallbacks(lang.hitch.apply(dojo, <span class="hljs-built_in">arguments</span>)); <span class="hljs-comment">// Deferred</span>
					},
					addErrback: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(errback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-249">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-249">&#182;</a>
              </div>
              <p>summary:
    Adds error callback for this deferred instance.
returns:
    Returns this deferred object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addCallbacks(<span class="hljs-literal">null</span>, lang.hitch.apply(dojo, <span class="hljs-built_in">arguments</span>)); <span class="hljs-comment">// Deferred</span>
					},
					addBoth: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-250">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-250">&#182;</a>
              </div>
              <p>summary:
    Add handler as both successful callback and error callback for this deferred instance.
returns:
    Returns this deferred object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> enclosed = lang.hitch.apply(dojo, <span class="hljs-built_in">arguments</span>);
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addCallbacks(enclosed, enclosed); <span class="hljs-comment">// Deferred</span>
					},
					fired: -<span class="hljs-number">1</span>
				});
				Deferred.when = dojo.when = when;
				<span class="hljs-keyword">return</span> Deferred;
			});
		},
		<span class="hljs-string">'dojo/NodeList-dom'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./_base/kernel'</span>,
				<span class="hljs-string">'./query'</span>,
				<span class="hljs-string">'./_base/array'</span>,
				<span class="hljs-string">'./_base/lang'</span>,
				<span class="hljs-string">'./dom-class'</span>,
				<span class="hljs-string">'./dom-construct'</span>,
				<span class="hljs-string">'./dom-geometry'</span>,
				<span class="hljs-string">'./dom-attr'</span>,
				<span class="hljs-string">'./dom-style'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, query, array, lang, domCls, domCtr, domGeom, domAttr, domStyle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-251">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-251">&#182;</a>
              </div>
              <p>module:
    dojo/NodeList-dom.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             return function(){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-252">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-252">&#182;</a>
              </div>
              <p>summary:
    Adds DOM related methods to NodeList, and returns NodeList constructor.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				var magicGuard = function (a) {</pre></div></div>
            
        </li>
        
        
        <li id="section-253">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-253">&#182;</a>
              </div>
              <p>summary:
    the guard function for dojo.attr() and dojo.style()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> a.length === <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">typeof</span> a[<span class="hljs-number">0</span>] === <span class="hljs-string">'string'</span>; <span class="hljs-comment">// inline'd type check</span>
				};
				<span class="hljs-keyword">var</span> orphan = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-254">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-254">&#182;</a>
              </div>
              <p>summary:
    function to orphan nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> p = node.parentNode;
					<span class="hljs-keyword">if</span> (p) {
						p.removeChild(node);
					}
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-255">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-255">&#182;</a>
              </div>
              <p>FIXME: should we move orphan() to dojo.html?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> NodeList = query.NodeList,
					awc = NodeList._adaptWithCondition,
					aafe = NodeList._adaptAsForEach,
					aam = NodeList._adaptAsMap;

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSet</span><span class="hljs-params">(module)</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, name, value)</span> {</span>
						<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) {
							<span class="hljs-keyword">return</span> module[<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">'string'</span> ? <span class="hljs-string">'get'</span> : <span class="hljs-string">'set'</span>](node, name);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-256">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-256">&#182;</a>
              </div>
              <p>setter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> module.set(node, name, value);
					};
				}
				lang.extend(NodeList, {
					_normalize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(content, refNode)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-257">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-257">&#182;</a>
              </div>
              <p>summary:
    normalizes data to an array of items to insert.
description:
    If content is an object, it can have special properties “template” and
    “parse”. If “template” is defined, then the template value is run through
    dojo.string.substitute (if dojo/string.substitute() has been dojo.required elsewhere),
    or if templateFunc is a function on the content, that function will be used to
    transform the template into a final string to be used for for passing to dojo/dom-construct.toDom().
    If content.parse is true, then it is remembered for later, for when the content
    nodes are inserted into the DOM. At that point, the nodes will be parsed for widgets
    (if dojo.parser has been dojo.required elsewhere).
Wanted to just use a DocumentFragment, but for the array/NodeList
case that meant using cloneNode, but we may not want that.
Cloning should only happen if the node operations span
multiple refNodes. Also, need a real array, not a NodeList from the
DOM since the node movements could change those NodeLists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> parse = content.parse === <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-258">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-258">&#182;</a>
              </div>
              <p>Do we have an object that needs to be run through a template?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> content.template === <span class="hljs-string">'string'</span>) {
							<span class="hljs-keyword">var</span> templateFunc = content.templateFunc || dojo.string &amp;&amp; dojo.string.substitute;
							content = templateFunc ? templateFunc(content.template, content) : content;
						}
						<span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span> content;
						<span class="hljs-keyword">if</span> (type === <span class="hljs-string">'string'</span> || type === <span class="hljs-string">'number'</span>) {
							content = domCtr.toDom(content, refNode &amp;&amp; refNode.ownerDocument);
							<span class="hljs-keyword">if</span> (content.nodeType === <span class="hljs-number">11</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-259">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-259">&#182;</a>
              </div>
              <p>DocumentFragment. It cannot handle cloneNode calls, so pull out the children.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								content = lang._toArray(content.childNodes);
							} <span class="hljs-keyword">else</span> {
								content = [content];
							}
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!lang.isArrayLike(content)) {
							content = [content];
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!lang.isArray(content)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-260">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-260">&#182;</a>
              </div>
              <p>To get to this point, content is array-like, but
not an array, which likely means a DOM NodeList. Convert it now.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							content = lang._toArray(content);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-261">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-261">&#182;</a>
              </div>
              <p>Pass around the parse info</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (parse) {
							content._runParse = <span class="hljs-literal">true</span>;
						}
						<span class="hljs-keyword">return</span> content; <span class="hljs-comment">//Array</span>
					},
					_cloneNode: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-262">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-262">&#182;</a>
              </div>
              <p>summary:
    private utility to clone a node. Not very interesting in the vanilla
    dojo/NodeList case, but delegates could do interesting things like
    clone event handlers if that is derivable from the node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> node.cloneNode(<span class="hljs-literal">true</span>);
					},
					_place: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(ary, refNode, position, useClone)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-263">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-263">&#182;</a>
              </div>
              <p>summary:
    private utility to handle placing an array of nodes relative to another node.
description:
    Allows for cloning the nodes in the array, and for
    optionally parsing widgets, if ary._runParse is true.
Avoid a disallowed operation if trying to do an innerHTML on a non-element node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (refNode.nodeType !== <span class="hljs-number">1</span> &amp;&amp; position === <span class="hljs-string">'only'</span>) {
							<span class="hljs-keyword">return</span>;
						}
						<span class="hljs-keyword">var</span> rNode = refNode,
							tempNode;</pre></div></div>
            
        </li>
        
        
        <li id="section-264">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-264">&#182;</a>
              </div>
              <p>Always cycle backwards in case the array is really a
DOM NodeList and the DOM operations take it out of the live collection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> length = ary.length;
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
							<span class="hljs-keyword">var</span> node = useClone ? <span class="hljs-keyword">this</span>._cloneNode(ary[i]) : ary[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-265">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-265">&#182;</a>
              </div>
              <p>If need widget parsing, use a temp node, instead of waiting after inserting into
real DOM because we need to start widget parsing at one node up from current node,
which could cause some already parsed widgets to be parsed again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (ary._runParse &amp;&amp; dojo.parser &amp;&amp; dojo.parser.parse) {
								<span class="hljs-keyword">if</span> (!tempNode) {
									tempNode = rNode.ownerDocument.createElement(<span class="hljs-string">'div'</span>);
								}
								tempNode.appendChild(node);
								dojo.parser.parse(tempNode);
								node = tempNode.firstChild;
								<span class="hljs-keyword">while</span> (tempNode.firstChild) {
									tempNode.removeChild(tempNode.firstChild);
								}
							}
							<span class="hljs-keyword">if</span> (i === length - <span class="hljs-number">1</span>) {
								domCtr.place(node, rNode, position);
							} <span class="hljs-keyword">else</span> {
								rNode.parentNode.insertBefore(node, rNode);
							}
							rNode = node;
						}
					},
					position: aam(domGeom.position),
					attr: awc(getSet(domAttr), magicGuard),
					style: awc(getSet(domStyle), magicGuard),
					addClass: aafe(domCls.add),
					removeClass: aafe(domCls.remove),
					toggleClass: aafe(domCls.toggle),
					replaceClass: aafe(domCls.replace),
					empty: aafe(domCtr.empty),
					removeAttr: aafe(domAttr.remove),
					marginBox: aam(domGeom.getMarginBox),
					place: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(queryOrNode, position)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-266">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-266">&#182;</a>
              </div>
              <p>summary:
    places elements of this node list relative to the first element matched
    by queryOrNode. Returns the original NodeList. See: <code>dojo.place</code>
queryOrNode:
    may be a string representing any valid CSS3 selector or a DOM node.
    In the selector case, only the first matching element will be used
    for relative positioning.
position:
    can be one of:</p>
<pre><code>-    <span class="hljs-string">"last"</span> (<span class="hljs-keyword">default</span>)
-    <span class="hljs-string">"first"</span>
-    <span class="hljs-string">"before"</span>
-    <span class="hljs-string">"after"</span>
-    <span class="hljs-string">"only"</span>
-    <span class="hljs-string">"replace"</span>

or an offset <span class="hljs-keyword">in</span> the childNodes property
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> item = query(queryOrNode)[<span class="hljs-number">0</span>];
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
							domCtr.place(node, item, position);
						}); <span class="hljs-comment">// dojo/NodeList</span>
					},
					orphan: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(filter)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-267">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-267">&#182;</a>
              </div>
              <p>summary:
    removes elements in this list that match the filter
    from their parents and returns them as a new NodeList.
filter:
    CSS selector like “.foo” or “div &gt; span”
returns:
    NodeList containing the orphaned elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> (filter ? query._filterResult(<span class="hljs-keyword">this</span>, filter) : <span class="hljs-keyword">this</span>)
							.forEach(orphan); <span class="hljs-comment">// dojo/NodeList</span>
					},
					adopt: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(queryOrListOrNode, position)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-268">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-268">&#182;</a>
              </div>
              <p>summary:
    places any/all elements in queryOrListOrNode at a
    position relative to the first element in this list.
    Returns a dojo/NodeList of the adopted elements.
queryOrListOrNode:
    a DOM node or a query string or a query result.
    Represents the nodes to be adopted relative to the
    first element of this NodeList.
position:
    can be one of:</p>
<pre><code>-    <span class="hljs-string">"last"</span> (<span class="hljs-keyword">default</span>)
-    <span class="hljs-string">"first"</span>
-    <span class="hljs-string">"before"</span>
-    <span class="hljs-string">"after"</span>
-    <span class="hljs-string">"only"</span>
-    <span class="hljs-string">"replace"</span>

or an offset <span class="hljs-keyword">in</span> the childNodes property
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> query(queryOrListOrNode)
							.place(<span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>], position)
							._stash(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// dojo/NodeList</span>
					},
					query: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(queryStr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-269">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-269">&#182;</a>
              </div>
              <p>summary:
    Returns a new list whose members match the passed query,
    assuming elements of the current NodeList as the root for
    each search.
example:
    assume a DOM created by this markup:
|    <div id="foo">
|        <p>
|            bacon is tasty, <span>dontcha think?</span>
|        </p>
|    </div>
|    <div id="bar">
|        <p>great comedians may not be funny <span>in person</span></p>
|    </div>
    If we are presented with the following definition for a NodeList:
|    var l = new NodeList(dojo.byId(“foo”), dojo.byId(“bar”));
    it’s possible to find all span elements under paragraphs
    contained by these elements with this sub-query:
|    var spans = l.query(“p span”);
FIXME: probably slow</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!queryStr) {
							<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
						}
						<span class="hljs-keyword">var</span> ret = <span class="hljs-keyword">new</span> NodeList();
						<span class="hljs-keyword">this</span>.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-270">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-270">&#182;</a>
              </div>
              <p>FIXME: why would we ever get undefined here?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							query(queryStr, node)
								.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(subNode)</span> {</span>
									<span class="hljs-keyword">if</span> (subNode !== <span class="hljs-literal">undefined</span>) {
										ret.push(subNode);
									}
								});
						});
						<span class="hljs-keyword">return</span> ret._stash(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// dojo/NodeList</span>
					},
					filter: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(filter)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-271">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-271">&#182;</a>
              </div>
              <p>summary:
    “masks” the built-in javascript filter() method (supported
    in Dojo via <code>dojo.filter</code>) to support passing a simple
    string filter in addition to supporting filtering function
    objects.
filter:
    If a string, a CSS rule like “.thinger” or “div &gt; span”.
example:
    “regular” JS filter syntax as exposed in dojo.filter:
    |    dojo.query(“<em>“).filter(function(item){
    |        // highlight every paragraph
    |        return (item.nodeName == “p”);
    |    }).style(“backgroundColor”, “yellow”);
example:
    the same filtering using a CSS selector
    |    dojo.query(“</em>“).filter(“p”).styles(“backgroundColor”, “yellow”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">arguments</span>,
							items = <span class="hljs-keyword">this</span>,
							start = <span class="hljs-number">0</span>;
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> filter === <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-272">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-272">&#182;</a>
              </div>
              <p>inline’d type check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							items = query._filterResult(<span class="hljs-keyword">this</span>, a[<span class="hljs-number">0</span>]);
							<span class="hljs-keyword">if</span> (a.length === <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-273">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-273">&#182;</a>
              </div>
              <p>if we only got a string query, pass back the filtered results</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">return</span> items._stash(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// dojo/NodeList</span>
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-274">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-274">&#182;</a>
              </div>
              <p>if we got a callback, run it over the filtered items</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							start = <span class="hljs-number">1</span>;
						}
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._wrap(array.filter(items, a[start], a[start + <span class="hljs-number">1</span>]), <span class="hljs-keyword">this</span>); <span class="hljs-comment">// dojo/NodeList</span>
					},
					addContent: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(content, position)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-275">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-275">&#182;</a>
              </div>
              <p>summary:
    add a node, NodeList or some HTML as a string to every item in the
    list.  Returns the original list.
description:
    a copy of the HTML content is added to each item in the
    list, with an optional position argument. If no position
    argument is provided, the content is appended to the end of
    each item.
content:
    DOM node, HTML in string format, a NodeList or an Object. If a DOM node or
    NodeList, the content will be cloned if the current NodeList has more than one
    element. Only the DOM nodes are cloned, no event handlers. If it is an Object,
    it should be an object with at “template” String property that has the HTML string
    to insert. If dojo.string has already been dojo.required, then dojo.string.substitute
    will be used on the “template” to generate the final HTML string. Other allowed
    properties on the object are: “parse” if the HTML
    string should be parsed for widgets (dojo.require(“dojo.parser”) to get that
    option to work), and “templateFunc” if a template function besides dojo.string.substitute
    should be used to transform the “template”.
position:
    can be one of:</p>
<pre><code>-    &quot;last&quot;||&quot;end&quot; (default)
-    &quot;first||&quot;start&quot;
-    &quot;before&quot;
-    &quot;after&quot;
-    &quot;replace&quot; (replaces nodes in this NodeList with new content)
-    &quot;only&quot; (removes other children of the nodes so new content is the only child)

or an offset in the childNodes property
</code></pre><p>example:
    appends content to the end if the position is omitted
|    dojo.query(“h3 &gt; p”).addContent(“hey there!”);
example:
    add something to the front of each element that has a
    “thinger” property:
|    dojo.query(“[thinger]”).addContent(“…”, “first”);
example:
    adds a header before each element of the list
|    dojo.query(“.note”).addContent(“<h4>NOTE:</h4>“, “before”);
example:
    add a clone of a DOM node to the end of every element in
    the list, removing it from its existing parent.
|    dojo.query(“.note”).addContent(dojo.byId(“foo”));
example:
    Append nodes from a templatized string.
|    dojo.require(“dojo.string”);
|    dojo.query(“.note”).addContent({
|        template: ‘<b>${id}: </b><span>${name}</span>‘,
|        id: “user332”,
|        name: “Mr. Anderson”
|    });
example:
    Append nodes from a templatized string that also has widgets parsed.
|    dojo.require(“dojo.string”);
|    dojo.require(“dojo.parser”);
|    var notes = dojo.query(“.note”).addContent({
|        template: ‘<button dojoType="dijit/form/Button">${text}</button>‘,
|        parse: true,
|        text: “Send”
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						content = <span class="hljs-keyword">this</span>._normalize(content, <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>]);
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, node; node = <span class="hljs-keyword">this</span>[i]; i++) {
							<span class="hljs-keyword">this</span>._place(content, node, position, i &gt; <span class="hljs-number">0</span>);
						}
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// dojo/NodeList</span>
					}
				});
				<span class="hljs-keyword">return</span> NodeList;
			});
		},
		<span class="hljs-string">'dojo/query'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./_base/kernel'</span>,
				<span class="hljs-string">'./has'</span>,
				<span class="hljs-string">'./dom'</span>,
				<span class="hljs-string">'./on'</span>,
				<span class="hljs-string">'./_base/array'</span>,
				<span class="hljs-string">'./_base/lang'</span>,
				<span class="hljs-string">'./selector/_loader'</span>,
				<span class="hljs-string">'./selector/_loader!default'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, has, dom, on, array, lang, loader, defaultEngine)</span> {</span>
<span class="hljs-pi">				'use strict'</span>;
				has.add(<span class="hljs-string">'array-extensible'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-276">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-276">&#182;</a>
              </div>
              <p>test to see if we can extend an array (not supported in old IE)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> lang.delegate([], {
						length: <span class="hljs-number">1</span>
					})
						.length === <span class="hljs-number">1</span> &amp;&amp; !has(<span class="hljs-string">'bug-for-in-skips-shadowed'</span>);
				});
				<span class="hljs-keyword">var</span> ap = <span class="hljs-built_in">Array</span>.prototype,
					aps = ap.slice,
					apc = ap.concat,
					forEach = array.forEach;
				<span class="hljs-keyword">var</span> tnl = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, parent, NodeListCtor)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-277">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-277">&#182;</a>
              </div>
              <p>summary:
    decorate an array to make it look like a <code>dojo/NodeList</code>.
a:
    Array of nodes to decorate.
parent:
    An optional parent NodeList that generated the current
    list of nodes. Used to call _stash() so the parent NodeList
    can be accessed via end() later.
NodeListCtor:
    An optional constructor function to use for any
    new NodeList calls. This allows a certain chain of
    NodeList calls to use a different object than dojo/NodeList.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> nodeList = <span class="hljs-keyword">new</span>(NodeListCtor || <span class="hljs-keyword">this</span>._NodeListCtor || nl)(a);
					<span class="hljs-keyword">return</span> parent ? nodeList._stash(parent) : nodeList;
				};
				<span class="hljs-keyword">var</span> loopBody = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(f, a, o)</span> {</span>
					a = [<span class="hljs-number">0</span>].concat(aps.call(a, <span class="hljs-number">0</span>));
					o = o || dojo.global;
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
						a[<span class="hljs-number">0</span>] = node;
						<span class="hljs-keyword">return</span> f.apply(o, a);
					};
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-278">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-278">&#182;</a>
              </div>
              <p>adapters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> adaptAsForEach = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(f, o)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-279">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-279">&#182;</a>
              </div>
              <p>summary:
    adapts a single node function to be used in the forEach-type
    actions. The initial object is returned from the specialized
    function.
f: Function
    a function to adapt
o: Object?
    an optional context for f</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">this</span>.forEach(loopBody(f, <span class="hljs-built_in">arguments</span>, o));
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// Object</span>
					};
				};
				<span class="hljs-keyword">var</span> adaptAsMap = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(f, o)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-280">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-280">&#182;</a>
              </div>
              <p>summary:
    adapts a single node function to be used in the map-type
    actions. The return is a new array of values, as via <code>dojo.map</code>
f: Function
    a function to adapt
o: Object?
    an optional context for f</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.map(loopBody(f, <span class="hljs-built_in">arguments</span>, o));
					};
				};
				<span class="hljs-keyword">var</span> adaptAsFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(f, o)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-281">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-281">&#182;</a>
              </div>
              <p>summary:
    adapts a single node function to be used in the filter-type actions
f: Function
    a function to adapt
o: Object?
    an optional context for f</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.filter(loopBody(f, <span class="hljs-built_in">arguments</span>, o));
					};
				};
				<span class="hljs-keyword">var</span> adaptWithCondition = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(f, g, o)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-282">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-282">&#182;</a>
              </div>
              <p>summary:
    adapts a single node function to be used in the map-type
    actions, behaves like forEach() or map() depending on arguments
f: Function
    a function to adapt
g: Function
    a condition function, if true runs as map(), otherwise runs as forEach()
o: Object?
    an optional context for f and g</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">arguments</span>,
							body = loopBody(f, a, o);
						<span class="hljs-keyword">if</span> (g.call(o || dojo.global, a)) {
							<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.map(body); <span class="hljs-comment">// self</span>
						}
						<span class="hljs-keyword">this</span>.forEach(body);
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// self</span>
					};
				};
				<span class="hljs-keyword">var</span> NodeList = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(array)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-283">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-283">&#182;</a>
              </div>
              <p>summary:
    Array-like object which adds syntactic
    sugar for chaining, common iteration operations, animation, and
    node manipulation. NodeLists are most often returned as the
    result of dojo.query() calls.
description:
    NodeList instances provide many utilities that reflect
    core Dojo APIs for Array iteration and manipulation, DOM
    manipulation, and event handling. Instead of needing to dig up
    functions in the dojo.<em> namespace, NodeLists generally make the
    full power of Dojo available for DOM manipulation tasks in a
    simple, chainable way.
example:
    create a node list from a node
    |    new query.NodeList(dojo.byId(“foo”));
example:
    get a NodeList from a CSS query and iterate on it
    |    var l = dojo.query(“.thinger”);
    |    l.forEach(function(node, index, nodeList){
    |        console.log(index, node.innerHTML);
    |    });
example:
    use native and Dojo-provided array methods to manipulate a
    NodeList without needing to use dojo.</em> functions explicitly:
    |    var l = dojo.query(“.thinger”);
    |    // since NodeLists are real arrays, they have a length
    |    // property that is both readable and writable and
    |    // push/pop/shift/unshift methods
    |    console.log(l.length);
    |    l.push(dojo.create(“span”));
    |
    |    // dojo’s normalized array methods work too:
    |    console.log( l.indexOf(dojo.byId(“foo”)) );
    |    // …including the special “function as string” shorthand
    |    console.log( l.every(“item.nodeType == 1”) );
    |
    |    // NodeLists can be [..] indexed, or you can use the at()
    |    // function to get specific items wrapped in a new NodeList:
    |    var node = l[3]; // the 4th element
    |    var newList = l.at(1, 3); // the 2nd and 4th elements
example:
    the style functions you expect are all there too:
    |    // style() as a getter…
    |    var borders = dojo.query(“.thinger”).style(“border”);
    |    // …and as a setter:
    |    dojo.query(“.thinger”).style(“border”, “1px solid black”);
    |    // class manipulation
    |    dojo.query(“li:nth-child(even)”).addClass(“even”);
    |    // even getting the coordinates of all the items
    |    var coords = dojo.query(“.thinger”).coords();
example:
    DOM manipulation functions from the dojo.<em> namespace area also available:
    |    // remove all of the elements in the list from their
    |    // parents (akin to “deleting” them from the document)
    |    dojo.query(“.thinger”).orphan();
    |    // place all elements in the list at the front of #foo
    |    dojo.query(“.thinger”).place(“foo”, “first”);
example:
    Event handling couldn’t be easier. <code>dojo.connect</code> is mapped in,
    and shortcut handlers are provided for most DOM events:
    |    // like dojo.connect(), but with implicit scope
    |    dojo.query(“li”).connect(“onclick”, console, “log”);
    |
    |    // many common event handlers are already available directly:
    |    dojo.query(“li”).onclick(console, “log”);
    |    var toggleHovered = dojo.hitch(dojo, “toggleClass”, “hovered”);
    |    dojo.query(“p”)
    |        .onmouseenter(toggleHovered)
    |        .onmouseleave(toggleHovered);
example:
    chainability is a key advantage of NodeLists:
    |    dojo.query(“.thinger”)
    |        .onclick(function(e){ /</em> … */ })
    |        .at(1, 3, 8) // get a subset
    |            .style(“padding”, “5px”)
    |            .forEach(console.log);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> isNew = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> nl &amp;&amp; has(<span class="hljs-string">'array-extensible'</span>);
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> array === <span class="hljs-string">'number'</span>) {
						array = <span class="hljs-built_in">Array</span>(array);
					}
					<span class="hljs-keyword">var</span> nodeArray = array &amp;&amp; <span class="hljs-string">'length'</span> <span class="hljs-keyword">in</span> array ? array : <span class="hljs-built_in">arguments</span>;
					<span class="hljs-keyword">if</span> (isNew || !nodeArray.sort) {</pre></div></div>
            
        </li>
        
        
        <li id="section-284">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-284">&#182;</a>
              </div>
              <p>make sure it’s a real array before we pass it on to be wrapped </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> target = isNew ? <span class="hljs-keyword">this</span> : [],
							l = target.length = nodeArray.length;
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) {
							target[i] = nodeArray[i];
						}
						<span class="hljs-keyword">if</span> (isNew) {</pre></div></div>
            
        </li>
        
        
        <li id="section-285">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-285">&#182;</a>
              </div>
              <p>called with new operator, this means we are going to use this instance and push
the nodes on to it. This is usually much faster since the NodeList properties
don’t need to be copied (unless the list of nodes is extremely large).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> target;
						}
						nodeArray = target;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-286">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-286">&#182;</a>
              </div>
              <p>called without new operator, use a real array and copy prototype properties,
this is slower and exists for back-compat. Should be removed in 2.0.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					lang._mixin(nodeArray, nlp);
					nodeArray._NodeListCtor = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(array)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-287">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-287">&#182;</a>
              </div>
              <p>call without new operator to preserve back-compat behavior</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> nl(array);
					};
					<span class="hljs-keyword">return</span> nodeArray;
				};
				<span class="hljs-keyword">var</span> nl = NodeList,
					nlp = nl.prototype = has(<span class="hljs-string">'array-extensible'</span>) ? [] : {};</pre></div></div>
            
        </li>
        
        
        <li id="section-288">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-288">&#182;</a>
              </div>
              <p>extend an array if it is extensible
expose adapters and the wrapper as private functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				nl._wrap = nlp._wrap = tnl;
				nl._adaptAsMap = adaptAsMap;
				nl._adaptAsForEach = adaptAsForEach;
				nl._adaptAsFilter = adaptAsFilter;
				nl._adaptWithCondition = adaptWithCondition;</pre></div></div>
            
        </li>
        
        
        <li id="section-289">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-289">&#182;</a>
              </div>
              <p>mass assignment
add array redirectors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				forEach([
					<span class="hljs-string">'slice'</span>,
					<span class="hljs-string">'splice'</span>
				], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span>
					<span class="hljs-keyword">var</span> f = ap[name];</pre></div></div>
            
        </li>
        
        
        <li id="section-290">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-290">&#182;</a>
              </div>
              <p>Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.
CANNOT apply ._stash()/end() to splice since it currently modifies
the existing this array — it would break backward compatibility if we copy the array before
the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					nlp[name] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._wrap(f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>), name === <span class="hljs-string">'slice'</span> ? <span class="hljs-keyword">this</span> : <span class="hljs-literal">null</span>);
					};
				});</pre></div></div>
            
        </li>
        
        
        <li id="section-291">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-291">&#182;</a>
              </div>
              <p>concat should be here but some browsers with native NodeList have problems with it
add array.js redirectors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				forEach([
					<span class="hljs-string">'indexOf'</span>,
					<span class="hljs-string">'lastIndexOf'</span>,
					<span class="hljs-string">'every'</span>,
					<span class="hljs-string">'some'</span>
				], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span>
					<span class="hljs-keyword">var</span> f = array[name];
					nlp[name] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">return</span> f.apply(dojo, [<span class="hljs-keyword">this</span>].concat(aps.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>)));
					};
				});
				lang.extend(NodeList, {
					constructor: nl,
					_NodeListCtor: nl,
					toString: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-292">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-292">&#182;</a>
              </div>
              <p>Array.prototype.toString can’t be applied to objects, so we use join</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.join(<span class="hljs-string">','</span>);
					},
					_stash: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(parent)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-293">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-293">&#182;</a>
              </div>
              <p>summary:
    private function to hold to a parent NodeList. end() to return the parent NodeList.</p>
<p>example:
    How to make a <code>dojo/NodeList</code> method that only returns the third node in
    the dojo/NodeList but allows access to the original NodeList by using this._stash:
|    dojo.extend(NodeList, {
|        third: function(){
|            var newNodeList = NodeList(this[2]);
|            return newNodeList._stash(this);
|        }
|    });
|    // then see how _stash applies a sub-list, to be .end()’ed out of
|    dojo.query(“.foo”)
|        .third()
|            .addClass(“thirdFoo”)
|        .end()
|        // access to the orig .foo list
|        .removeClass(“foo”)
|</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">this</span>._parent = parent;
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// dojo/NodeList</span>
					},
					on: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(eventName, listener)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-294">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-294">&#182;</a>
              </div>
              <p>summary:
    Listen for events on the nodes in the NodeList. Basic usage is:
    | query(“.my-class”).on(“click”, listener);
    This supports event delegation by using selectors as the first argument with the event names as
    pseudo selectors. For example:
    | dojo.query(“#my-list”).on(“li:click”, listener);
    This will listen for click events within <code>&lt;li&gt;</code> elements that are inside the <code>#my-list</code> element.
    Because on supports CSS selector syntax, we can use comma-delimited events as well:
    | dojo.query(“#my-list”).on(“li button:mouseover, li:click”, listener);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> handles = <span class="hljs-keyword">this</span>.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
							<span class="hljs-keyword">return</span> on(node, eventName, listener); <span class="hljs-comment">// TODO: apply to the NodeList so the same selector engine is used for matches</span>
						});
						handles.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; handles.length; i++) {
								handles[i].remove();
							}
						};
						<span class="hljs-keyword">return</span> handles;
					},
					end: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-295">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-295">&#182;</a>
              </div>
              <p>summary:
    Ends use of the current <code>NodeList</code> by returning the previous NodeList
    that generated the current NodeList.
description:
    Returns the <code>NodeList</code> that generated the current <code>NodeList</code>. If there
    is no parent NodeList, an empty NodeList is returned.
example:
|    dojo.query(“a”)
|        .filter(“.disabled”)
|            // operate on the anchors that only have a disabled class
|            .style(“color”, “grey”)
|        .end()
|        // jump back to the list of anchors
|        .style(…)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._parent) {
							<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._parent;
						} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-296">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-296">&#182;</a>
              </div>
              <p>Just return empty list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>._NodeListCtor(<span class="hljs-number">0</span>);
						}
					},
					concat: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(item)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-297">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-297">&#182;</a>
              </div>
              <p>summary:
    Returns a new NodeList comprised of items in this NodeList
    as well as items passed in as parameters
description:
    This method behaves exactly like the Array.concat method
    with the caveat that it returns a <code>NodeList</code> and not a
    raw Array. For more details, see the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat">Array.concat
    docs</a>
item: Object?
    Any number of optional parameters may be passed in to be
    spliced into the NodeList
return this._wrap(apc.apply(this, arguments));
the line above won’t work for the native NodeList, or for Dojo NodeLists either :-(
implementation notes:
Array.concat() doesn’t recognize native NodeLists or Dojo NodeLists
as arrays, and so does not inline them into a unioned array, but
appends them as single entities. Both the original NodeList and the
items passed in as parameters must be converted to raw Arrays
and then the concatenation result may be re-_wrap()ed as a Dojo NodeList.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> t = aps.call(<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>),
							m = array.map(<span class="hljs-built_in">arguments</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a)</span> {</span>
								<span class="hljs-keyword">return</span> aps.call(a, <span class="hljs-number">0</span>);
							});
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._wrap(apc.apply(t, m), <span class="hljs-keyword">this</span>); <span class="hljs-comment">// dojo/NodeList</span>
					},
					map: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func, obj)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-298">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-298">&#182;</a>
              </div>
              <p>summary:
    see dojo.map(). The primary difference is that the acted-on
    array is implicitly this NodeList and the return is a
    NodeList (a subclass of Array)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._wrap(array.map(<span class="hljs-keyword">this</span>, func, obj), <span class="hljs-keyword">this</span>); <span class="hljs-comment">// dojo/NodeList</span>
					},
					forEach: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback, thisObj)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-299">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-299">&#182;</a>
              </div>
              <p>summary:
    see <code>dojo.forEach()</code>. The primary difference is that the acted-on
    array is implicitly this NodeList. If you want the option to break out
    of the forEach loop, use every() or some() instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						forEach(<span class="hljs-keyword">this</span>, callback, thisObj);</pre></div></div>
            
        </li>
        
        
        <li id="section-300">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-300">&#182;</a>
              </div>
              <p>non-standard return to allow easier chaining</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// dojo/NodeList</span>
					},
					filter: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(filter)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-301">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-301">&#182;</a>
              </div>
              <p>summary:
    “masks” the built-in javascript filter() method (supported
    in Dojo via <code>dojo.filter</code>) to support passing a simple
    string filter in addition to supporting filtering function
    objects.
filter:
    If a string, a CSS rule like “.thinger” or “div &gt; span”.
example:
    “regular” JS filter syntax as exposed in dojo.filter:
    |    dojo.query(“<em>“).filter(function(item){
    |        // highlight every paragraph
    |        return (item.nodeName == “p”);
    |    }).style(“backgroundColor”, “yellow”);
example:
    the same filtering using a CSS selector
    |    dojo.query(“</em>“).filter(“p”).styles(“backgroundColor”, “yellow”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">arguments</span>,
							items = <span class="hljs-keyword">this</span>,
							start = <span class="hljs-number">0</span>;
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> filter === <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-302">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-302">&#182;</a>
              </div>
              <p>inline’d type check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							items = query._filterResult(<span class="hljs-keyword">this</span>, a[<span class="hljs-number">0</span>]);
							<span class="hljs-keyword">if</span> (a.length === <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-303">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-303">&#182;</a>
              </div>
              <p>if we only got a string query, pass back the filtered results</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">return</span> items._stash(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// dojo/NodeList</span>
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-304">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-304">&#182;</a>
              </div>
              <p>if we got a callback, run it over the filtered items</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							start = <span class="hljs-number">1</span>;
						}
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._wrap(array.filter(items, a[start], a[start + <span class="hljs-number">1</span>]), <span class="hljs-keyword">this</span>); <span class="hljs-comment">// dojo/NodeList</span>
					},
					instantiate: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(declaredClass, properties)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-305">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-305">&#182;</a>
              </div>
              <p>summary:
    Create a new instance of a specified class, using the
    specified properties and each node in the NodeList as a
    srcNodeRef.
example:
    Grabs all buttons in the page and converts them to dijit/form/Button’s.
|    var buttons = query(“button”).instantiate(Button, {showLabel: true});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);
						properties = properties || {};
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
							<span class="hljs-keyword">new</span> c(properties, node);
						}); <span class="hljs-comment">// dojo/NodeList</span>
					},
					at: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-306">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-306">&#182;</a>
              </div>
              <p>summary:
    Returns a new NodeList comprised of items in this NodeList
    at the given index or indices.</p>
<p>index: Integer…
    One or more 0-based indices of items in the current
    NodeList. A negative index will start at the end of the
    list and go backwards.</p>
<p>example:
Shorten the list to the first, second, and third elements
|    query(“a”).at(0, 1, 2).forEach(fn);</p>
<p>example:
Retrieve the first and last elements of a unordered list:
|    query(“ul &gt; li”).at(0, -1).forEach(cb);</p>
<p>example:
Do something for the first element only, but end() out back to
the original list and continue chaining:
|    query(“a”).at(0).onclick(fn).end().forEach(function(n){
|        console.log(n); // all anchors on the page.
|    })</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> t = <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>._NodeListCtor(<span class="hljs-number">0</span>);
						forEach(<span class="hljs-built_in">arguments</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i)</span> {</span>
							<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) {
								i = <span class="hljs-keyword">this</span>.length + i;
							}
							<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[i]) {
								t.push(<span class="hljs-keyword">this</span>[i]);
							}
						}, <span class="hljs-keyword">this</span>);
						<span class="hljs-keyword">return</span> t._stash(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// dojo/NodeList</span>
					}
				});

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryForEngine</span><span class="hljs-params">(engine, NodeList)</span> {</span>
					<span class="hljs-keyword">var</span> query = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query, root)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-307">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-307">&#182;</a>
              </div>
              <p>summary:
    Returns nodes which match the given CSS selector, searching the
    entire document by default but optionally taking a node to scope
    the search by. Returns an instance of NodeList.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> root === <span class="hljs-string">'string'</span>) {
							root = dom.byId(root);
							<span class="hljs-keyword">if</span> (!root) {
								<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NodeList([]);
							}
						}
						<span class="hljs-keyword">var</span> results = <span class="hljs-keyword">typeof</span> query === <span class="hljs-string">'string'</span> ? engine(query, root) : query ? query.orphan ? query : [query] : [];
						<span class="hljs-keyword">if</span> (results.orphan) {</pre></div></div>
            
        </li>
        
        
        <li id="section-308">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-308">&#182;</a>
              </div>
              <p>already wrapped</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> results;
						}
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NodeList(results);
					};
					query.matches = engine.match || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, selector, root)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-309">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-309">&#182;</a>
              </div>
              <p>summary:
    Test to see if a node matches a selector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> query.filter([node], selector, root)
							.length &gt; <span class="hljs-number">0</span>;
					};</pre></div></div>
            
        </li>
        
        
        <li id="section-310">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-310">&#182;</a>
              </div>
              <p>the engine provides a filtering function, use it to for matching</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					query.filter = engine.filter || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(nodes, selector, root)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-311">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-311">&#182;</a>
              </div>
              <p>summary:
    Filters an array of nodes. Note that this does not guarantee to return a NodeList, just an array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> query(selector, root)
							.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
								<span class="hljs-keyword">return</span> array.indexOf(nodes, node) &gt; -<span class="hljs-number">1</span>;
							});
					};
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> engine !== <span class="hljs-string">'function'</span>) {
						<span class="hljs-keyword">var</span> search = engine.search;
						engine = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(selector, root)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-312">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-312">&#182;</a>
              </div>
              <p>Slick does it backwards (or everyone else does it backwards, probably the latter)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> search(root || document, selector);
						};
					}
					<span class="hljs-keyword">return</span> query;
				}
				<span class="hljs-keyword">var</span> query = queryForEngine(defaultEngine, NodeList);
				<span class="hljs-comment">/*=====
                 query = function(selector, context){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-313">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-313">&#182;</a>
              </div>
              <p>summary:
    This modules provides DOM querying functionality. The module export is a function
    that can be used to query for DOM nodes by CSS selector and returns a NodeList
    representing the matching nodes.
selector: String
    A CSS selector to search for.
context: String|DomNode?
    An optional context to limit the searching scope. Only nodes under <code>context</code> will be
    scanned.
example:
    add an onclick handler to every submit button in the document
    which causes the form to be sent via Ajax instead:
|    require([“dojo/query”], function(query){
|        query(“input[type=’submit’]”).on(“click”, function(e){
|            dojo.stopEvent(e); // prevent sending the form
|            var btn = e.target;
|            dojo.xhrPost({
|                form: btn.form,
|                load: function(data){
|                    // replace the form with the response
|                    var div = dojo.doc.createElement(“div”);
|                    dojo.place(div, btn.form, “after”);
|                    div.innerHTML = data;
|                    dojo.style(btn.form, “display”, “none”);
|                }
|            });
|        });
|    });</p>
<p>description:
    dojo/query is responsible for loading the appropriate query engine and wrapping
    its results with a <code>NodeList</code>. You can use dojo/query with a specific selector engine
    by using it as a plugin. For example, if you installed the sizzle package, you could
    use it as the selector engine with:
    |    require([“dojo/query!sizzle”], function(query){
    |        query(“div”)…</p>
<pre><code>The id after the ! can be a module id of the selector engine or one of the following values:

- acme: This is the <span class="hljs-keyword">default</span> engine used by Dojo base, and will ensure that the full
Acme engine is always loaded.

- css2: If the browser has a native selector engine, <span class="hljs-keyword">this</span> will be used, otherwise a
very minimal lightweight selector engine will be loaded that can <span class="hljs-keyword">do</span> simple CSS2 selectors
(by #id, .class, tag, and [name=value] attributes, <span class="hljs-keyword">with</span> standard child or descendant (&gt;)
operators) and nothing more.

- css2<span class="hljs-number">.1</span>: If the browser has a native selector engine, <span class="hljs-keyword">this</span> will be used, otherwise the
full Acme engine will be loaded.

- css3: If the browser has a native selector engine <span class="hljs-keyword">with</span> support <span class="hljs-keyword">for</span> CSS3 pseudo
selectors (most modern browsers except IE8), <span class="hljs-keyword">this</span> will be used, otherwise the
full Acme engine will be loaded.

- Or the module id of a selector engine can be used to explicitly choose the selector engine

For example, <span class="hljs-keyword">if</span> you are using CSS3 pseudo selectors <span class="hljs-keyword">in</span> module, you can specify that
you will need support them <span class="hljs-keyword">with</span>:
|    <span class="hljs-built_in">require</span>([<span class="hljs-string">"dojo/query!css3"</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(query)</span>{</span>
|        query(<span class="hljs-string">'#t &gt; h3:nth-child(odd)'</span>)...

You can also choose the selector engine/load configuration by setting the query-selector:
For example:
|    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">data-dojo-config</span>=<span class="hljs-value">"query-selector:'css3'"</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"dojo.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>                 return new NodeList(); // dojo/NodeList
                 };
                 =====*/</pre></div></div>
            
        </li>
        
        
        <li id="section-314">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-314">&#182;</a>
              </div>
              <p>the query that is returned from this module is slightly different than dojo.query,
because dojo.query has to maintain backwards compatibility with returning a
true array which has performance problems. The query returned from the module
does not use true arrays, but rather inherits from Array, making it much faster to
instantiate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo.query = queryForEngine(defaultEngine, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(array)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-315">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-315">&#182;</a>
              </div>
              <p>call it without the new operator to invoke the back-compat behavior that returns a true array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> NodeList(array); <span class="hljs-comment">// dojo/NodeList</span>
				});
				query.load = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, parentRequire, loaded)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-316">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-316">&#182;</a>
              </div>
              <p>summary:
    can be used as AMD plugin to conditionally load new query engine
example:
|    require([“dojo/query!custom”], function(qsa){
|        // loaded selector/custom.js as engine
|        qsa(“#foobar”).forEach(…);
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					loader.load(id, parentRequire, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(engine)</span> {</span>
						loaded(queryForEngine(engine, NodeList));
					});
				};
				dojo._filterQueryResult = query._filterResult = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(nodes, selector, root)</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NodeList(query.filter(nodes, selector, root));
				};
				dojo.NodeList = query.NodeList = NodeList;
				<span class="hljs-keyword">return</span> query;
			});
		},
		<span class="hljs-string">'dojo/has'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'require'</span>,
				<span class="hljs-string">'module'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(require, module)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-317">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-317">&#182;</a>
              </div>
              <p>module:
    dojo/has
summary:
    Defines the has.js API and several feature tests used by dojo.
description:
    This module defines the has API as described by the project has.js with the following additional features:</p>
<pre><code>- the has test cache is exposed at has.cache.
- the method has.add includes a forth parameter that controls whether or not existing tests are replaced
- the loader<span class="hljs-string">'s has cache may be optionally copied into this module'</span>s has cahce.

This module adopted from https:<span class="hljs-comment">//github.com/phiggins42/has.js; thanks has.js team!</span>
</code></pre><p>try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one
if using a foreign loader, then the has cache may be initialized via the config object for this module
WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> has = <span class="hljs-built_in">require</span>.has || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>};
				<span class="hljs-keyword">if</span> (!<span class="hljs-number">1</span>) {
					<span class="hljs-keyword">var</span> isBrowser = <span class="hljs-keyword">typeof</span> window !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> location !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> document !== <span class="hljs-string">'undefined'</span> &amp;&amp; window.location === location &amp;&amp; window.document === document,</pre></div></div>
            
        </li>
        
        
        <li id="section-318">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-318">&#182;</a>
              </div>
              <p>has API variables</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						global = <span class="hljs-keyword">this</span>,
						doc = isBrowser &amp;&amp; document,
						element = doc &amp;&amp; doc.createElement(<span class="hljs-string">'DiV'</span>),
						cache = module.config &amp;&amp; module.config() || {};
					has = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-319">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-319">&#182;</a>
              </div>
              <p>summary:
    Return the current value of the named feature.</p>
<p>name: String|Integer
    The name (if a string) or identifier (if an integer) of the feature to test.</p>
<p>description:
    Returns the value of the feature named by name. The feature must have been
    previously added to the cache by has.add.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> cache[name] === <span class="hljs-string">'function'</span> ? cache[name] = cache[name](global, doc, element) : cache[name]; <span class="hljs-comment">// Boolean</span>
					};
					has.cache = cache;
					has.add = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, test, now, force)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-320">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-320">&#182;</a>
              </div>
              <p>summary:
     Register a new feature test for some named feature.
name: String|Integer
     The name (if a string) or identifier (if an integer) of the feature to test.
test: Function
     A test function to register. If a function, queued for testing until actually
     needed. The test function should return a boolean indicating
     the presence of a feature or bug.
now: Boolean?
     Optional. Omit if <code>test</code> is not a function. Provides a way to immediately
     run the test and cache the result.
force: Boolean?
     Optional. If the test already exists and force is truthy, then the existing
     test will be replaced; otherwise, add does not replace an existing test (that
     is, by default, the first test advice wins).
example:
    A redundant test, testFn with immediate execution:
|    has.add(“javascript”, function(){ return true; }, true);</p>
<p>example:
    Again with the redundantness. You can do this in your tests, but we should
    not be doing this in any internal has.js tests
|    has.add(“javascript”, true);</p>
<p>example:
    Three things are passed to the testFunction. <code>global</code>, <code>document</code>, and a generic element
    from which to work your test should the need arise.
|    has.add(“bug-byid”, function(g, d, el){
|        // g    == global, typically window, yadda yadda
|        // d    == document object
|        // el == the generic element. a <code>has</code> element.
|        return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						(<span class="hljs-keyword">typeof</span> cache[name] === <span class="hljs-string">'undefined'</span> || force) &amp;&amp; (cache[name] = test);
						<span class="hljs-keyword">return</span> now &amp;&amp; has(name);
					};</pre></div></div>
            
        </li>
        
        
        <li id="section-321">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-321">&#182;</a>
              </div>
              <p>since we’re operating under a loader that doesn’t provide a has API, we must explicitly initialize
has as it would have otherwise been initialized by the dojo loader; use has.add to the builder
can optimize these away iff desired</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-number">1</span> || has.add(<span class="hljs-string">'host-browser'</span>, isBrowser);
					<span class="hljs-number">1</span> || has.add(<span class="hljs-string">'dom'</span>, isBrowser);
					<span class="hljs-number">1</span> || has.add(<span class="hljs-string">'dojo-dom-ready-api'</span>, <span class="hljs-number">1</span>);
					<span class="hljs-number">1</span> || has.add(<span class="hljs-string">'dojo-sniff'</span>, <span class="hljs-number">1</span>);
				}
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-322">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-322">&#182;</a>
              </div>
              <p>Common application level tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					has.add(<span class="hljs-string">'dom-addeventlistener'</span>, !! document.addEventListener);
					has.add(<span class="hljs-string">'touch'</span>, <span class="hljs-string">'ontouchstart'</span> <span class="hljs-keyword">in</span> document);</pre></div></div>
            
        </li>
        
        
        <li id="section-323">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-323">&#182;</a>
              </div>
              <p>I don’t know if any of these tests are really correct, just a rough guess</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					has.add(<span class="hljs-string">'device-width'</span>, screen.availWidth || innerWidth);</pre></div></div>
            
        </li>
        
        
        <li id="section-324">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-324">&#182;</a>
              </div>
              <p>Tests for DOMNode.attributes[] behavior:</p>
<ul>
<li>dom-attributes-explicit - attributes[] only lists explicitly user specified attributes</li>
<li>dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn’t specify</li>
<li>Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> form = document.createElement(<span class="hljs-string">'form'</span>);
					has.add(<span class="hljs-string">'dom-attributes-explicit'</span>, form.attributes.length === <span class="hljs-number">0</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-325">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-325">&#182;</a>
              </div>
              <p>W3C</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					has.add(<span class="hljs-string">'dom-attributes-specified-flag'</span>, form.attributes.length &gt; <span class="hljs-number">0</span> &amp;&amp; form.attributes.length &lt; <span class="hljs-number">40</span>); <span class="hljs-comment">// IE8</span>
				}
				has.clearElement = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(element)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-326">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-326">&#182;</a>
              </div>
              <p>summary:
 Deletes the contents of the element passed to test functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					element.innerHTML = <span class="hljs-string">''</span>;
					<span class="hljs-keyword">return</span> element;
				};
				has.normalize = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, toAbsMid)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-327">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-327">&#182;</a>
              </div>
              <p>summary:
 Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).</p>
<p>toAbsMid: Function
 Resolves a relative module id into an absolute module id</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> tokens = id.match(<span class="hljs-regexp">/[\?:]|[^:\?]*/g</span>),
						i = <span class="hljs-number">0</span>,
						get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(skip)</span> {</span>
							<span class="hljs-keyword">var</span> term = tokens[i++];
							<span class="hljs-keyword">if</span> (term === <span class="hljs-string">':'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-328">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-328">&#182;</a>
              </div>
              <p>empty string module name, resolves to 0</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
							} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-329">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-329">&#182;</a>
              </div>
              <p>postfixed with a ? means it is a feature to branch on, the term is the name of the feature</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (tokens[i++] === <span class="hljs-string">'?'</span>) {
									<span class="hljs-keyword">if</span> (!skip &amp;&amp; has(term)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-330">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-330">&#182;</a>
              </div>
              <p>matched the feature, get the first value from the options</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										<span class="hljs-keyword">return</span> get();
									} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-331">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-331">&#182;</a>
              </div>
              <p>did not match, get the second value, passing over the first</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										get(<span class="hljs-literal">true</span>);
										<span class="hljs-keyword">return</span> get(skip);
									}
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-332">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-332">&#182;</a>
              </div>
              <p>a module</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">return</span> term || <span class="hljs-number">0</span>;
							}
						};
					id = get();
					<span class="hljs-keyword">return</span> id &amp;&amp; toAbsMid(id);
				};
				has.load = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, parentRequire, loaded)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-333">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-333">&#182;</a>
              </div>
              <p>summary:
    Conditional loading of AMD modules based on a has feature test value.
id: String
    Gives the resolved module id to load.
parentRequire: Function
    The loader require function with respect to the module that contained the plugin resource in it’s
    dependency list.
loaded: Function
 Callback to loader that consumes result of plugin demand.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (id) {
						parentRequire([id], loaded);
					} <span class="hljs-keyword">else</span> {
						loaded();
					}
				};
				<span class="hljs-keyword">return</span> has;
			});
		},
		<span class="hljs-string">'dojo/_base/loader'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'../has'</span>,
				<span class="hljs-string">'require'</span>,
				<span class="hljs-string">'module'</span>,
				<span class="hljs-string">'./json'</span>,
				<span class="hljs-string">'./lang'</span>,
				<span class="hljs-string">'./array'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, has, require, thisModule, json, lang, array)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-334">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-334">&#182;</a>
              </div>
              <p>module:
    dojo/_base/loader
    This module defines the v1.x synchronous loader API.
signal the loader in sync mode…</p>
<blockquote>
<blockquote>
<p>pure-amd</p>
</blockquote>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!<span class="hljs-number">1</span>) {
					console.error(<span class="hljs-string">'cannot load the Dojo v1.x loader with a foreign loader'</span>);
					<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
				}
				<span class="hljs-number">1</span> || has.add(<span class="hljs-string">'dojo-fast-sync-require'</span>, <span class="hljs-number">1</span>);
				<span class="hljs-keyword">var</span> makeErrorToken = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> {</span>
					<span class="hljs-keyword">return</span> {
						src: thisModule.id,
						id: id
					};
				}, slashName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span>
						<span class="hljs-keyword">return</span> name.replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">'/'</span>);
					}, buildDetectRe = <span class="hljs-regexp">/\/\/&gt;&gt;built/</span>,
					dojoRequireCallbacks = [],
					dojoRequireModuleStack = [],
					dojoRequirePlugin = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid, require, loaded)</span> {</span>
						dojoRequireCallbacks.push(loaded);
						array.forEach(mid.split(<span class="hljs-string">','</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid)</span> {</span>
							<span class="hljs-keyword">var</span> module = getModule(mid, <span class="hljs-built_in">require</span>.module);
							dojoRequireModuleStack.push(module);
							injectModule(module);
						});
						checkDojoRequirePlugin();
					}, checkDojoRequirePlugin = <span class="hljs-number">1</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">var</span> module, mid;
						<span class="hljs-keyword">for</span> (mid <span class="hljs-keyword">in</span> modules) {
							module = modules[mid];
							<span class="hljs-keyword">if</span> (module.noReqPluginCheck === <span class="hljs-literal">undefined</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-335">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-335">&#182;</a>
              </div>
              <p>tag the module as either a loadInit or require plugin or not for future reference</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								module.noReqPluginCheck = <span class="hljs-regexp">/loadInit\!/</span>.test(mid) || <span class="hljs-regexp">/require\!/</span>.test(mid) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
							}
							<span class="hljs-keyword">if</span> (!module.executed &amp;&amp; !module.noReqPluginCheck &amp;&amp; module.injected === requested) {
								<span class="hljs-keyword">return</span>;
							}
						}
						guardCheckComplete(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							<span class="hljs-keyword">var</span> oldCallbacks = dojoRequireCallbacks;
							dojoRequireCallbacks = [];
							array.forEach(oldCallbacks, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> {</span>
								cb(<span class="hljs-number">1</span>);
							});
						});
					} : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-336">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-336">&#182;</a>
              </div>
              <p>Note: this is the original checkDojoRequirePlugin that is much slower than the algorithm above. However, we know it
works, so we leave it here in case the algorithm above fails in some corner case.</p>
<p>checkDojoRequirePlugin inspects all of the modules demanded by a dojo/require!<module-list> dependency
to see if they have arrived. The loader does not release <em>any</em> of these modules to be instantiated
until <em>all</em> of these modules are on board, thereby preventing the evaluation of a module with dojo.require’s
that reference modules that are not available.</p>
<p>The algorithm works by traversing the dependency graphs (remember, there can be cycles so they are not trees)
of each module in the dojoRequireModuleStack array (which contains the list of modules demanded by dojo/require!).
The moment a single module is discovered that is missing, the algorithm gives up and indicates that not all
modules are on board. dojo/loadInit! and dojo/require! are ignored because there dependencies are inserted
directly in dojoRequireModuleStack. For example, if “your/module” module depends on “dojo/require!my/module”, then
<em>both</em> “dojo/require!my/module” and “my/module” will be in dojoRequireModuleStack. Obviously, if “my/module”
is on board, then “dojo/require!my/module” is also satisfied, so the algorithm doesn’t check for “dojo/require!my/module”.</p>
<p>Note: inserting a dojo/require!<some-module-list> dependency in the dojoRequireModuleStack achieves nothing
with the current algorithm; however, having such modules present makes it possible to optimize the algorithm</p>
<p>Note: prior versions of this algorithm had an optimization that signaled loaded on dojo/require! dependencies
individually (rather than waiting for them all to be resolved). The implementation proved problematic with cycles
and plugins. However, it is possible to reattach that strategy in the future.
a set from module-id to {undefined | 1 | 0}, where…
 undefined =&gt; the module has not been inspected
 0 =&gt; the module or at least one of its dependencies has not arrived
 1 =&gt; the module is a loadInit! or require! plugin resource, or is currently being traversed (therefore, assume
      OK until proven otherwise), or has been completely traversed and all dependencies have arrived</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> touched, traverse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(m)</span> {</span>
								touched[m.mid] = <span class="hljs-number">1</span>;
								<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> t, module, deps = m.deps || [], i = <span class="hljs-number">0</span>; i &lt; deps.length; i++) {
									module = deps[i];
									<span class="hljs-keyword">if</span> (!(t = touched[module.mid])) {
										<span class="hljs-keyword">if</span> (t === <span class="hljs-number">0</span> || !traverse(module)) {
											touched[m.mid] = <span class="hljs-number">0</span>;
											<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
										}
									}
								}
								<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
							};
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-337">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-337">&#182;</a>
              </div>
              <p>initialize the touched hash with easy-to-compute values that help short circuit recursive algorithm;
recall loadInit/require plugin modules are dependencies of modules in dojoRequireModuleStack…
which would cause a circular dependency chain that would never be resolved if checked here
notice all dependencies of any particular loadInit/require plugin module will already
be checked since those are pushed into dojoRequireModuleStack explicitly by the
plugin…so if a particular loadInitPlugin module’s dependencies are not really
on board, that <em>will</em> be detected elsewhere in the traversal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> module, mid;
							touched = {};
							<span class="hljs-keyword">for</span> (mid <span class="hljs-keyword">in</span> modules) {
								module = modules[mid];
								<span class="hljs-keyword">if</span> (module.executed || module.noReqPluginCheck) {
									touched[mid] = <span class="hljs-number">1</span>;
								} <span class="hljs-keyword">else</span> {
									<span class="hljs-keyword">if</span> (module.noReqPluginCheck !== <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-338">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-338">&#182;</a>
              </div>
              <p>tag the module as either a loadInit or require plugin or not for future reference</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										module.noReqPluginCheck = <span class="hljs-regexp">/loadInit\!/</span>.test(mid) || <span class="hljs-regexp">/require\!/</span>.test(mid) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
									}
									<span class="hljs-keyword">if</span> (module.noReqPluginCheck) {
										touched[mid] = <span class="hljs-number">1</span>;
									} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (module.injected !== arrived) {</pre></div></div>
            
        </li>
        
        
        <li id="section-339">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-339">&#182;</a>
              </div>
              <p>not executed, has not arrived, and is not a loadInit or require plugin resource</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										touched[mid] = <span class="hljs-number">0</span>;
									} <span class="hljs-comment">// else, leave undefined and we'll traverse the dependencies</span>
								}
							}
							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> t, i = <span class="hljs-number">0</span>, end = dojoRequireModuleStack.length; i &lt; end; i++) {
								module = dojoRequireModuleStack[i];
								<span class="hljs-keyword">if</span> (!(t = touched[module.mid])) {
									<span class="hljs-keyword">if</span> (t === <span class="hljs-number">0</span> || !traverse(module)) {
										<span class="hljs-keyword">return</span>;
									}
								}
							}
							guardCheckComplete(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								<span class="hljs-keyword">var</span> oldCallbacks = dojoRequireCallbacks;
								dojoRequireCallbacks = [];
								array.forEach(oldCallbacks, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> {</span>
									cb(<span class="hljs-number">1</span>);
								});
							});
						};
					}(),
					dojoLoadInitPlugin = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid, require, loaded)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-340">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-340">&#182;</a>
              </div>
              <p>mid names a module that defines a “dojo load init” bundle, an object with two properties:</p>
<ul>
<li>names: a vector of module ids that give top-level names to define in the lexical scope of def</li>
<li>def: a function that contains some some legacy loader API applications</li>
</ul>
<p>The point of def is to possibly cause some modules to be loaded (but not executed) by dojo/require! where the module
ids are possibly-determined at runtime. For example, here is dojox.gfx from v1.6 expressed as an AMD module using the dojo/loadInit
and dojo/require plugins.</p>
<p>// dojox/gfx:</p>
<p> define(“*loadInit_12, {
   names:[“dojo”, “dijit”, “dojox”],
   def: function(){
     dojo.loadInit(function(){
       var gfx = lang.getObject(“dojox.gfx”, true);</p>
<pre><code>   <span class="hljs-comment">//</span>
   <span class="hljs-comment">// code required to set gfx properties ommitted...</span>
   <span class="hljs-comment">//</span>

   <span class="hljs-comment">// now use the calculations to include the runtime-dependent module</span>
   dojo.require(<span class="hljs-string">"dojox.gfx."</span> + gfx.renderer);
 });
</code></pre><p>   }
 });</p>
<p> define([“dojo”, “dojo/loadInit!” + id].concat(“dojo/require!dojox/gfx/matric,dojox/gfx/_base”), function(dojo){
   // when this AMD factory function is executed, the following modules are guaranteed downloaded but not executed:
   //    “dojox.gfx.” + gfx.renderer
   //    dojox.gfx.matrix
   //    dojox.gfx._base
   dojo.provide(“dojo.gfx”);
   dojo.require(“dojox.gfx.matrix”);
   dojo.require(“dojox.gfx._base”);
   dojo.require(“dojox.gfx.” + gfx.renderer);
   return lang.getObject(“dojo.gfx”);
 });
})();</p>
<p>The idea is to run the legacy loader API with global variables shadowed, which allows these variables to
be relocated. For example, dojox and dojo could be relocated to different names by giving a map and the code above will
execute properly (because the plugin below resolves the load init bundle.names module with respect to the module that demanded
the plugin resource).</p>
<p>Note that the relocation is specified in the runtime configuration; relocated names need not be set at build-time.</p>
<p>Warning: this is not the best way to express dojox.gfx as and AMD module. In fact, the module has been properly converted in
v1.7. However, this technique allows the builder to convert legacy modules into AMD modules and guarantee the codepath is the
same in the converted AMD module.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-built_in">require</span>([mid], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(bundle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-341">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-341">&#182;</a>
              </div>
              <p>notice how names is resolved with respect to the module that demanded the plugin resource</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-built_in">require</span>(bundle.names, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-342">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-342">&#182;</a>
              </div>
              <p>bring the bundle names into scope</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> scopeText = <span class="hljs-string">''</span>, args = [], i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) {
									scopeText += <span class="hljs-string">'var '</span> + bundle.names[i] + <span class="hljs-string">'= arguments['</span> + i + <span class="hljs-string">']; '</span>;
									args.push(<span class="hljs-built_in">arguments</span>[i]);
								}
								<span class="hljs-built_in">eval</span>(scopeText);
								<span class="hljs-keyword">var</span> callingModule = <span class="hljs-built_in">require</span>.module,</pre></div></div>
            
        </li>
        
        
        <li id="section-343">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-343">&#182;</a>
              </div>
              <p>the list of modules that need to be downloaded but not executed before the callingModule can be executed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									requireList = [],</pre></div></div>
            
        </li>
        
        
        <li id="section-344">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-344">&#182;</a>
              </div>
              <p>the list of i18n bundles that are xdomain; undefined if none</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									i18nDeps, syncLoaderApi = {
										provide: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(moduleName)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-345">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-345">&#182;</a>
              </div>
              <p>mark modules that arrive consequent to multiple provides in this module as arrived since they can’t be injected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>											moduleName = slashName(moduleName);
											<span class="hljs-keyword">var</span> providedModule = getModule(moduleName, callingModule);
											<span class="hljs-keyword">if</span> (providedModule !== callingModule) {
												setArrived(providedModule);
											}
										},
										<span class="hljs-built_in">require</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(moduleName, omitModuleCheck)</span> {</span>
											moduleName = slashName(moduleName);
											omitModuleCheck &amp;&amp; (getModule(moduleName, callingModule)
												.result = nonmodule);
											requireList.push(moduleName);
										},
										requireLocalization: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(moduleName, bundleName, locale)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-346">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-346">&#182;</a>
              </div>
              <p>since we’re going to need dojo/i8n, add it to i18nDeps if not already there</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>											<span class="hljs-keyword">if</span> (!i18nDeps) {</pre></div></div>
            
        </li>
        
        
        <li id="section-347">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-347">&#182;</a>
              </div>
              <p>don’t have to map since that will occur when the dependency is resolved</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>												i18nDeps = [<span class="hljs-string">'dojo/i18n'</span>];
											}</pre></div></div>
            
        </li>
        
        
        <li id="section-348">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-348">&#182;</a>
              </div>
              <p>figure out if the bundle is xdomain; if so, add it to the i18nDepsSet</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>											locale = (locale || dojo.locale)
												.toLowerCase();
											moduleName = slashName(moduleName) + <span class="hljs-string">'/nls/'</span> + (<span class="hljs-regexp">/root/i</span>.test(locale) ? <span class="hljs-string">''</span> : locale + <span class="hljs-string">'/'</span>) + slashName(bundleName);
											<span class="hljs-keyword">if</span> (getModule(moduleName, callingModule)
												.isXd) {</pre></div></div>
            
        </li>
        
        
        <li id="section-349">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-349">&#182;</a>
              </div>
              <p>don’t have to map since that will occur when the dependency is resolved</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>												i18nDeps.push(<span class="hljs-string">'dojo/i18n!'</span> + moduleName);
											} <span class="hljs-comment">// else the bundle will be loaded synchronously when the module is evaluated</span>
										},
										loadInit: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(f)</span> {</span>
											f();
										}
									}, hold = {}, p;</pre></div></div>
            
        </li>
        
        
        <li id="section-350">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-350">&#182;</a>
              </div>
              <p>hijack the correct dojo and apply bundle.def</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">try</span> {
									<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> syncLoaderApi) {
										hold[p] = dojo[p];
										dojo[p] = syncLoaderApi[p];
									}
									bundle.def.apply(<span class="hljs-literal">null</span>, args);
								} <span class="hljs-keyword">catch</span> (e) {
									signal(<span class="hljs-string">'error'</span>, [
										makeErrorToken(<span class="hljs-string">'failedDojoLoadInit'</span>),
										e
									]);
								} <span class="hljs-keyword">finally</span> {
									<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> syncLoaderApi) {
										dojo[p] = hold[p];
									}
								}
								<span class="hljs-keyword">if</span> (i18nDeps) {
									requireList = requireList.concat(i18nDeps);
								}
								<span class="hljs-keyword">if</span> (requireList.length) {
									dojoRequirePlugin(requireList.join(<span class="hljs-string">','</span>), <span class="hljs-built_in">require</span>, loaded);
								} <span class="hljs-keyword">else</span> {
									loaded();
								}
							});
						});
					}, extractApplication = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text, startSearch, startApplication)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-351">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-351">&#182;</a>
              </div>
              <p>find end of the call by finding the matching end paren
Warning: as usual, this will fail in the presense of unmatched right parans contained in strings, regexs, or unremoved comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> parenRe = <span class="hljs-regexp">/\(|\)/g</span>,
							matchCount = <span class="hljs-number">1</span>,
							match;
						parenRe.lastIndex = startSearch;
						<span class="hljs-keyword">while</span> (match = parenRe.exec(text)) {
							<span class="hljs-keyword">if</span> (match[<span class="hljs-number">0</span>] === <span class="hljs-string">')'</span>) {
								matchCount -= <span class="hljs-number">1</span>;
							} <span class="hljs-keyword">else</span> {
								matchCount += <span class="hljs-number">1</span>;
							}
							<span class="hljs-keyword">if</span> (matchCount === <span class="hljs-number">0</span>) {
								<span class="hljs-keyword">break</span>;
							}
						}
						<span class="hljs-keyword">if</span> (matchCount !== <span class="hljs-number">0</span>) {
							<span class="hljs-keyword">throw</span> <span class="hljs-string">'unmatched paren around character '</span> + parenRe.lastIndex + <span class="hljs-string">' in: '</span> + text;
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-352">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-352">&#182;</a>
              </div>
              <p>Put the master matching string in the results.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> [
							dojo.trim(text.substring(startApplication, parenRe.lastIndex)) + <span class="hljs-string">';\n'</span>,
							parenRe.lastIndex
						];
					},</pre></div></div>
            
        </li>
        
        
        <li id="section-353">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-353">&#182;</a>
              </div>
              <p>the following regex is taken from 1.6. It is a very poor technique to remove comments and
will fail in some cases; for example, consider the code…</p>
<p>  var message = “Category-1 <em>/</em> Category-2”;</p>
<p>The regex that follows will see a /* comment and trash the code accordingly. In fact, there are all
kinds of cases like this with strings and regexs that will cause this design to fail miserably.</p>
<p>Alternative regex designs exist that will result in less-likely failures, but will still fail in many cases.
The only solution guaranteed 100% correct is to parse the code and that seems overkill for this
backcompat/unbuilt-xdomain layer. In the end, since it’s been this way for a while, we won’t change it.
See the opening paragraphs of Chapter 7 or ECME-262 which describes the lexical abiguity further.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					removeCommentRe = <span class="hljs-regexp">/(\/\*([\s\S]*?)\*\/|\/\/(.*)$)/gm</span>,
					syncLoaderApiRe = <span class="hljs-regexp">/(^|\s)dojo\.(loadInit|require|provide|requireLocalization|requireIf|requireAfterIf|platformRequire)\s*\(/gm</span>,
					amdLoaderApiRe = <span class="hljs-regexp">/(^|\s)(require|define)\s*\(/m</span>,
					extractLegacyApiApplications = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text, noCommentText)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-354">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-354">&#182;</a>
              </div>
              <p>scan the noCommentText for any legacy loader API applications. Copy such applications into result (this is
used by the builder). Move dojo.loadInit applications to loadInitApplications string. Copy all other applications
to otherApplications string. If no applications were found, return 0, signalling an AMD module. Otherwise, return
loadInitApplications + otherApplications. Fixup text by replacing</p>
<p> dojo.loadInit(// etc…</p>
<p>with</p>
<p> \n 0 &amp;&amp; dojo.loadInit(// etc…</p>
<p>Which results in the dojo.loadInit from <em>not</em> being applied. This design goes a long way towards protecting the
code from an over-agressive removeCommentRe. However…</p>
<p>WARNING: the removeCommentRe will cause an error if a detected comment removes all or part of a legacy-loader application
that is not in a comment.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> match, startSearch, startApplication, application, loadInitApplications = [],
							otherApplications = [],
							allApplications = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-355">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-355">&#182;</a>
              </div>
              <p>noCommentText may be provided by a build app with comments extracted by a better method than regex (hopefully)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						noCommentText = noCommentText || text.replace(removeCommentRe, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(match)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-356">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-356">&#182;</a>
              </div>
              <p>remove iff the detected comment has text that looks like a sync loader API application; this helps by
removing as little as possible, minimizing the changes the janky regex will kill the module</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							syncLoaderApiRe.lastIndex = amdLoaderApiRe.lastIndex = <span class="hljs-number">0</span>;
							<span class="hljs-keyword">return</span> syncLoaderApiRe.test(match) || amdLoaderApiRe.test(match) ? <span class="hljs-string">''</span> : match;
						});</pre></div></div>
            
        </li>
        
        
        <li id="section-357">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-357">&#182;</a>
              </div>
              <p>find and extract all dojo.loadInit applications</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">while</span> (match = syncLoaderApiRe.exec(noCommentText)) {
							startSearch = syncLoaderApiRe.lastIndex;
							startApplication = startSearch - match[<span class="hljs-number">0</span>].length;
							application = extractApplication(noCommentText, startSearch, startApplication);
							<span class="hljs-keyword">if</span> (match[<span class="hljs-number">2</span>] === <span class="hljs-string">'loadInit'</span>) {
								loadInitApplications.push(application[<span class="hljs-number">0</span>]);
							} <span class="hljs-keyword">else</span> {
								otherApplications.push(application[<span class="hljs-number">0</span>]);
							}
							syncLoaderApiRe.lastIndex = application[<span class="hljs-number">1</span>];
						}
						allApplications = loadInitApplications.concat(otherApplications);
						<span class="hljs-keyword">if</span> (allApplications.length || !amdLoaderApiRe.test(noCommentText)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-358">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-358">&#182;</a>
              </div>
              <p>either there were some legacy loader API applications or there were no AMD API applications</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> [
								text.replace(<span class="hljs-regexp">/(^|\s)dojo\.loadInit\s*\(/g</span>, <span class="hljs-string">'\n0 &amp;&amp; dojo.loadInit('</span>),
								allApplications.join(<span class="hljs-string">''</span>),
								allApplications
							];
						} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-359">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-359">&#182;</a>
              </div>
              <p>legacy loader API <em>was not</em> detected and AMD API <em>was</em> detected; therefore, assume it’s an AMD module</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
						}
					}, transformToAmd = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module, text)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-360">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-360">&#182;</a>
              </div>
              <p>This is roughly the equivalent of dojo._xdCreateResource in 1.6-; however, it expresses a v1.6- dojo
module in terms of AMD define instead of creating the dojo proprietary xdomain module expression.
The module could have originated from several sources:</p>
<ul>
<li>amd require() a module, e.g., require([“my/module”])</li>
<li>amd require() a nonmodule, e.g., require([“my/resource.js”‘)</li>
<li>amd define() deps vector (always a module)</li>
<li>dojo.require() a module, e.g. dojo.require(“my.module”)</li>
<li>dojo.require() a nonmodule, e.g., dojo.require(“my.module”, true)</li>
<li>dojo.requireIf/requireAfterIf/platformRequire a module</li>
</ul>
<p>The module is scanned for legacy loader API applications; if none are found, then assume the module is an
AMD module and return 0. Otherwise, a synthetic dojo/loadInit plugin resource is created and the module text
is rewritten as an AMD module with the single dependency of this synthetic resource. When the dojo/loadInit
plugin loaded the synthetic resource, it will cause all dojo.loadInit’s to be executed, find all dojo.require’s
(either directly consequent to dojo.require or indirectly consequent to dojo.require[After]If or
dojo.platformRequire, and finally cause loading of all dojo.required modules with the dojo/require plugin. Thus,
when the dojo/loadInit plugin reports it has been loaded, all modules required by the given module are guaranteed
loaded (but not executed). This then allows the module to execute it’s code path without interupts, thereby
following the synchronous code path.</p>
<p>Notice that this function behaves the same whether or not it happens to be in a mapped dojo/loader module.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> extractResult, id, names = [],
							namesAsStrings = [];
						<span class="hljs-keyword">if</span> (buildDetectRe.test(text) || !(extractResult = extractLegacyApiApplications(text))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-361">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-361">&#182;</a>
              </div>
              <p>buildDetectRe.test(text) =&gt; a built module, always AMD
extractResult==0 =&gt; no sync API</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-362">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-362">&#182;</a>
              </div>
              <p>manufacture a synthetic module id that can never be a real mdule id (just like require does)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						id = module.mid + <span class="hljs-string">'-*loadInit'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-363">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-363">&#182;</a>
              </div>
              <p>construct the dojo/loadInit names vector which causes any relocated names to be defined as lexical variables under their not-relocated name
the dojo/loadInit plugin assumes the first name in names is “dojo”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> getModule(<span class="hljs-string">'dojo'</span>, module)
							.result.scopeMap) {
							names.push(p);
							namesAsStrings.push(<span class="hljs-string">'"'</span> + p + <span class="hljs-string">'"'</span>);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-364">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-364">&#182;</a>
              </div>
              <p>rewrite the module as a synthetic dojo/loadInit plugin resource + the module expressed as an AMD module that depends on this synthetic resource
don’t have to map dojo/init since that will occur when the dependency is resolved</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-string">'// xdomain rewrite of '</span> + module.mid + <span class="hljs-string">'\n'</span> + <span class="hljs-string">'define(\''</span> + id + <span class="hljs-string">'\',{\n'</span> + <span class="hljs-string">'\tnames:'</span> + dojo.toJson(names) + <span class="hljs-string">',\n'</span> + <span class="hljs-string">'\tdef:function('</span> + names.join(<span class="hljs-string">','</span>) + <span class="hljs-string">'){'</span> + extractResult[<span class="hljs-number">1</span>] + <span class="hljs-string">'}'</span> + <span class="hljs-string">'});\n\n'</span> + <span class="hljs-string">'define('</span> + dojo.toJson(names.concat([<span class="hljs-string">'dojo/loadInit!'</span> + id])) + <span class="hljs-string">', function('</span> + names.join(<span class="hljs-string">','</span>) + <span class="hljs-string">'){\n'</span> + extractResult[<span class="hljs-number">0</span>] + <span class="hljs-string">'});'</span>;
					}, loaderVars = <span class="hljs-built_in">require</span>.initSyncLoader(dojoRequirePlugin, checkDojoRequirePlugin, transformToAmd),
					sync = loaderVars.sync,
					requested = loaderVars.requested,
					arrived = loaderVars.arrived,
					nonmodule = loaderVars.nonmodule,
					executing = loaderVars.executing,
					executed = loaderVars.executed,
					syncExecStack = loaderVars.syncExecStack,
					modules = loaderVars.modules,
					execQ = loaderVars.execQ,
					getModule = loaderVars.getModule,
					injectModule = loaderVars.injectModule,
					setArrived = loaderVars.setArrived,
					signal = loaderVars.signal,
					finishExec = loaderVars.finishExec,
					execModule = loaderVars.execModule,
					getLegacyMode = loaderVars.getLegacyMode,
					guardCheckComplete = loaderVars.guardCheckComplete;</pre></div></div>
            
        </li>
        
        
        <li id="section-365">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-365">&#182;</a>
              </div>
              <p>there is exactly one dojoRequirePlugin among possibly-many dojo/_base/loader’s (owing to mapping)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojoRequirePlugin = loaderVars.dojoRequirePlugin;
				dojo.provide = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mid)</span> {</span>
					<span class="hljs-keyword">var</span> executingModule = syncExecStack[<span class="hljs-number">0</span>],
						module = lang.mixin(getModule(slashName(mid), <span class="hljs-built_in">require</span>.module), {
							executed: executing,
							result: lang.getObject(mid, <span class="hljs-literal">true</span>)
						});
					setArrived(module);
					<span class="hljs-keyword">if</span> (executingModule) {
						(executingModule.provides || (executingModule.provides = []))
							.push(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								module.result = lang.getObject(mid);
								<span class="hljs-keyword">delete</span> module.provides;
								module.executed !== executed &amp;&amp; finishExec(module);
							});
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-366">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-366">&#182;</a>
              </div>
              <p>else dojo.provide called not consequent to loading; therefore, give up trying to publish module value to loader namespace</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> module.result;
				};
				has.add(<span class="hljs-string">'config-publishRequireResult'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
				dojo.require = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(moduleName, omitModuleCheck)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-367">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-367">&#182;</a>
              </div>
              <p>summary:
    loads a Javascript module from the appropriate URI</p>
<p>moduleName: String
    module name to load, using periods for separators,
     e.g. “dojo.date.locale”.  Module paths are de-referenced by dojo’s
    internal mapping of locations to names and are disambiguated by
    longest prefix. See <code>dojo.registerModulePath()</code> for details on
    registering new modules.</p>
<p>omitModuleCheck: Boolean?
    if <code>true</code>, omitModuleCheck skips the step of ensuring that the
    loaded file actually defines the symbol it is referenced by.
    For example if it called as <code>dojo.require(&quot;a.b.c&quot;)</code> and the
    file located at <code>a/b/c.js</code> does not define an object <code>a.b.c</code>,
    and exception will be throws whereas no exception is raised
    when called as <code>dojo.require(&quot;a.b.c&quot;, true)</code></p>
<p>description:
    Modules are loaded via dojo.require by using one of two loaders: the normal loader
    and the xdomain loader. The xdomain loader is used when dojo was built with a
    custom build that specified loader=xdomain and the module lives on a modulePath
    that is a whole URL, with protocol and a domain. The versions of Dojo that are on
    the Google and AOL CDNs use the xdomain loader.</p>
<pre><code>If the module is loaded via the xdomain loader, it is an asynchronous load, since
the module is added via a dynamically created script tag. This
means that dojo.require() can <span class="hljs-keyword">return</span> before the module has loaded. However, <span class="hljs-keyword">this</span>
should only happen <span class="hljs-keyword">in</span> the <span class="hljs-keyword">case</span> where you <span class="hljs-keyword">do</span> dojo.require calls <span class="hljs-keyword">in</span> the top-level
HTML page, or <span class="hljs-keyword">if</span> you purposely avoid the loader checking <span class="hljs-keyword">for</span> dojo.require
dependencies <span class="hljs-keyword">in</span> your module by using a syntax like dojo[<span class="hljs-string">"require"</span>] to load the module.

Sometimes it is useful to not have the loader detect the dojo.require calls <span class="hljs-keyword">in</span> the
module so that you can dynamically load the modules as a result of an action on the
page, instead of right at module load time.

Also, <span class="hljs-keyword">for</span> script blocks <span class="hljs-keyword">in</span> an HTML page, the loader does not pre-process them, so
it does not know to download the modules before the dojo.require calls occur.

So, <span class="hljs-keyword">in</span> those two cases, when you want on-the-fly module loading or <span class="hljs-keyword">for</span> script blocks
<span class="hljs-keyword">in</span> the HTML page, special care must be taken <span class="hljs-keyword">if</span> the dojo.required code is loaded
asynchronously. To make sure you can execute code that depends on the dojo.required
modules, be sure to add the code that depends on the modules <span class="hljs-keyword">in</span> a dojo.addOnLoad()
callback. dojo.addOnLoad waits <span class="hljs-keyword">for</span> all outstanding modules to finish loading before
executing.

This type of syntax works <span class="hljs-keyword">with</span> both xdomain and normal loaders, so it is good
practice to always use <span class="hljs-keyword">this</span> idiom <span class="hljs-keyword">for</span> on-the-fly code loading and <span class="hljs-keyword">in</span> HTML script
blocks. If at some point you change loaders and where the code is loaded from,
it will all still work.

More on how dojo.require
`dojo.require(<span class="hljs-string">"A.B"</span>)` first checks to see <span class="hljs-keyword">if</span> symbol A.B is
defined. If it is, it is simply returned (nothing to <span class="hljs-keyword">do</span>).

If it is not defined, it will look <span class="hljs-keyword">for</span> `A/B.js` <span class="hljs-keyword">in</span> the script root
directory.

`dojo.require` throws an exception <span class="hljs-keyword">if</span> it cannot find a file
to load, or <span class="hljs-keyword">if</span> the symbol `A.B` is not defined after loading.

It returns the object `A.B`, but note the caveats above about on-the-fly loading and
HTML script blocks when the xdomain loader is loading a module.

`dojo.require()` does nothing about importing symbols into
the current namespace.    It is presumed that the caller will
take care of that.
</code></pre><p>example:
    To use dojo.require in conjunction with dojo.ready:</p>
<pre><code>|    dojo.require(<span class="hljs-string">"foo"</span>);
|    dojo.require(<span class="hljs-string">"bar"</span>);
|    dojo.addOnLoad(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
|        <span class="hljs-comment">//you can now safely do something with foo and bar</span>
|    });
</code></pre><p>example:
    For example, to import all symbols into a local block, you might write:</p>
<pre><code>|    <span class="hljs-keyword">with</span> (dojo.require(<span class="hljs-string">"A.B"</span>)) {
|        ...
|    }

And to import just the leaf symbol to a local variable:

|    <span class="hljs-keyword">var</span> B = dojo.require(<span class="hljs-string">"A.B"</span>);
|    ...
</code></pre><p>returns:
    the required namespace object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doRequire</span><span class="hljs-params">(mid, omitModuleCheck)</span> {</span>
						<span class="hljs-keyword">var</span> module = getModule(slashName(mid), <span class="hljs-built_in">require</span>.module);
						<span class="hljs-keyword">if</span> (syncExecStack.length &amp;&amp; syncExecStack[<span class="hljs-number">0</span>].finish) {</pre></div></div>
            
        </li>
        
        
        <li id="section-368">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-368">&#182;</a>
              </div>
              <p>switched to async loading in the middle of evaluating a legacy module; stop
applying dojo.require so the remaining dojo.requires are applied in order</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							syncExecStack[<span class="hljs-number">0</span>].finish.push(mid);
							<span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-369">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-369">&#182;</a>
              </div>
              <p>recall module.executed has values {0, executing, executed}; therefore, truthy indicates executing or executed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (module.executed) {
							<span class="hljs-keyword">return</span> module.result;
						}
						omitModuleCheck &amp;&amp; (module.result = nonmodule);</pre></div></div>
            
        </li>
        
        
        <li id="section-370">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-370">&#182;</a>
              </div>
              <p>rcg…why here and in two lines??</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> currentMode = getLegacyMode();</pre></div></div>
            
        </li>
        
        
        <li id="section-371">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-371">&#182;</a>
              </div>
              <p>recall, in sync mode to inject is to <em>eval</em> the module text
if the module is a legacy module, this is the same as executing
but if the module is an AMD module, this means defining, not executing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						injectModule(module);</pre></div></div>
            
        </li>
        
        
        <li id="section-372">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-372">&#182;</a>
              </div>
              <p>the inject may have changed the mode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						currentMode = getLegacyMode();</pre></div></div>
            
        </li>
        
        
        <li id="section-373">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-373">&#182;</a>
              </div>
              <p>in sync mode to dojo.require is to execute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (module.executed !== executed &amp;&amp; module.injected === arrived) {</pre></div></div>
            
        </li>
        
        
        <li id="section-374">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-374">&#182;</a>
              </div>
              <p>the module was already here before injectModule was called probably finishing up a xdomain
load, but maybe a module given to the loader directly rather than having the loader retrieve it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							loaderVars.guardCheckComplete(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								execModule(module);
							});
						}
						<span class="hljs-keyword">if</span> (module.executed) {
							<span class="hljs-keyword">return</span> module.result;
						}
						<span class="hljs-keyword">if</span> (currentMode === sync) {</pre></div></div>
            
        </li>
        
        
        <li id="section-375">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-375">&#182;</a>
              </div>
              <p>the only way to get here is in sync mode and dojo.required a module that</p>
<ul>
<li>was loaded async in the injectModule application a few lines up</li>
<li>was an AMD module that had deps that are being loaded async and therefore couldn’t execute</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (module.cjs) {</pre></div></div>
            
        </li>
        
        
        <li id="section-376">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-376">&#182;</a>
              </div>
              <p>the module was an AMD module; unshift, not push, which causes the current traversal to be reattempted from the top</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								execQ.unshift(module);
							} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-377">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-377">&#182;</a>
              </div>
              <p>the module was a legacy module</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								syncExecStack.length &amp;&amp; (syncExecStack[<span class="hljs-number">0</span>].finish = [mid]);
							}
						} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-378">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-378">&#182;</a>
              </div>
              <p>the loader wasn’t in sync mode on entry; probably async mode; therefore, no expectation of getting
the module value synchronously; make sure it gets executed though</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							execQ.push(module);
						}
						<span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
					}
					<span class="hljs-keyword">var</span> result = doRequire(moduleName, omitModuleCheck);
					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'config-publishRequireResult'</span>) &amp;&amp; !lang.exists(moduleName) &amp;&amp; result !== <span class="hljs-literal">undefined</span>) {
						lang.setObject(moduleName, result);
					}
					<span class="hljs-keyword">return</span> result;
				};
				dojo.loadInit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(f)</span> {</span>
					f();
				};
				dojo.registerModulePath = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(moduleName, prefix)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-379">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-379">&#182;</a>
              </div>
              <p>summary:
    Maps a module name to a path
description:
    An unregistered module is given the default path of ../[module],
    relative to Dojo root. For example, module acme is mapped to
    ../acme.  If you want to use a different module name, use
    dojo.registerModulePath.
example:
    If your dojo.js is located at this location in the web root:
|    /myapp/js/dojo/dojo/dojo.js
    and your modules are located at:
|    /myapp/js/foo/bar.js
|    /myapp/js/foo/baz.js
|    /myapp/js/foo/thud/xyzzy.js
    Your application can tell Dojo to locate the “foo” namespace by calling:
|    dojo.registerModulePath(“foo”, “../../foo”);
    At which point you can then use dojo.require() to load the
    modules (assuming they provide() the same things which are
    required). The full code might be:
|    <script type="text/javascript"
|        src="/myapp/js/dojo/dojo/dojo.js"></script>
|    <script type="text/javascript">
|        dojo.registerModulePath(“foo”, “../../foo”);
|        dojo.require(“foo.bar”);
|        dojo.require(“foo.baz”);
|        dojo.require(“foo.thud.xyzzy”);
|    </script></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> paths = {};
					paths[moduleName.replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">'/'</span>)] = prefix;
					<span class="hljs-built_in">require</span>({
						paths: paths
					});
				};
				dojo.platformRequire = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(modMap)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-380">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-380">&#182;</a>
              </div>
              <p>summary:
    require one or more modules based on which host environment
    Dojo is currently operating in
description:
    This method takes a “map” of arrays which one can use to
    optionally load dojo modules. The map is indexed by the
    possible dojo.name<em> values, with two additional values:
    “default” and “common”. The items in the “default” array will
    be loaded if none of the other items have been choosen based on
    dojo.name</em>, set by your host environment. The items in the
    “common” array will <em>always</em> be loaded, regardless of which
    list is chosen.
example:
    |    dojo.platformRequire({
    |        browser: [
    |            “foo.sample”, // simple module
    |            “foo.test”,
    |            [“foo.bar.baz”, true] // skip object check in _loadModule (dojo.require)
    |        ],
    |        default: [ “foo.sample._base” ],
    |        common: [ “important.module.common” ]
    |    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> result = (modMap.common || [])
						.concat(modMap[dojo._name] || modMap[<span class="hljs-string">'default'</span>] || []),
						temp;
					<span class="hljs-keyword">while</span> (result.length) {
						<span class="hljs-keyword">if</span> (lang.isArray(temp = result.shift())) {
							dojo.require.apply(dojo, temp);
						} <span class="hljs-keyword">else</span> {
							dojo.require(temp);
						}
					}
				};
				dojo.requireIf = dojo.requireAfterIf = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(condition, moduleName, omitModuleCheck)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-381">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-381">&#182;</a>
              </div>
              <p>summary:
    If the condition is true then call <code>dojo.require()</code> for the specified
    resource</p>
<p>example:
|    dojo.requireIf(dojo.isBrowser, “my.special.Module”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (condition) {
						dojo.require(moduleName, omitModuleCheck);
					}
				};
				dojo.requireLocalization = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(moduleName, bundleName, locale)</span> {</span>
					<span class="hljs-built_in">require</span>([<span class="hljs-string">'../i18n'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i18n)</span> {</span>
						i18n.getLocalization(moduleName, bundleName, locale);
					});
				};
				<span class="hljs-keyword">return</span> {
					extractLegacyApiApplications: extractLegacyApiApplications,
					<span class="hljs-built_in">require</span>: dojoRequirePlugin,
					loadInit: dojoLoadInitPlugin
				};
			});
		},
		<span class="hljs-string">'dojo/json'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([<span class="hljs-string">'./has'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(has)</span> {</span>
<span class="hljs-pi">				'use strict'</span>;
				<span class="hljs-keyword">var</span> hasJSON = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">JSON</span> !== <span class="hljs-string">'undefined'</span>;
				has.add(<span class="hljs-string">'json-parse'</span>, hasJSON);</pre></div></div>
            
        </li>
        
        
        <li id="section-382">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-382">&#182;</a>
              </div>
              <p>all the parsers work fine
Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=509184">https://bugzilla.mozilla.org/show_bug.cgi?id=509184</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				has.add(<span class="hljs-string">'json-stringify'</span>, hasJSON &amp;&amp; <span class="hljs-built_in">JSON</span>.stringify({
					a: <span class="hljs-number">0</span>
				}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k, v)</span> {</span>
					<span class="hljs-keyword">return</span> v || <span class="hljs-number">1</span>;
				}) === <span class="hljs-string">'{"a":1}'</span>);
				<span class="hljs-comment">/*=====
             return {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-383">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-383">&#182;</a>
              </div>
              <p>summary:
    Functions to parse and serialize JSON</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
             parse: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(str, strict)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-384">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-384">&#182;</a>
              </div>
              <p>summary:
    Parses a <a href="http://json.org">JSON</a> string to return a JavaScript object.
description:
    This function follows <a href="https://developer.mozilla.org/en/JSON">native JSON API</a>
    Throws for invalid JSON strings. This delegates to eval() if native JSON
    support is not available. By default this will evaluate any valid JS expression.
    With the strict parameter set to true, the parser will ensure that only
    valid JSON strings are parsed (otherwise throwing an error). Without the strict
    parameter, the content passed to this method must come
    from a trusted source.
str:
    a string literal of a JSON item, for instance:
    <code>&#39;{ &quot;foo&quot;: [ &quot;bar&quot;, 1, { &quot;baz&quot;: &quot;thud&quot; } ] }&#39;</code>
strict:
    When set to true, this will ensure that only valid, secure JSON is ever parsed.
    Make sure this is set to true for untrusted content. Note that on browsers/engines
    without native JSON support, setting this to true will run slower.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             },
             stringify: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, replacer, spacer)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-385">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-385">&#182;</a>
              </div>
              <p>summary:
    Returns a <a href="http://json.org">JSON</a> serialization of an object.
description:
    Returns a <a href="http://json.org">JSON</a> serialization of an object.
    This function follows <a href="https://developer.mozilla.org/en/JSON">native JSON API</a>
    Note that this doesn’t check for infinite recursion, so don’t do that!
value:
    A value to be serialized.
replacer:
    A replacer function that is called for each value and can return a replacement
spacer:
    A spacer string to be used for pretty printing of JSON
example:
    simple serialization of a trivial object
|    define([“dojo/json”], function(JSON){
    |        var jsonStr = JSON.stringify({ howdy: “stranger!”, isStrange: true });
|        doh.is(‘{“howdy”:”stranger!”,”isStrange”:true}’, jsonStr);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             }
             };
             =====*/
				if (has('json-stringify')) {
					return JSON;
				} else {
					var escapeString = function (str) {</pre></div></div>
            
        </li>
        
        
        <li id="section-386">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-386">&#182;</a>
              </div>
              <p>summary:
    Adds escape sequences for non-visual characters, double quote and
    backslash and surrounds with double quotes to form a valid string
    literal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> (<span class="hljs-string">'"'</span> + str.replace(<span class="hljs-regexp">/(["\\])/g</span>, <span class="hljs-string">'\\$1'</span>) + <span class="hljs-string">'"'</span>)
							.replace(<span class="hljs-regexp">/[\f]/g</span>, <span class="hljs-string">'\\f'</span>)
							.replace(<span class="hljs-regexp">/[\b]/g</span>, <span class="hljs-string">'\\b'</span>)
							.replace(<span class="hljs-regexp">/[\n]/g</span>, <span class="hljs-string">'\\n'</span>)
							.replace(<span class="hljs-regexp">/[\t]/g</span>, <span class="hljs-string">'\\t'</span>)
							.replace(<span class="hljs-regexp">/[\r]/g</span>, <span class="hljs-string">'\\r'</span>); <span class="hljs-comment">// string</span>
					};
					<span class="hljs-keyword">return</span> {
						parse: has(<span class="hljs-string">'json-parse'</span>) ? <span class="hljs-built_in">JSON</span>.parse : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(str, strict)</span> {</span>
							<span class="hljs-keyword">if</span> (strict &amp;&amp; !<span class="hljs-regexp">/^([\s\[\{]*(?:"(?:\\.|[^"])+"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/</span>.test(str)) {
								<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">SyntaxError</span>(<span class="hljs-string">'Invalid characters in JSON'</span>);
							}
							<span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">'('</span> + str + <span class="hljs-string">')'</span>);
						},
						stringify: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value, replacer, spacer)</span> {</span>
							<span class="hljs-keyword">var</span> undef;
							<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> replacer === <span class="hljs-string">'string'</span>) {
								spacer = replacer;
								replacer = <span class="hljs-literal">null</span>;
							}

							<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringify</span><span class="hljs-params">(it, indent, key)</span> {</span>
								<span class="hljs-keyword">if</span> (replacer) {
									it = replacer(key, it);
								}
								<span class="hljs-keyword">var</span> val, objtype = <span class="hljs-keyword">typeof</span> it;
								<span class="hljs-keyword">if</span> (objtype === <span class="hljs-string">'number'</span>) {
									<span class="hljs-keyword">return</span> <span class="hljs-built_in">isFinite</span>(it) ? it + <span class="hljs-string">''</span> : <span class="hljs-string">'null'</span>;
								}
								<span class="hljs-keyword">if</span> (objtype === <span class="hljs-string">'boolean'</span>) {
									<span class="hljs-keyword">return</span> it + <span class="hljs-string">''</span>;
								}
								<span class="hljs-keyword">if</span> (it === <span class="hljs-literal">null</span>) {
									<span class="hljs-keyword">return</span> <span class="hljs-string">'null'</span>;
								}
								<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> it === <span class="hljs-string">'string'</span>) {
									<span class="hljs-keyword">return</span> escapeString(it);
								}
								<span class="hljs-keyword">if</span> (objtype === <span class="hljs-string">'function'</span> || objtype === <span class="hljs-string">'undefined'</span>) {
									<span class="hljs-keyword">return</span> undef; <span class="hljs-comment">// undefined</span>
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-387">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-387">&#182;</a>
              </div>
              <p>short-circuit for objects that support “json” serialization
if they return “self” then just pass-through…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> it.toJSON === <span class="hljs-string">'function'</span>) {
									<span class="hljs-keyword">return</span> stringify(it.toJSON(key), indent, key);
								}
								<span class="hljs-keyword">if</span> (it <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) {
									<span class="hljs-keyword">return</span> <span class="hljs-string">'"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'</span>.replace(<span class="hljs-regexp">/\{(\w+)(\+)?\}/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(t, prop, plus)</span> {</span>
										<span class="hljs-keyword">var</span> num = it[<span class="hljs-string">'getUTC'</span> + prop]() + (plus ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
										<span class="hljs-keyword">return</span> num &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">'0'</span> + num : num;
									});
								}
								<span class="hljs-keyword">if</span> (it.valueOf() !== it) {</pre></div></div>
            
        </li>
        
        
        <li id="section-388">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-388">&#182;</a>
              </div>
              <p>primitive wrapper, try again unwrapped:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-keyword">return</span> stringify(it.valueOf(), indent, key);
								}
								<span class="hljs-keyword">var</span> nextIndent = spacer ? indent + spacer : <span class="hljs-string">''</span>;
								<span class="hljs-comment">/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */</span>
								<span class="hljs-keyword">var</span> sep = spacer ? <span class="hljs-string">' '</span> : <span class="hljs-string">''</span>;
								<span class="hljs-keyword">var</span> newLine = spacer ? <span class="hljs-string">'\n'</span> : <span class="hljs-string">''</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-389">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-389">&#182;</a>
              </div>
              <p>array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (it <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {
									<span class="hljs-keyword">var</span> itl = it.length,
										res = [];
									<span class="hljs-keyword">for</span> (key = <span class="hljs-number">0</span>; key &lt; itl; key++) {
										<span class="hljs-keyword">var</span> obj = it[key];
										val = stringify(obj, nextIndent, key);
										<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val !== <span class="hljs-string">'string'</span>) {
											val = <span class="hljs-string">'null'</span>;
										}
										res.push(newLine + nextIndent + val);
									}
									<span class="hljs-keyword">return</span> <span class="hljs-string">'['</span> + res.join(<span class="hljs-string">','</span>) + newLine + indent + <span class="hljs-string">']'</span>;
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-390">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-390">&#182;</a>
              </div>
              <p>generic object code path</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">var</span> output = [];
								<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> it) {
									<span class="hljs-keyword">var</span> keyStr;
									<span class="hljs-keyword">if</span> (it.hasOwnProperty(key)) {
										<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'number'</span>) {
											keyStr = <span class="hljs-string">'"'</span> + key + <span class="hljs-string">'"'</span>;
										} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'string'</span>) {
											keyStr = escapeString(key);
										} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-391">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-391">&#182;</a>
              </div>
              <p>skip non-string or number keys</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>											<span class="hljs-keyword">continue</span>;
										}
										val = stringify(it[key], nextIndent, key);
										<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val !== <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-392">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-392">&#182;</a>
              </div>
              <p>skip non-serializable values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>											<span class="hljs-keyword">continue</span>;
										}</pre></div></div>
            
        </li>
        
        
        <li id="section-393">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-393">&#182;</a>
              </div>
              <p>At this point, the most non-IE browsers don’t get in this branch 
(they have native JSON), so push is definitely the way to</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										output.push(newLine + nextIndent + keyStr + <span class="hljs-string">':'</span> + sep + val);
									}
								}
								<span class="hljs-keyword">return</span> <span class="hljs-string">'{'</span> + output.join(<span class="hljs-string">','</span>) + newLine + indent + <span class="hljs-string">'}'</span>; <span class="hljs-comment">// String</span>
							}
							<span class="hljs-keyword">return</span> stringify(value, <span class="hljs-string">''</span>, <span class="hljs-string">''</span>);
						}
					};
				}
			});
		},
		<span class="hljs-string">'dojo/_base/declare'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'../has'</span>,
				<span class="hljs-string">'./lang'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, has, lang)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-394">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-394">&#182;</a>
              </div>
              <p>module:
    dojo/_base/declare</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> mix = lang.mixin,
					op = <span class="hljs-built_in">Object</span>.prototype,
					opts = op.toString,
					xtor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(),
					counter = <span class="hljs-number">0</span>,
					cname = <span class="hljs-string">'constructor'</span>;

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">err</span><span class="hljs-params">(msg, cls)</span> {</span>
					<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'declare'</span> + (cls ? <span class="hljs-string">' '</span> + cls : <span class="hljs-string">''</span>) + <span class="hljs-string">': '</span> + msg);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-395">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-395">&#182;</a>
              </div>
              <p>C3 Method Resolution Order (see <a href="http://www.python.org/download/releases/2.3/mro/">http://www.python.org/download/releases/2.3/mro/</a>)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c3mro</span><span class="hljs-params">(bases, className)</span> {</span>
					<span class="hljs-keyword">var</span> result = [],
						roots = [{
							cls: <span class="hljs-number">0</span>,
							refs: []
						}],
						nameMap = {}, clsCount = <span class="hljs-number">1</span>,
						l = bases.length,
						i = <span class="hljs-number">0</span>,
						j, lin, base, top, proto, rec, name, refs;</pre></div></div>
            
        </li>
        
        
        <li id="section-396">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-396">&#182;</a>
              </div>
              <p>build a list of bases naming them if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">for</span> (; i &lt; l; ++i) {
						base = bases[i];
						<span class="hljs-keyword">if</span> (!base) {
							err(<span class="hljs-string">'mixin #'</span> + i + <span class="hljs-string">' is unknown. Did you use dojo.require to pull it in?'</span>, className);
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opts.call(base) !== <span class="hljs-string">'[object Function]'</span>) {
							err(<span class="hljs-string">'mixin #'</span> + i + <span class="hljs-string">' is not a callable constructor.'</span>, className);
						}
						lin = base._meta ? base._meta.bases : [base];
						top = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-397">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-397">&#182;</a>
              </div>
              <p>add bases to the name map</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (j = lin.length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) {
							proto = lin[j].prototype;
							<span class="hljs-keyword">if</span> (!proto.hasOwnProperty(<span class="hljs-string">'declaredClass'</span>)) {
								proto.declaredClass = <span class="hljs-string">'uniqName_'</span> + counter++;
							}
							name = proto.declaredClass;
							<span class="hljs-keyword">if</span> (!nameMap.hasOwnProperty(name)) {
								nameMap[name] = {
									count: <span class="hljs-number">0</span>,
									refs: [],
									cls: lin[j]
								};
								++clsCount;
							}
							rec = nameMap[name];
							<span class="hljs-keyword">if</span> (top &amp;&amp; top !== rec) {
								rec.refs.push(top);
								++top.count;
							}
							top = rec;
						}
						++top.count;
						roots[<span class="hljs-number">0</span>].refs.push(top);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-398">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-398">&#182;</a>
              </div>
              <p>remove classes without external references recursively</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">while</span> (roots.length) {
						top = roots.pop();
						result.push(top.cls);
						--clsCount;</pre></div></div>
            
        </li>
        
        
        <li id="section-399">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-399">&#182;</a>
              </div>
              <p>optimization: follow a single-linked chain</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">while</span> (refs = top.refs, refs.length === <span class="hljs-number">1</span>) {
							top = refs[<span class="hljs-number">0</span>];
							<span class="hljs-keyword">if</span> (!top || --top.count) {</pre></div></div>
            
        </li>
        
        
        <li id="section-400">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-400">&#182;</a>
              </div>
              <p>branch or end of chain =&gt; do not end to roots</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								top = <span class="hljs-number">0</span>;
								<span class="hljs-keyword">break</span>;
							}
							result.push(top.cls);
							--clsCount;
						}
						<span class="hljs-keyword">if</span> (top) {</pre></div></div>
            
        </li>
        
        
        <li id="section-401">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-401">&#182;</a>
              </div>
              <p>branch</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = refs.length; i &lt; l; ++i) {
								top = refs[i];
								<span class="hljs-keyword">if</span> (!--top.count) {
									roots.push(top);
								}
							}
						}
					}
					<span class="hljs-keyword">if</span> (clsCount) {
						err(<span class="hljs-string">'can\'t build consistent linearization'</span>, className);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-402">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-402">&#182;</a>
              </div>
              <p>calculate the superclass offset</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					base = bases[<span class="hljs-number">0</span>];
					result[<span class="hljs-number">0</span>] = base ? base._meta &amp;&amp; base === result[result.length - base._meta.bases.length] ? base._meta.bases.length : <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
					<span class="hljs-keyword">return</span> result;
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inherited</span><span class="hljs-params">(args, a, f)</span> {</span>
					<span class="hljs-keyword">var</span> name, chains, bases, caller, meta, base, proto, opf, pos, cache = <span class="hljs-keyword">this</span>._inherited = <span class="hljs-keyword">this</span>._inherited || {};</pre></div></div>
            
        </li>
        
        
        <li id="section-403">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-403">&#182;</a>
              </div>
              <p>crack arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args === <span class="hljs-string">'string'</span>) {
						name = args;
						args = a;
						a = f;
					}
					f = <span class="hljs-number">0</span>;
					caller = args.callee;
					name = name || caller.nom;
					<span class="hljs-keyword">if</span> (!name) {
						err(<span class="hljs-string">'can\'t deduce a name to call inherited()'</span>, <span class="hljs-keyword">this</span>.declaredClass);
					}
					meta = <span class="hljs-keyword">this</span>.constructor._meta;
					bases = meta.bases;
					pos = cache.p;
					<span class="hljs-keyword">if</span> (name !== cname) {</pre></div></div>
            
        </li>
        
        
        <li id="section-404">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-404">&#182;</a>
              </div>
              <p>method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (cache.c !== caller) {</pre></div></div>
            
        </li>
        
        
        <li id="section-405">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-405">&#182;</a>
              </div>
              <p>cache bust</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							pos = <span class="hljs-number">0</span>;
							base = bases[<span class="hljs-number">0</span>];
							meta = base._meta;
							<span class="hljs-keyword">if</span> (meta.hidden[name] !== caller) {</pre></div></div>
            
        </li>
        
        
        <li id="section-406">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-406">&#182;</a>
              </div>
              <p>error detection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								chains = meta.chains;
								<span class="hljs-keyword">if</span> (chains &amp;&amp; <span class="hljs-keyword">typeof</span> chains[name] === <span class="hljs-string">'string'</span>) {
									err(<span class="hljs-string">'calling chained method with inherited: '</span> + name, <span class="hljs-keyword">this</span>.declaredClass);
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-407">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-407">&#182;</a>
              </div>
              <p>find caller</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">do</span> {
									meta = base._meta;
									proto = base.prototype;
									<span class="hljs-keyword">if</span> (meta &amp;&amp; (proto[name] === caller &amp;&amp; proto.hasOwnProperty(name) || meta.hidden[name] === caller)) {
										<span class="hljs-keyword">break</span>;
									}
								} <span class="hljs-keyword">while</span> (base = bases[++pos]);</pre></div></div>
            
        </li>
        
        
        <li id="section-408">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-408">&#182;</a>
              </div>
              <p>intentional assignment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								pos = base ? pos : -<span class="hljs-number">1</span>;
							}
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-409">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-409">&#182;</a>
              </div>
              <p>find next</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						base = bases[++pos];
						<span class="hljs-keyword">if</span> (base) {
							proto = base.prototype;
							<span class="hljs-keyword">if</span> (base._meta &amp;&amp; proto.hasOwnProperty(name)) {
								f = proto[name];
							} <span class="hljs-keyword">else</span> {
								opf = op[name];
								<span class="hljs-keyword">do</span> {
									proto = base.prototype;
									f = proto[name];
									<span class="hljs-keyword">if</span> (f &amp;&amp; (base._meta ? proto.hasOwnProperty(name) : f !== opf)) {
										<span class="hljs-keyword">break</span>;
									}
								} <span class="hljs-keyword">while</span> (base = bases[++pos]); <span class="hljs-comment">// intentional assignment</span>
							}
						}
						f = base &amp;&amp; f || op[name];
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-410">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-410">&#182;</a>
              </div>
              <p>constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (cache.c !== caller) {</pre></div></div>
            
        </li>
        
        
        <li id="section-411">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-411">&#182;</a>
              </div>
              <p>cache bust</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							pos = <span class="hljs-number">0</span>;
							meta = bases[<span class="hljs-number">0</span>]._meta;
							<span class="hljs-keyword">if</span> (meta &amp;&amp; meta.ctor !== caller) {</pre></div></div>
            
        </li>
        
        
        <li id="section-412">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-412">&#182;</a>
              </div>
              <p>error detection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								chains = meta.chains;
								<span class="hljs-keyword">if</span> (!chains || chains.constructor !== <span class="hljs-string">'manual'</span>) {
									err(<span class="hljs-string">'calling chained constructor with inherited'</span>, <span class="hljs-keyword">this</span>.declaredClass);
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-413">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-413">&#182;</a>
              </div>
              <p>find caller</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">while</span> (base = bases[++pos]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-414">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-414">&#182;</a>
              </div>
              <p>intentional assignment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									meta = base._meta;
									<span class="hljs-keyword">if</span> (meta &amp;&amp; meta.ctor === caller) {
										<span class="hljs-keyword">break</span>;
									}
								}
								pos = base ? pos : -<span class="hljs-number">1</span>;
							}
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-415">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-415">&#182;</a>
              </div>
              <p>find next</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">while</span> (base = bases[++pos]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-416">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-416">&#182;</a>
              </div>
              <p>intentional assignment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							meta = base._meta;
							f = meta ? meta.ctor : base;
							<span class="hljs-keyword">if</span> (f) {
								<span class="hljs-keyword">break</span>;
							}
						}
						f = base &amp;&amp; f;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-417">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-417">&#182;</a>
              </div>
              <p>cache the found super method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					cache.c = f;
					cache.p = pos;</pre></div></div>
            
        </li>
        
        
        <li id="section-418">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-418">&#182;</a>
              </div>
              <p>now we have the result</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (f) {
						<span class="hljs-keyword">return</span> a === <span class="hljs-literal">true</span> ? f : f.apply(<span class="hljs-keyword">this</span>, a || args);
					} <span class="hljs-comment">// intentionally no return if a super method was not found</span>
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInherited</span><span class="hljs-params">(name, args)</span> {</span>
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">'string'</span>) {
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__inherited(name, args, <span class="hljs-literal">true</span>);
					}
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__inherited(name, <span class="hljs-literal">true</span>);
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inherited__debug</span><span class="hljs-params">(args, a1, a2)</span> {</span>
					<span class="hljs-keyword">var</span> f = <span class="hljs-keyword">this</span>.getInherited(args, a1);
					<span class="hljs-keyword">if</span> (f) {
						<span class="hljs-keyword">return</span> f.apply(<span class="hljs-keyword">this</span>, a2 || a1 || args);
					} <span class="hljs-comment">// intentionally no return if a super method was not found</span>
				}
				<span class="hljs-keyword">var</span> inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;</pre></div></div>
            
        </li>
        
        
        <li id="section-419">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-419">&#182;</a>
              </div>
              <p>emulation of “instanceof”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInstanceOf</span><span class="hljs-params">(cls)</span> {</span>
					<span class="hljs-keyword">var</span> bases = <span class="hljs-keyword">this</span>.constructor._meta.bases;
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = bases.length; i &lt; l; ++i) {
						<span class="hljs-keyword">if</span> (bases[i] === cls) {
							<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
						}
					}
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> cls;
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mixOwn</span><span class="hljs-params">(target, source)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-420">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-420">&#182;</a>
              </div>
              <p>add props adding metadata for incoming functions skipping a constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> source) {
						<span class="hljs-keyword">if</span> (name !== cname &amp;&amp; source.hasOwnProperty(name)) {
							target[name] = source[name];
						}
					}
					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'bug-for-in-skips-shadowed'</span>)) {
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> extraNames = lang._extraNames, i = extraNames.length; i;) {
							name = extraNames[--i];
							<span class="hljs-keyword">if</span> (name !== cname &amp;&amp; source.hasOwnProperty(name)) {
								target[name] = source[name];
							}
						}
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-421">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-421">&#182;</a>
              </div>
              <p>implementation of safe mixin function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeMixin</span><span class="hljs-params">(target, source)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-422">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-422">&#182;</a>
              </div>
              <p>summary:
    Mix in properties skipping a constructor and decorating functions
    like it is done by declare().
target: Object
    Target object to accept new properties.
source: Object
    Source object for new properties.
description:
    This function is used to mix in properties like lang.mixin does,
    but it skips a constructor property and decorates functions like
    declare() does.</p>
<pre><code>It is meant to be used <span class="hljs-keyword">with</span> classes and objects produced <span class="hljs-keyword">with</span>
declare. Functions mixed <span class="hljs-keyword">in</span> <span class="hljs-keyword">with</span> dojo.safeMixin can use
<span class="hljs-keyword">this</span>.inherited() like normal methods.

This <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is</span> <span class="hljs-title">used</span> <span class="hljs-title">to</span> <span class="hljs-title">implement</span> <span class="hljs-title">extend</span><span class="hljs-params">()</span> <span class="hljs-title">method</span> <span class="hljs-title">of</span> <span class="hljs-title">a</span> <span class="hljs-title">constructor</span>
<span class="hljs-title">produced</span> <span class="hljs-title">with</span> <span class="hljs-title">declare</span><span class="hljs-params">()</span>.</span>
</code></pre><p>example:
|    var A = declare(null, {
|        m1: function(){
|            console.log(“A.m1”);
|        },
|        m2: function(){
|            console.log(“A.m2”);
|        }
|    });
|    var B = declare(A, {
|        m1: function(){
|            this.inherited(arguments);
|            console.log(“B.m1”);
|        }
|    });
|    B.extend({
|        m2: function(){
|            this.inherited(arguments);
|            console.log(“B.m2”);
|        }
|    });
|    var x = new B();
|    dojo.safeMixin(x, {
|        m1: function(){
|            this.inherited(arguments);
|            console.log(“X.m1”);
|        },
|        m2: function(){
|            this.inherited(arguments);
|            console.log(“X.m2”);
|        }
|    });
|    x.m2();
|    // prints:
|    // A.m1
|    // B.m1
|    // X.m1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> name, t;</pre></div></div>
            
        </li>
        
        
        <li id="section-423">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-423">&#182;</a>
              </div>
              <p>add props adding metadata for incoming functions skipping a constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> source) {
						t = source[name];
						<span class="hljs-keyword">if</span> ((t !== op[name] || !(name <span class="hljs-keyword">in</span> op)) &amp;&amp; name !== cname) {
							<span class="hljs-keyword">if</span> (opts.call(t) === <span class="hljs-string">'[object Function]'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-424">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-424">&#182;</a>
              </div>
              <p>non-trivial function method =&gt; attach its name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								t.nom = name;
							}
							target[name] = t;
						}
					}
					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'bug-for-in-skips-shadowed'</span>)) {
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> extraNames = lang._extraNames, i = extraNames.length; i;) {
							name = extraNames[--i];
							t = source[name];
							<span class="hljs-keyword">if</span> ((t !== op[name] || !(name <span class="hljs-keyword">in</span> op)) &amp;&amp; name !== cname) {
								<span class="hljs-keyword">if</span> (opts.call(t) === <span class="hljs-string">'[object Function]'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-425">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-425">&#182;</a>
              </div>
              <p>non-trivial function method =&gt; attach its name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									t.nom = name;
								}
								target[name] = t;
							}
						}
					}
					<span class="hljs-keyword">return</span> target;
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span><span class="hljs-params">(source)</span> {</span>
					declare.safeMixin(<span class="hljs-keyword">this</span>.prototype, source);
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSubclass</span><span class="hljs-params">(mixins)</span> {</span>
					<span class="hljs-keyword">return</span> declare([<span class="hljs-keyword">this</span>].concat(mixins));
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-426">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-426">&#182;</a>
              </div>
              <p>chained constructor compatible with the legacy declare()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainedConstructor</span><span class="hljs-params">(bases, ctorSpecial)</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">arguments</span>,
							args = a,
							a0 = a[<span class="hljs-number">0</span>],
							f, i, m, l = bases.length,
							preArgs;
						<span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> a.callee)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-427">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-427">&#182;</a>
              </div>
              <p>not called via new, so force it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> applyNew(a);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-428">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-428">&#182;</a>
              </div>
              <p>this._inherited = {};
perform the shaman’s rituals of the original declare()
1) call two types of the preamble</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (ctorSpecial &amp;&amp; (a0 &amp;&amp; a0.preamble || <span class="hljs-keyword">this</span>.preamble)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-429">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-429">&#182;</a>
              </div>
              <p>full blown ritual</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							preArgs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(bases.length);</pre></div></div>
            
        </li>
        
        
        <li id="section-430">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-430">&#182;</a>
              </div>
              <p>prepare parameters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							preArgs[<span class="hljs-number">0</span>] = a;
							<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;;) {</pre></div></div>
            
        </li>
        
        
        <li id="section-431">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-431">&#182;</a>
              </div>
              <p>process the preamble of the 1st argument</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								a0 = a[<span class="hljs-number">0</span>];
								<span class="hljs-keyword">if</span> (a0) {
									f = a0.preamble;
									<span class="hljs-keyword">if</span> (f) {
										a = f.apply(<span class="hljs-keyword">this</span>, a) || a;
									}
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-432">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-432">&#182;</a>
              </div>
              <p>process the preamble of this class</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								f = bases[i].prototype;
								f = f.hasOwnProperty(<span class="hljs-string">'preamble'</span>) &amp;&amp; f.preamble;
								<span class="hljs-keyword">if</span> (f) {
									a = f.apply(<span class="hljs-keyword">this</span>, a) || a;
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-433">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-433">&#182;</a>
              </div>
              <p>one peculiarity of the preamble:
it is called if it is not needed,
e.g., there is no constructor to call
let’s watch for the last constructor
(see ticket #9795)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (++i === l) {
									<span class="hljs-keyword">break</span>;
								}
								preArgs[i] = a;
							}
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-434">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-434">&#182;</a>
              </div>
              <p>2) call all non-trivial constructors using prepared arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (i = l - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
							f = bases[i];
							m = f._meta;
							f = m ? m.ctor : f;
							<span class="hljs-keyword">if</span> (f) {
								f.apply(<span class="hljs-keyword">this</span>, preArgs ? preArgs[i] : a);
							}
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-435">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-435">&#182;</a>
              </div>
              <p>3) continue the original ritual: call the postscript</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						f = <span class="hljs-keyword">this</span>.postscript;
						<span class="hljs-keyword">if</span> (f) {
							f.apply(<span class="hljs-keyword">this</span>, args);
						}
					};
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-436">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-436">&#182;</a>
              </div>
              <p>chained constructor compatible with the legacy declare()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">singleConstructor</span><span class="hljs-params">(ctor, ctorSpecial)</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">arguments</span>,
							t = a,
							a0 = a[<span class="hljs-number">0</span>],
							f;
						<span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> a.callee)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-437">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-437">&#182;</a>
              </div>
              <p>not called via new, so force it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> applyNew(a);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-438">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-438">&#182;</a>
              </div>
              <p>this._inherited = {};
perform the shaman’s rituals of the original declare()
1) call two types of the preamble</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (ctorSpecial) {</pre></div></div>
            
        </li>
        
        
        <li id="section-439">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-439">&#182;</a>
              </div>
              <p>full blown ritual</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (a0) {</pre></div></div>
            
        </li>
        
        
        <li id="section-440">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-440">&#182;</a>
              </div>
              <p>process the preamble of the 1st argument</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								f = a0.preamble;
								<span class="hljs-keyword">if</span> (f) {
									t = f.apply(<span class="hljs-keyword">this</span>, t) || t;
								}
							}
							f = <span class="hljs-keyword">this</span>.preamble;
							<span class="hljs-keyword">if</span> (f) {</pre></div></div>
            
        </li>
        
        
        <li id="section-441">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-441">&#182;</a>
              </div>
              <p>process the preamble of this class</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								f.apply(<span class="hljs-keyword">this</span>, t); <span class="hljs-comment">// one peculiarity of the preamble:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-442">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-442">&#182;</a>
              </div>
              <p>it is called even if it is not needed,
e.g., there is no constructor to call
let’s watch for the last constructor
(see ticket #9795)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							}
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-443">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-443">&#182;</a>
              </div>
              <p>2) call a constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (ctor) {
							ctor.apply(<span class="hljs-keyword">this</span>, a);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-444">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-444">&#182;</a>
              </div>
              <p>3) continue the original ritual: call the postscript</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						f = <span class="hljs-keyword">this</span>.postscript;
						<span class="hljs-keyword">if</span> (f) {
							f.apply(<span class="hljs-keyword">this</span>, a);
						}
					};
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-445">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-445">&#182;</a>
              </div>
              <p>plain vanilla constructor (can use inherited() to call its base constructor)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">simpleConstructor</span><span class="hljs-params">(bases)</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">arguments</span>,
							i = <span class="hljs-number">0</span>,
							f, m;
						<span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> a.callee)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-446">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-446">&#182;</a>
              </div>
              <p>not called via new, so force it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> applyNew(a);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-447">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-447">&#182;</a>
              </div>
              <p>this._inherited = {};
perform the shaman’s rituals of the original declare()
1) do not call the preamble
2) call the top constructor (it can use this.inherited())</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (; f = bases[i]; ++i) {</pre></div></div>
            
        </li>
        
        
        <li id="section-448">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-448">&#182;</a>
              </div>
              <p>intentional assignment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							m = f._meta;
							f = m ? m.ctor : f;
							<span class="hljs-keyword">if</span> (f) {
								f.apply(<span class="hljs-keyword">this</span>, a);
								<span class="hljs-keyword">break</span>;
							}
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-449">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-449">&#182;</a>
              </div>
              <p>3) call the postscript</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						f = <span class="hljs-keyword">this</span>.postscript;
						<span class="hljs-keyword">if</span> (f) {
							f.apply(<span class="hljs-keyword">this</span>, a);
						}
					};
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chain</span><span class="hljs-params">(name, bases, reversed)</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">var</span> b, m, f, i = <span class="hljs-number">0</span>,
							step = <span class="hljs-number">1</span>;
						<span class="hljs-keyword">if</span> (reversed) {
							i = bases.length - <span class="hljs-number">1</span>;
							step = -<span class="hljs-number">1</span>;
						}
						<span class="hljs-keyword">for</span> (; b = bases[i]; i += step) {</pre></div></div>
            
        </li>
        
        
        <li id="section-450">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-450">&#182;</a>
              </div>
              <p>intentional assignment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							m = b._meta;
							f = (m ? m.hidden : b.prototype)[name];
							<span class="hljs-keyword">if</span> (f) {
								f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
							}
						}
					};
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-451">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-451">&#182;</a>
              </div>
              <p>forceNew(ctor)
return a new object that inherits from ctor.prototype but
without actually running ctor on the object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forceNew</span><span class="hljs-params">(ctor)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-452">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-452">&#182;</a>
              </div>
              <p>create object with correct prototype using a do-nothing
constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					xtor.prototype = ctor.prototype;
					<span class="hljs-keyword">var</span> t = <span class="hljs-keyword">new</span> xtor();
					xtor.prototype = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-453">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-453">&#182;</a>
              </div>
              <p>clean up</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> t;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-454">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-454">&#182;</a>
              </div>
              <p>applyNew(args)
just like ‘new ctor()’ except that the constructor and its arguments come
from args, which must be an array or an arguments object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyNew</span><span class="hljs-params">(args)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-455">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-455">&#182;</a>
              </div>
              <p>create an object with ctor’s prototype but without
calling ctor on it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> ctor = args.callee,
						t = forceNew(ctor);</pre></div></div>
            
        </li>
        
        
        <li id="section-456">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-456">&#182;</a>
              </div>
              <p>execute the real constructor on the new object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					ctor.apply(t, args);
					<span class="hljs-keyword">return</span> t;
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">declare</span><span class="hljs-params">(className, superclass, props)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-457">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-457">&#182;</a>
              </div>
              <p>summary:
    Create a feature-rich constructor from compact notation.
className: String?
    The optional name of the constructor (loosely, a “class”)
    stored in the “declaredClass” property in the created prototype.
    It will be used as a global name for a created constructor.
superclass: Function|Function[]
    May be null, a Function, or an Array of Functions. This argument
    specifies a list of bases (the left-most one is the most deepest
    base).
props: Object
    An object whose properties are copied to the created prototype.
    Add an instance-initialization function by making it a property
    named “constructor”.
returns: dojo/_base/declare.__DeclareCreatedObject
    New constructor function.
description:
    Create a constructor using a compact notation for inheritance and
    prototype extension.</p>
<pre><code>Mixin ancestors provide a type of multiple inheritance.
Prototypes of mixin ancestors are copied to the new class:
changes to mixin prototypes will not affect classes to which
they have been mixed in.

Ancestors can be compound classes created by this version of
declare(). In complex cases all base classes are going to be
linearized according to C3 MRO algorithm
(see http://www.python.org/download/releases/2.3/mro/ for more
details).

&quot;className&quot; is cached in &quot;declaredClass&quot; property of the new class,
if it was supplied. The immediate super class will be cached in
&quot;superclass&quot; property of the new class.

Methods in &quot;props&quot; will be copied and modified: &quot;nom&quot; property
(the declared name of the method) will be added to all copied
functions to help identify them for the internal machinery. Be
very careful, while reusing methods: if you use the same
function under different names, it can produce errors in some
cases.

It is possible to use constructors created &quot;manually&quot; (without
declare()) as bases. They will be called as usual during the
creation of an instance, their methods will be chained, and even
called by &quot;this.inherited()&quot;.

Special property &quot;-chains-&quot; governs how to chain methods. It is
a dictionary, which uses method names as keys, and hint strings
as values. If a hint string is &quot;after&quot;, this method will be
called after methods of its base classes. If a hint string is
&quot;before&quot;, this method will be called before methods of its base
classes.

If &quot;constructor&quot; is not mentioned in &quot;-chains-&quot; property, it will
be chained using the legacy mode: using &quot;after&quot; chaining,
calling preamble() method before each constructor, if available,
and calling postscript() after all constructors were executed.
If the hint is &quot;after&quot;, it is chained as a regular method, but
postscript() will be called after the chain of constructors.
&quot;constructor&quot; cannot be chained &quot;before&quot;, but it allows
a special hint string: &quot;manual&quot;, which means that constructors
are not going to be chained in any way, and programmer will call
them manually using this.inherited(). In the latter case
postscript() will be called after the construction.

All chaining hints are &quot;inherited&quot; from base classes and
potentially can be overridden. Be very careful when overriding
hints! Make sure that all chained methods can work in a proposed
manner of chaining.

Once a method was chained, it is impossible to unchain it. The
only exception is &quot;constructor&quot;. You don&#39;t need to define a
method in order to supply a chaining hint.

If a method is chained, it cannot use this.inherited() because
all other methods in the hierarchy will be called automatically.

Usually constructors and initializers of any kind are chained
using &quot;after&quot; and destructors of any kind are chained as
&quot;before&quot;. Note that chaining assumes that chained methods do not
return any value: any returned value will be discarded.
</code></pre><p>example:
|    declare(“my.classes.bar”, my.classes.foo, {
|        // properties to be added to the class prototype
|        someValue: 2,
|        // initialization function
|        constructor: function(){
|            this.myComplicatedObject = new ReallyComplicatedObject();
|        },
|        // other functions
|        someMethod: function(){
|            doStuff();
|        }
|    });</p>
<p>example:
|    var MyBase = declare(null, {
|        // constructor, properties, and methods go here
|        // …
|    });
|    var MyClass1 = declare(MyBase, {
|        // constructor, properties, and methods go here
|        // …
|    });
|    var MyClass2 = declare(MyBase, {
|        // constructor, properties, and methods go here
|        // …
|    });
|    var MyDiamond = declare([MyClass1, MyClass2], {
|        // constructor, properties, and methods go here
|        // …
|    });</p>
<p>example:
|    var F = function(){ console.log(“raw constructor”); };
|    F.prototype.method = function(){
|        console.log(“raw method”);
|    };
|    var A = declare(F, {
|        constructor: function(){
|            console.log(“A.constructor”);
|        },
|        method: function(){
|            console.log(“before calling F.method…”);
|            this.inherited(arguments);
|            console.log(“…back in A”);
|        }
|    });
|    new A().method();
|    // will print:
|    // raw constructor
|    // A.constructor
|    // before calling F.method…
|    // raw method
|    // …back in A</p>
<p>example:
|    var A = declare(null, {
|        “-chains-“: {
|            destroy: “before”
|        }
|    });
|    var B = declare(A, {
|        constructor: function(){
|            console.log(“B.constructor”);
|        },
|        destroy: function(){
|            console.log(“B.destroy”);
|        }
|    });
|    var C = declare(B, {
|        constructor: function(){
|            console.log(“C.constructor”);
|        },
|        destroy: function(){
|            console.log(“C.destroy”);
|        }
|    });
|    new C().destroy();
|    // prints:
|    // B.constructor
|    // C.constructor
|    // C.destroy
|    // B.destroy</p>
<p>example:
|    var A = declare(null, {
|        “-chains-“: {
|            constructor: “manual”
|        }
|    });
|    var B = declare(A, {
|        constructor: function(){
|            // …
|            // call the base constructor with new parameters
|            this.inherited(arguments, [1, 2, 3]);
|            // …
|        }
|    });</p>
<p>example:
|    var A = declare(null, {
|        “-chains-“: {
|            m1: “before”
|        },
|        m1: function(){
|            console.log(“A.m1”);
|        },
|        m2: function(){
|            console.log(“A.m2”);
|        }
|    });
|    var B = declare(A, {
|        “-chains-“: {
|            m2: “after”
|        },
|        m1: function(){
|            console.log(“B.m1”);
|        },
|        m2: function(){
|            console.log(“B.m2”);
|        }
|    });
|    var x = new B();
|    x.m1();
|    // prints:
|    // B.m1
|    // A.m1
|    x.m2();
|    // prints:
|    // A.m2
|    // B.m2
crack parameters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> className !== <span class="hljs-string">'string'</span>) {
						props = superclass;
						superclass = className;
						className = <span class="hljs-string">''</span>;
					}
					props = props || {};
					<span class="hljs-keyword">var</span> proto, i, t, ctor, name, bases, chains, mixins = <span class="hljs-number">1</span>,
						parents = superclass;</pre></div></div>
            
        </li>
        
        
        <li id="section-458">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-458">&#182;</a>
              </div>
              <p>build a prototype</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (opts.call(superclass) === <span class="hljs-string">'[object Array]'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-459">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-459">&#182;</a>
              </div>
              <p>C3 MRO</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						bases = c3mro(superclass, className);
						t = bases[<span class="hljs-number">0</span>];
						mixins = bases.length - t;
						superclass = bases[mixins];
					} <span class="hljs-keyword">else</span> {
						bases = [<span class="hljs-number">0</span>];
						<span class="hljs-keyword">if</span> (superclass) {
							<span class="hljs-keyword">if</span> (opts.call(superclass) === <span class="hljs-string">'[object Function]'</span>) {
								t = superclass._meta;
								bases = bases.concat(t ? t.bases : superclass);
							} <span class="hljs-keyword">else</span> {
								err(<span class="hljs-string">'base class is not a callable constructor.'</span>, className);
							}
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (superclass !== <span class="hljs-literal">null</span>) {
							err(<span class="hljs-string">'unknown base class. Did you use dojo.require to pull it in?'</span>, className);
						}
					}
					<span class="hljs-keyword">if</span> (superclass) {
						<span class="hljs-keyword">for</span> (i = mixins - <span class="hljs-number">1</span>;; --i) {
							proto = forceNew(superclass);
							<span class="hljs-keyword">if</span> (!i) {</pre></div></div>
            
        </li>
        
        
        <li id="section-460">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-460">&#182;</a>
              </div>
              <p>stop if nothing to add (the last base)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">break</span>;
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-461">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-461">&#182;</a>
              </div>
              <p>mix in properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							t = bases[i];
							(t._meta ? mixOwn : mix)(proto, t.prototype);</pre></div></div>
            
        </li>
        
        
        <li id="section-462">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-462">&#182;</a>
              </div>
              <p>chain in new constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							ctor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>();
							ctor.superclass = superclass;
							ctor.prototype = proto;
							superclass = proto.constructor = ctor;
						}
					} <span class="hljs-keyword">else</span> {
						proto = {};
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-463">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-463">&#182;</a>
              </div>
              <p>add all properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					declare.safeMixin(proto, props);</pre></div></div>
            
        </li>
        
        
        <li id="section-464">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-464">&#182;</a>
              </div>
              <p>add constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					t = props.constructor;
					<span class="hljs-keyword">if</span> (t !== op.constructor) {
						t.nom = cname;
						proto.constructor = t;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-465">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-465">&#182;</a>
              </div>
              <p>collect chains and flags</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">for</span> (i = mixins - <span class="hljs-number">1</span>; i; --i) {</pre></div></div>
            
        </li>
        
        
        <li id="section-466">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-466">&#182;</a>
              </div>
              <p>intentional assignment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						t = bases[i]._meta;
						<span class="hljs-keyword">if</span> (t &amp;&amp; t.chains) {
							chains = mix(chains || {}, t.chains);
						}
					}
					<span class="hljs-keyword">if</span> (proto[<span class="hljs-string">'-chains-'</span>]) {
						chains = mix(chains || {}, proto[<span class="hljs-string">'-chains-'</span>]);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-467">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-467">&#182;</a>
              </div>
              <p>build ctor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					t = !chains || !chains.hasOwnProperty(cname);
					bases[<span class="hljs-number">0</span>] = ctor = chains &amp;&amp; chains.constructor === <span class="hljs-string">'manual'</span> ? simpleConstructor(bases) : bases.length === <span class="hljs-number">1</span> ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t);</pre></div></div>
            
        </li>
        
        
        <li id="section-468">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-468">&#182;</a>
              </div>
              <p>add meta information to the constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					ctor._meta = {
						bases: bases,
						hidden: props,
						chains: chains,
						parents: parents,
						ctor: props.constructor
					};
					ctor.superclass = superclass &amp;&amp; superclass.prototype;
					ctor.extend = extend;
					ctor.createSubclass = createSubclass;
					ctor.prototype = proto;
					proto.constructor = ctor;</pre></div></div>
            
        </li>
        
        
        <li id="section-469">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-469">&#182;</a>
              </div>
              <p>add “standard” methods to the prototype</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					proto.getInherited = getInherited;
					proto.isInstanceOf = isInstanceOf;
					proto.inherited = inheritedImpl;
					proto.__inherited = inherited;</pre></div></div>
            
        </li>
        
        
        <li id="section-470">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-470">&#182;</a>
              </div>
              <p>add name if specified</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (className) {
						proto.declaredClass = className;
						lang.setObject(className, ctor);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-471">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-471">&#182;</a>
              </div>
              <p>build chains and add them to the prototype</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (chains) {
						<span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> chains) {
							<span class="hljs-keyword">if</span> (proto[name] &amp;&amp; <span class="hljs-keyword">typeof</span> chains[name] === <span class="hljs-string">'string'</span> &amp;&amp; name !== cname) {
								t = proto[name] = chain(name, bases, chains[name] === <span class="hljs-string">'after'</span>);
								t.nom = name;
							}
						}
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-472">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-472">&#182;</a>
              </div>
              <p>chained methods do not return values
no need to chain “invisible” functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> ctor; <span class="hljs-comment">// Function</span>
				}
				<span class="hljs-comment">/*=====
             declare.__DeclareCreatedObject = {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-473">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-473">&#182;</a>
              </div>
              <p>summary:
    dojo/_base/declare() returns a constructor <code>C</code>.   <code>new C()</code> returns an Object with the following
    methods, in addition to the methods and properties specified via the arguments passed to declare().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
             inherited: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, args, newArgs)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-474">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-474">&#182;</a>
              </div>
              <p>summary:
    Calls a super method.
name: String?
    The optional method name. Should be the same as the caller’s
    name. Usually “name” is specified in complex dynamic cases, when
    the calling method was dynamically added, undecorated by
    declare(), and it cannot be determined.
args: Arguments
    The caller supply this argument, which should be the original
    “arguments”.
newArgs: Object?
    If “true”, the found function will be returned without
    executing it.
    If Array, it will be used to call a super method. Otherwise
    “args” will be used.
returns:
    Whatever is returned by a super method, or a super method itself,
    if “true” was specified as newArgs.
description:
    This method is used inside method of classes produced with
    declare() to call a super method (next in the chain). It is
    used for manually controlled chaining. Consider using the regular
    chaining, because it is faster. Use “this.inherited()” only in
    complex cases.</p>
<pre><code>This method cannot me called from automatically chained
constructors including the <span class="hljs-keyword">case</span> of a special (legacy)
constructor chaining. It cannot be called from chained methods.

If <span class="hljs-string">"this.inherited()"</span> cannot find the next-<span class="hljs-keyword">in</span>-chain method, it
does nothing and returns <span class="hljs-string">"undefined"</span>. The last method <span class="hljs-keyword">in</span> chain
can be a <span class="hljs-keyword">default</span> method implemented <span class="hljs-keyword">in</span> <span class="hljs-built_in">Object</span>, which will be
called last.

If <span class="hljs-string">"name"</span> is specified, it is assumed that the method that
received <span class="hljs-string">"args"</span> is the parent method <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> call. It is looked
up <span class="hljs-keyword">in</span> the chain list and <span class="hljs-keyword">if</span> it is found the next-<span class="hljs-keyword">in</span>-chain method
is called. If it is not found, the first-<span class="hljs-keyword">in</span>-chain method is
called.

If <span class="hljs-string">"name"</span> is not specified, it will be derived from the calling
method (using a methoid property <span class="hljs-string">"nom"</span>).
</code></pre><p>example:
|    var B = declare(A, {
|        method1: function(a, b, c){
|            this.inherited(arguments);
|        },
|        method2: function(a, b){
|            return this.inherited(arguments, [a + b]);
|        }
|    });
|    // next method is not in the chain list because it is added
|    // manually after the class was created.
|    B.prototype.method3 = function(){
|        console.log(“This is a dynamically-added method.”);
|        this.inherited(“method3”, arguments);
|    };
example:
|    var B = declare(A, {
|        method: function(a, b){
|            var super = this.inherited(arguments, true);
|            // …
|            if(!super){
|                console.log(“there is no super method”);
|                return 0;
|            }
|            return super.apply(this, arguments);
|        }
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             <span class="hljs-keyword">return</span>	{};	<span class="hljs-comment">// Object</span>
             },

             getInherited: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, args)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-475">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-475">&#182;</a>
              </div>
              <p>summary:
    Returns a super method.
name: String?
    The optional method name. Should be the same as the caller’s
    name. Usually “name” is specified in complex dynamic cases, when
    the calling method was dynamically added, undecorated by
    declare(), and it cannot be determined.
args: Arguments
    The caller supply this argument, which should be the original
    “arguments”.
returns:
    Returns a super method (Function) or “undefined”.
description:
    This method is a convenience method for “this.inherited()”.
    It uses the same algorithm but instead of executing a super
    method, it returns it, or “undefined” if not found.</p>
<p>example:
|    var B = declare(A, {
|        method: function(a, b){
|            var super = this.getInherited(arguments);
|            // …
|            if(!super){
|                console.log(“there is no super method”);
|                return 0;
|            }
|            return super.apply(this, arguments);
|        }
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             <span class="hljs-keyword">return</span>	{};	<span class="hljs-comment">// Object</span>
             },

             isInstanceOf: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cls)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-476">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-476">&#182;</a>
              </div>
              <p>summary:
    Checks the inheritance chain to see if it is inherited from this
    class.
cls: Function
    Class constructor.
returns:
    “true”, if this object is inherited from this class, “false”
    otherwise.
description:
    This method is used with instances of classes produced with
    declare() to determine of they support a certain interface or
    not. It models “instanceof” operator.</p>
<p>example:
|    var A = declare(null, {
|        // constructor, properties, and methods go here
|        // …
|    });
|    var B = declare(null, {
|        // constructor, properties, and methods go here
|        // …
|    });
|    var C = declare([A, B], {
|        // constructor, properties, and methods go here
|        // …
|    });
|    var D = declare(A, {
|        // constructor, properties, and methods go here
|        // …
|    });
|
|    var a = new A(), b = new B(), c = new C(), d = new D();
|
|    console.log(a.isInstanceOf(A)); // true
|    console.log(b.isInstanceOf(A)); // false
|    console.log(c.isInstanceOf(A)); // true
|    console.log(d.isInstanceOf(A)); // true
|
|    console.log(a.isInstanceOf(B)); // false
|    console.log(b.isInstanceOf(B)); // true
|    console.log(c.isInstanceOf(B)); // true
|    console.log(d.isInstanceOf(B)); // false
|
|    console.log(a.isInstanceOf(C)); // false
|    console.log(b.isInstanceOf(C)); // false
|    console.log(c.isInstanceOf(C)); // true
|    console.log(d.isInstanceOf(C)); // false
|
|    console.log(a.isInstanceOf(D)); // false
|    console.log(b.isInstanceOf(D)); // false
|    console.log(c.isInstanceOf(D)); // false
|    console.log(d.isInstanceOf(D)); // true</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             <span class="hljs-keyword">return</span>	{};	<span class="hljs-comment">// Object</span>
             },

             extend: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(source)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-477">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-477">&#182;</a>
              </div>
              <p>summary:
    Adds all properties and methods of source to constructor’s
    prototype, making them available to all instances created with
    constructor. This method is specific to constructors created with
    declare().
source: Object
    Source object which properties are going to be copied to the
    constructor’s prototype.
description:
    Adds source properties to the constructor’s prototype. It can
    override existing properties.</p>
<pre><code>This method is similar to dojo.extend <span class="hljs-function"><span class="hljs-keyword">function</span>, <span class="hljs-title">but</span> <span class="hljs-title">it</span> <span class="hljs-title">is</span> <span class="hljs-title">specific</span>
<span class="hljs-title">to</span> <span class="hljs-title">constructors</span> <span class="hljs-title">produced</span> <span class="hljs-title">by</span> <span class="hljs-title">declare</span><span class="hljs-params">()</span>. <span class="hljs-title">It</span> <span class="hljs-title">is</span> <span class="hljs-title">implemented</span>
<span class="hljs-title">using</span> <span class="hljs-title">dojo</span>.<span class="hljs-title">safeMixin</span>, <span class="hljs-title">and</span> <span class="hljs-title">it</span> <span class="hljs-title">skips</span> <span class="hljs-title">a</span> <span class="hljs-title">constructor</span> <span class="hljs-title">property</span>,
<span class="hljs-title">and</span> <span class="hljs-title">properly</span> <span class="hljs-title">decorates</span> <span class="hljs-title">copied</span> <span class="hljs-title">functions</span>.</span>
</code></pre><p>example:
|    var A = declare(null, {
|        m1: function(){},
|        s1: “Popokatepetl”
|    });
|    A.extend({
|        m1: function(){},
|        m2: function(){},
|        f1: true,
|        d1: 42
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             }
             };
             =====*/</pre></div></div>
            
        </li>
        
        
        <li id="section-478">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-478">&#182;</a>
              </div>
              <p>For back-compat, remove for 2.0</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo.safeMixin = declare.safeMixin = safeMixin;
				dojo.declare = declare;
				<span class="hljs-keyword">return</span> declare;
			});
		},
		<span class="hljs-string">'dojo/dom'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./sniff'</span>,
				<span class="hljs-string">'./_base/lang'</span>,
				<span class="hljs-string">'./_base/window'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(has, lang, win)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-479">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-479">&#182;</a>
              </div>
              <p>module:
    dojo/dom
FIXME: need to add unit tests for all the semi-public methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>) &lt;= <span class="hljs-number">7</span>) {
					<span class="hljs-keyword">try</span> {
						document.execCommand(<span class="hljs-string">'BackgroundImageCache'</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
					} <span class="hljs-keyword">catch</span> (e) {}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-480">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-480">&#182;</a>
              </div>
              <p>=============================</p>

            </div>
            
        </li>
        
        
        <li id="section-481">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-481">&#182;</a>
              </div>
              <h1 id="dom-functions">DOM Functions</h1>

            </div>
            
        </li>
        
        
        <li id="section-482">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-482">&#182;</a>
              </div>
              <p>the result object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> dom = {};
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>)) {
					dom.byId = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, doc)</span> {</span>
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> id !== <span class="hljs-string">'string'</span>) {
							<span class="hljs-keyword">return</span> id;
						}
						<span class="hljs-keyword">var</span> _d = doc || win.doc,
							te = id &amp;&amp; _d.getElementById(id);</pre></div></div>
            
        </li>
        
        
        <li id="section-483">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-483">&#182;</a>
              </div>
              <p>attributes.id.value is better than just id in case the
user has a name=id inside a form</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (te &amp;&amp; (te.attributes.id.value === id || te.id === id)) {
							<span class="hljs-keyword">return</span> te;
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">var</span> eles = _d.all[id];
							<span class="hljs-keyword">if</span> (!eles || eles.nodeName) {
								eles = [eles];
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-484">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-484">&#182;</a>
              </div>
              <p>if more than 1, choose first with the correct id</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
							<span class="hljs-keyword">while</span> (te = eles[i++]) {
								<span class="hljs-keyword">if</span> (te.attributes &amp;&amp; te.attributes.id &amp;&amp; te.attributes.id.value === id || te.id === id) {
									<span class="hljs-keyword">return</span> te;
								}
							}
						}
					};
				} <span class="hljs-keyword">else</span> {
					dom.byId = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, doc)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-485">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-485">&#182;</a>
              </div>
              <p>inline’d type check.
be sure to return null per documentation, to match IE branch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> id === <span class="hljs-string">'string'</span> ? (doc || win.doc)
							.getElementById(id) : id) || <span class="hljs-literal">null</span>; <span class="hljs-comment">// DOMNode</span>
					};
				}
				<span class="hljs-comment">/*=====
                 dom.byId = function(id, doc){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-486">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-486">&#182;</a>
              </div>
              <p>summary:
    Returns DOM node with matching <code>id</code> attribute or falsy value (ex: null or undefined)
    if not found.  If <code>id</code> is a DomNode, this function is a no-op.</p>
<p>id: String|DOMNode
    A string to match an HTML id attribute or a reference to a DOM Node</p>
<p>doc: Document?
    Document to work in. Defaults to the current value of
    dojo.doc.  Can be used to retrieve
    node references from other documents.</p>
<p>example:
    Look up a node by ID:
|    var n = dojo.byId(“foo”);</p>
<p>example:
    Check if a node exists, and use it.
|    var n = dojo.byId(“bar”);
|    if(n){ doStuff() … }</p>
<p>example:
    Allow string or DomNode references to be passed to a custom function:
|    var foo = function(nodeOrId){
|        nodeOrId = dojo.byId(nodeOrId);
|        // … more stuff
|    }</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                 };
                 =====*/
				dom.isDescendant = function (node, ancestor) {</pre></div></div>
            
        </li>
        
        
        <li id="section-487">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-487">&#182;</a>
              </div>
              <p>summary:
    Returns true if node is a descendant of ancestor
node: DOMNode|String
    string id or node reference to test
ancestor: DOMNode|String
    string id or node reference of potential parent to test against</p>
<p>example:
    Test is node id=”bar” is a descendant of node id=”foo”
|    if(dojo.isDescendant(“bar”, “foo”)){ … }</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">try</span> {
						node = dom.byId(node);
						ancestor = dom.byId(ancestor);
						<span class="hljs-keyword">while</span> (node) {
							<span class="hljs-keyword">if</span> (node === ancestor) {
								<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// Boolean</span>
							}
							node = node.parentNode;
						}
					} <span class="hljs-keyword">catch</span> (e) {}
					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Boolean</span>
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-488">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-488">&#182;</a>
              </div>
              <p>TODO: do we need this function in the base?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dom.setSelectable = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, selectable)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-489">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-489">&#182;</a>
              </div>
              <p>summary:
    Enable or disable selection on a node
node: DOMNode|String
    id or reference to node
selectable: Boolean
    state to put the node in. false indicates unselectable, true
    allows selection.
example:
    Make the node id=”bar” unselectable
|    dojo.setSelectable(“bar”);
example:
    Make the node id=”bar” selectable
|    dojo.setSelectable(“bar”, true);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'mozilla'</span>)) {
						node.style.MozUserSelect = selectable ? <span class="hljs-string">''</span> : <span class="hljs-string">'none'</span>;
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (has(<span class="hljs-string">'khtml'</span>) || has(<span class="hljs-string">'webkit'</span>)) {
						node.style.KhtmlUserSelect = selectable ? <span class="hljs-string">'auto'</span> : <span class="hljs-string">'none'</span>;
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>)) {
						<span class="hljs-keyword">var</span> v = node.unselectable = selectable ? <span class="hljs-string">''</span> : <span class="hljs-string">'on'</span>,
							cs = node.getElementsByTagName(<span class="hljs-string">'*'</span>),
							i = <span class="hljs-number">0</span>,
							l = cs.length;
						<span class="hljs-keyword">for</span> (; i &lt; l; ++i) {
							cs.item(i)
								.unselectable = v;
						}
					} <span class="hljs-comment">//FIXME: else?  Opera?</span>
				};
				<span class="hljs-keyword">return</span> dom;
			});
		},
		<span class="hljs-string">'dojo/_base/browser'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">require</span>.has) {
				<span class="hljs-built_in">require</span>.has.add(<span class="hljs-string">'config-selectorEngine'</span>, <span class="hljs-string">'acme'</span>);
			}
			define([
				<span class="hljs-string">'../ready'</span>,
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'./connect'</span>,
				<span class="hljs-string">'./unload'</span>,
				<span class="hljs-string">'./window'</span>,
				<span class="hljs-string">'./event'</span>,
				<span class="hljs-string">'./html'</span>,
				<span class="hljs-string">'./NodeList'</span>,
				<span class="hljs-string">'../query'</span>,
				<span class="hljs-string">'./xhr'</span>,
				<span class="hljs-string">'./fx'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-490">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-490">&#182;</a>
              </div>
              <p>module:
    dojo/_base/browser</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             return {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-491">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-491">&#182;</a>
              </div>
              <p>summary:
    This module causes the browser-only base modules to be loaded.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				return dojo;
			});
		},
		'dojo/selector/acme': function () {
			define([
				'../dom',
				'../sniff',
				'../_base/array',
				'../_base/lang',
				'../_base/window'
			], function (dom, has, array, lang, win) {</pre></div></div>
            
        </li>
        
        
        <li id="section-492">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-492">&#182;</a>
              </div>
              <p>module:
    dojo/selector/acme</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*
             acme architectural overview:

             acme is a relatively full-featured CSS3 query library. It is
             designed to take any valid CSS3 selector and return the nodes matching
             the selector. To do this quickly, it processes queries in several
             steps, applying caching where profitable.

             The steps (roughly in reverse order of the way they appear in the code):
             1.) check to see if we already have a "query dispatcher"
             - if so, use that with the given parameterization. Skip to step 4.
             2.) attempt to determine which branch to dispatch the query to:
             - JS (optimized DOM iteration)
             - native (FF3.1+, Safari 3.1+, IE 8+)
             3.) tokenize and convert to executable "query dispatcher"
             - this is where the lion's share of the complexity in the
             system lies. In the DOM version, the query dispatcher is
             assembled as a chain of "yes/no" test functions pertaining to
             a section of a simple query statement (".blah:nth-child(odd)"
             but not "div div", which is 2 simple statements). Individual
             statement dispatchers are cached (to prevent re-definition)
             as are entire dispatch chains (to make re-execution of the
             same query fast)
             4.) the resulting query dispatcher is called in the passed scope
             (by default the top-level document)
             - for DOM queries, this results in a recursive, top-down
             evaluation of nodes based on each simple query section
             - for native implementations, this may mean working around spec
             bugs. So be it.
             5.) matched nodes are pruned to ensure they are unique (if necessary)
             */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-493">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-493">&#182;</a>
              </div>
              <p>//////////////////////////////////////////////////////////////////////
Toolkit aliases
//////////////////////////////////////////////////////////////////////
if you are extracting acme for use in your own system, you will
need to provide these methods and properties. No other porting should be
necessary, save for configuring the system to use a class other than
dojo/NodeList as the return instance instantiator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> trim = lang.trim;
				<span class="hljs-keyword">var</span> each = array.forEach;
				<span class="hljs-keyword">var</span> getDoc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">return</span> win.doc;
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-494">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-494">&#182;</a>
              </div>
              <p>NOTE(alex): the spec is idiotic. CSS queries should ALWAYS be case-sensitive, but nooooooo</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> cssCaseBug = getDoc()
					.compatMode === <span class="hljs-string">'BackCompat'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-495">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-495">&#182;</a>
              </div>
              <p>//////////////////////////////////////////////////////////////////////
Global utilities
//////////////////////////////////////////////////////////////////////</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> specials = <span class="hljs-string">'&gt;~+'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-496">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-496">&#182;</a>
              </div>
              <p>global thunk to determine whether we should treat the current query as
case sensitive or not. This switch is flipped by the query evaluator
based on the document passed as the context to search.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> caseSensitive = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-497">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-497">&#182;</a>
              </div>
              <p>how high?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> yesman = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-498">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-498">&#182;</a>
              </div>
              <p>//////////////////////////////////////////////////////////////////////
Tokenizer
//////////////////////////////////////////////////////////////////////</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> getQueryParts = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-499">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-499">&#182;</a>
              </div>
              <p>summary:
    state machine for query tokenization
description:
    instead of using a brittle and slow regex-based CSS parser,
    acme implements an AST-style query representation. This
    representation is only generated once per query. For example,
    the same query run multiple times or under different root nodes
    does not re-parse the selector expression but instead uses the
    cached data structure. The state machine implemented here
    terminates on the last “ “ (space) character and returns an
    ordered array of query component structures (or “parts”). Each
    part represents an operator or a simple CSS filtering
    expression. The structure for parts is documented in the code
    below.
NOTE:
    this code is designed to run fast and compress well. Sacrifices
    to readability and maintainability have been made.  Your best
    bet when hacking the tokenizer is to put The Donnas on <em>really</em>
    loud (may we recommend their “Spend The Night” release?) and
    just assume you’re gonna make mistakes. Keep the unit tests
    open and run them frequently. Knowing is half the battle ;-)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (specials.indexOf(query.slice(-<span class="hljs-number">1</span>)) &gt;= <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-500">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-500">&#182;</a>
              </div>
              <p>if we end with a “&gt;”, “+”, or “~”, that means we’re implicitly
searching all children, so make it explicit</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						query += <span class="hljs-string">' * '</span>;
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-501">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-501">&#182;</a>
              </div>
              <p>if you have not provided a terminator, one will be provided for
you…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						query += <span class="hljs-string">' '</span>;
					}
					<span class="hljs-keyword">var</span> ts = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(s, e)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-502">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-502">&#182;</a>
              </div>
              <p>trim and slice.
take an index to start a string slice from and an end position
and return a trimmed copy of that sub-string</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> trim(query.slice(s, e));
					};</pre></div></div>
            
        </li>
        
        
        <li id="section-503">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-503">&#182;</a>
              </div>
              <p>the overall data graph of the full query, as represented by queryPart objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> queryParts = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-504">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-504">&#182;</a>
              </div>
              <p>state keeping vars</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> inBrackets = -<span class="hljs-number">1</span>,
						inParens = -<span class="hljs-number">1</span>,
						inMatchFor = -<span class="hljs-number">1</span>,
						inPseudo = -<span class="hljs-number">1</span>,
						inClass = -<span class="hljs-number">1</span>,
						inId = -<span class="hljs-number">1</span>,
						inTag = -<span class="hljs-number">1</span>,
						currentQuoteChar, lc = <span class="hljs-string">''</span>,
						cc = <span class="hljs-string">''</span>,
						pStart;</pre></div></div>
            
        </li>
        
        
        <li id="section-505">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-505">&#182;</a>
              </div>
              <p>iteration vars</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-506">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-506">&#182;</a>
              </div>
              <p>index in the query</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						ql = query.length,
						currentPart = <span class="hljs-literal">null</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-507">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-507">&#182;</a>
              </div>
              <p>data structure representing the entire clause</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						_cp = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-508">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-508">&#182;</a>
              </div>
              <p>the current pseudo or attr matcher
several temporary variables are assigned to this structure during a
potential sub-expression match:
    attr:
        a string representing the current full attribute match in a
        bracket expression
    type:
        if there’s an operator in a bracket expression, this is
        used to keep track of it
    value:
        the internals of parenthetical expression for a pseudo. for
        :nth-child(2n+1), value might be “2n+1”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> endTag = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-509">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-509">&#182;</a>
              </div>
              <p>called when the tokenizer hits the end of a particular tag name.
Re-sets state variables for tag matching and sets up the matcher
to handle the next type of token (tag or operator).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (inTag &gt;= <span class="hljs-number">0</span>) {
							<span class="hljs-keyword">var</span> tv = inTag === x ? <span class="hljs-literal">null</span> : ts(inTag, x);</pre></div></div>
            
        </li>
        
        
        <li id="section-510">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-510">&#182;</a>
              </div>
              <p>.toLowerCase();</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							currentPart[specials.indexOf(tv) &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">'tag'</span> : <span class="hljs-string">'oper'</span>] = tv;
							inTag = -<span class="hljs-number">1</span>;
						}
					};
					<span class="hljs-keyword">var</span> endId = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-511">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-511">&#182;</a>
              </div>
              <p>called when the tokenizer might be at the end of an ID portion of a match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (inId &gt;= <span class="hljs-number">0</span>) {
							currentPart.id = ts(inId, x)
								.replace(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">''</span>);
							inId = -<span class="hljs-number">1</span>;
						}
					};
					<span class="hljs-keyword">var</span> endClass = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-512">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-512">&#182;</a>
              </div>
              <p>called when the tokenizer might be at the end of a class name
match. CSS allows for multiple classes, so we augment the
current item with another class in its list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (inClass &gt;= <span class="hljs-number">0</span>) {
							currentPart.classes.push(ts(inClass + <span class="hljs-number">1</span>, x)
								.replace(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">''</span>));
							inClass = -<span class="hljs-number">1</span>;
						}
					};
					<span class="hljs-keyword">var</span> endAll = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-513">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-513">&#182;</a>
              </div>
              <p>at the end of a simple fragment, so wall off the matches</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						endId();
						endTag();
						endClass();
					};
					<span class="hljs-keyword">var</span> endPart = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						endAll();
						<span class="hljs-keyword">if</span> (inPseudo &gt;= <span class="hljs-number">0</span>) {
							currentPart.pseudos.push({
								name: ts(inPseudo + <span class="hljs-number">1</span>, x)
							});
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-514">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-514">&#182;</a>
              </div>
              <p>hint to the selector engine to tell it whether or not it
needs to do any iteration. Many simple selectors don’t, and
we can avoid significant construction-time work by advising
the system to skip them</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						currentPart.loops = currentPart.pseudos.length || currentPart.attrs.length || currentPart.classes.length;
						currentPart.oquery = currentPart.query = ts(pStart, x);</pre></div></div>
            
        </li>
        
        
        <li id="section-515">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-515">&#182;</a>
              </div>
              <p>save the full expression as a string
otag/tag are hints to suggest to the system whether or not
it’s an operator or a tag. We save a copy of otag since the
tag name is cast to upper-case in regular HTML matches. The
system has a global switch to figure out if the current
expression needs to be case sensitive or not and it will use
otag or tag accordingly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						currentPart.otag = currentPart.tag = currentPart.oper ? <span class="hljs-literal">null</span> : currentPart.tag || <span class="hljs-string">'*'</span>;
						<span class="hljs-keyword">if</span> (currentPart.tag) {</pre></div></div>
            
        </li>
        
        
        <li id="section-516">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-516">&#182;</a>
              </div>
              <p>if we’re in a case-insensitive HTML doc, we likely want
the toUpperCase when matching on element.tagName. If we
do it here, we can skip the string op per node
comparison</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							currentPart.tag = currentPart.tag.toUpperCase();
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-517">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-517">&#182;</a>
              </div>
              <p>add the part to the list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (queryParts.length &amp;&amp; queryParts[queryParts.length - <span class="hljs-number">1</span>].oper) {</pre></div></div>
            
        </li>
        
        
        <li id="section-518">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-518">&#182;</a>
              </div>
              <p>operators are always infix, so we remove them from the
list and attach them to the next match. The evaluator is
responsible for sorting out how to handle them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							currentPart.infixOper = queryParts.pop();
							currentPart.query = currentPart.infixOper.query + <span class="hljs-string">' '</span> + currentPart.query;
							<span class="hljs-comment">/*
                         console.debug(	"swapping out the infix",
                         currentPart.infixOper,
                         "and attaching it to",
                         currentPart);
                         */</span>
						}
						queryParts.push(currentPart);
						currentPart = <span class="hljs-literal">null</span>;
					};</pre></div></div>
            
        </li>
        
        
        <li id="section-519">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-519">&#182;</a>
              </div>
              <p>iterate over the query, character by character, building up a
list of query part objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">for</span> (; lc = cc, cc = query.charAt(x), x &lt; ql; x++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-520">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-520">&#182;</a>
              </div>
              <pre><code>cc: the current character <span class="hljs-keyword">in</span> the match
lc: the last character (<span class="hljs-keyword">if</span> any)
</code></pre><p>someone is trying to escape something, so don’t try to match any
fragments. We assume we’re inside a literal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (lc === <span class="hljs-string">'\\'</span>) {
							<span class="hljs-keyword">continue</span>;
						}
						<span class="hljs-keyword">if</span> (!currentPart) {</pre></div></div>
            
        </li>
        
        
        <li id="section-521">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-521">&#182;</a>
              </div>
              <p>a part was just ended or none has yet been created
NOTE: I hate all this alloc, but it’s shorter than writing tons of if’s</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							pStart = x;</pre></div></div>
            
        </li>
        
        
        <li id="section-522">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-522">&#182;</a>
              </div>
              <p>rules describe full CSS sub-expressions, like:</p>
<pre><code>#someId
.className:first-child
</code></pre><p>but not:
    thinger &gt; div.howdy[type=thinger]
the indidual components of the previous query would be
split into 3 parts that would be represented a structure like:
    [
        {
            query: “thinger”,
            tag: “thinger”,
        },
        {
            query: “div.howdy[type=thinger]”,
            classes: [“howdy”],
            infixOper: {
                query: “&gt;”,
                oper: “&gt;”,
            }
        },
    ]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							currentPart = {
								query: <span class="hljs-literal">null</span>,
								pseudos: [],
								attrs: [],
								classes: [],
								tag: <span class="hljs-literal">null</span>,
								oper: <span class="hljs-literal">null</span>,
								id: <span class="hljs-literal">null</span>,
								getTag: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
									<span class="hljs-keyword">return</span> caseSensitive ? <span class="hljs-keyword">this</span>.otag : <span class="hljs-keyword">this</span>.tag;
								}
							};</pre></div></div>
            
        </li>
        
        
        <li id="section-523">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-523">&#182;</a>
              </div>
              <p>if we don’t have a part, we assume we’re going to start at
the beginning of a match, which should be a tag name. This
might fault a little later on, but we detect that and this
iteration will still be fine.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							inTag = x;
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-524">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-524">&#182;</a>
              </div>
              <p>Skip processing all quoted characters.
If we are inside quoted text then currentQuoteChar stores the character that began the quote,
thus that character that will end it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (currentQuoteChar) {
							<span class="hljs-keyword">if</span> (cc === currentQuoteChar) {
								currentQuoteChar = <span class="hljs-literal">null</span>;
							}
							<span class="hljs-keyword">continue</span>;
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cc === <span class="hljs-string">'\''</span> || cc === <span class="hljs-string">'"'</span>) {
							currentQuoteChar = cc;
							<span class="hljs-keyword">continue</span>;
						}
						<span class="hljs-keyword">if</span> (inBrackets &gt;= <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-525">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-525">&#182;</a>
              </div>
              <p>look for a the close first</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (cc === <span class="hljs-string">']'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-526">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-526">&#182;</a>
              </div>
              <p>if we’re in a […] clause and we end, do assignment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (!_cp.attr) {</pre></div></div>
            
        </li>
        
        
        <li id="section-527">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-527">&#182;</a>
              </div>
              <p>no attribute match was previously begun, so we
assume this is an attribute existence match in the
form of [someAttributeName]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									_cp.attr = ts(inBrackets + <span class="hljs-number">1</span>, x);
								} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-528">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-528">&#182;</a>
              </div>
              <p>we had an attribute already, so we know that we’re
matching some sort of value, as in [attrName=howdy]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									_cp.matchFor = ts(inMatchFor || inBrackets + <span class="hljs-number">1</span>, x);
								}
								<span class="hljs-keyword">var</span> cmf = _cp.matchFor;
								<span class="hljs-keyword">if</span> (cmf) {</pre></div></div>
            
        </li>
        
        
        <li id="section-529">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-529">&#182;</a>
              </div>
              <p>try to strip quotes from the matchFor value. We want
[attrName=howdy] to match the same
as [attrName = ‘howdy’ ]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-keyword">if</span> (cmf.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'"'</span> || cmf.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'\''</span>) {
										_cp.matchFor = cmf.slice(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);
									}
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-530">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-530">&#182;</a>
              </div>
              <p>remove backslash escapes from an attribute match, since DOM
querying will get attribute values without backslashes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (_cp.matchFor) {
									_cp.matchFor = _cp.matchFor.replace(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">''</span>);
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-531">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-531">&#182;</a>
              </div>
              <p>end the attribute by adding it to the list of attributes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								currentPart.attrs.push(_cp);
								_cp = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-532">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-532">&#182;</a>
              </div>
              <p>necessary?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								inBrackets = inMatchFor = -<span class="hljs-number">1</span>;
							} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cc === <span class="hljs-string">'='</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-533">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-533">&#182;</a>
              </div>
              <p>if the last char was an operator prefix, make sure we
record it along with the “=” operator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">var</span> addToCc = <span class="hljs-string">'|~^$*'</span>.indexOf(lc) &gt;= <span class="hljs-number">0</span> ? lc : <span class="hljs-string">''</span>;
								_cp.type = addToCc + cc;
								_cp.attr = ts(inBrackets + <span class="hljs-number">1</span>, x - addToCc.length);
								inMatchFor = x + <span class="hljs-number">1</span>;
							} <span class="hljs-comment">// now look for other clause parts</span>
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inParens &gt;= <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-534">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-534">&#182;</a>
              </div>
              <p>if we’re in a parenthetical expression, we need to figure
out if it’s attached to a pseudo-selector rule like
:nth-child(1)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (cc === <span class="hljs-string">')'</span>) {
								<span class="hljs-keyword">if</span> (inPseudo &gt;= <span class="hljs-number">0</span>) {
									_cp.value = ts(inParens + <span class="hljs-number">1</span>, x);
								}
								inPseudo = inParens = -<span class="hljs-number">1</span>;
							}
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cc === <span class="hljs-string">'#'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-535">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-535">&#182;</a>
              </div>
              <p>start of an ID match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							endAll();
							inId = x + <span class="hljs-number">1</span>;
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cc === <span class="hljs-string">'.'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-536">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-536">&#182;</a>
              </div>
              <p>start of a class match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							endAll();
							inClass = x;
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cc === <span class="hljs-string">':'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-537">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-537">&#182;</a>
              </div>
              <p>start of a pseudo-selector match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							endAll();
							inPseudo = x;
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cc === <span class="hljs-string">'['</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-538">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-538">&#182;</a>
              </div>
              <p>start of an attribute match.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							endAll();
							inBrackets = x;</pre></div></div>
            
        </li>
        
        
        <li id="section-539">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-539">&#182;</a>
              </div>
              <p>provide a new structure for the attribute match to fill-in</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							_cp = {};
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cc === <span class="hljs-string">'('</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-540">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-540">&#182;</a>
              </div>
              <p>we really only care if we’ve entered a parenthetical
expression if we’re already inside a pseudo-selector match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (inPseudo &gt;= <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-541">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-541">&#182;</a>
              </div>
              <p>provide a new structure for the pseudo match to fill-in</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								_cp = {
									name: ts(inPseudo + <span class="hljs-number">1</span>, x),
									value: <span class="hljs-literal">null</span>
								};
								currentPart.pseudos.push(_cp);
							}
							inParens = x;
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cc === <span class="hljs-string">' '</span> &amp;&amp; lc !== cc) {
							endPart();
						}
					}
					<span class="hljs-keyword">return</span> queryParts;
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-542">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-542">&#182;</a>
              </div>
              <p>//////////////////////////////////////////////////////////////////////
DOM query infrastructure
//////////////////////////////////////////////////////////////////////</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> agree = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(first, second)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-543">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-543">&#182;</a>
              </div>
              <p>the basic building block of the yes/no chaining system. agree(f1,
f2) generates a new function which returns the boolean results of
both of the passed functions to a single logical-anded result. If
either are not passed, the other is used exclusively.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!first) {
						<span class="hljs-keyword">return</span> second;
					}
					<span class="hljs-keyword">if</span> (!second) {
						<span class="hljs-keyword">return</span> first;
					}
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">return</span> first.apply(window, <span class="hljs-built_in">arguments</span>) &amp;&amp; second.apply(window, <span class="hljs-built_in">arguments</span>);
					};
				};
				<span class="hljs-keyword">var</span> getArr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i, arr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-544">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-544">&#182;</a>
              </div>
              <p>helps us avoid array alloc when we don’t need it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> r = arr || [];</pre></div></div>
            
        </li>
        
        
        <li id="section-545">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-545">&#182;</a>
              </div>
              <p>FIXME: should this be ‘new d._NodeListCtor()’ ?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (i) {
						r.push(i);
					}
					<span class="hljs-keyword">return</span> r;
				};
				<span class="hljs-keyword">var</span> _isElement = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-number">1</span> === n.nodeType;
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-546">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-546">&#182;</a>
              </div>
              <p>FIXME: need to coalesce _getAttr with defaultGetter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> blank = <span class="hljs-string">''</span>;
				<span class="hljs-keyword">var</span> _getAttr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem, attr)</span> {</span>
					<span class="hljs-keyword">if</span> (!elem) {
						<span class="hljs-keyword">return</span> blank;
					}
					<span class="hljs-keyword">if</span> (attr === <span class="hljs-string">'class'</span>) {
						<span class="hljs-keyword">return</span> elem.className || blank;
					}
					<span class="hljs-keyword">if</span> (attr === <span class="hljs-string">'for'</span>) {
						<span class="hljs-keyword">return</span> elem.htmlFor || blank;
					}
					<span class="hljs-keyword">if</span> (attr === <span class="hljs-string">'style'</span>) {
						<span class="hljs-keyword">return</span> elem.style.cssText || blank;
					}
					<span class="hljs-keyword">return</span> (caseSensitive ? elem.getAttribute(attr) : elem.getAttribute(attr, <span class="hljs-number">2</span>)) || blank;
				};
				<span class="hljs-keyword">var</span> attrs = {
					<span class="hljs-string">'*='</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attr, value)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-547">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-547">&#182;</a>
              </div>
              <p>E[foo*=”bar”]
    an E element whose “foo” attribute value contains
    the substring “bar”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> _getAttr(elem, attr)
								.indexOf(value) &gt;= <span class="hljs-number">0</span>;
						};
					},
					<span class="hljs-string">'^='</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attr, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-548">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-548">&#182;</a>
              </div>
              <p>E[foo^=”bar”]
    an E element whose “foo” attribute value begins exactly
    with the string “bar”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">return</span> _getAttr(elem, attr)
								.indexOf(value) === <span class="hljs-number">0</span>;
						};
					},
					<span class="hljs-string">'$='</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attr, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-549">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-549">&#182;</a>
              </div>
              <p>E[foo$=”bar”]
    an E element whose “foo” attribute value ends exactly
    with the string “bar”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">var</span> ea = <span class="hljs-string">' '</span> + _getAttr(elem, attr);
							<span class="hljs-keyword">var</span> lastIndex = ea.lastIndexOf(value);
							<span class="hljs-keyword">return</span> lastIndex &gt; -<span class="hljs-number">1</span> &amp;&amp; lastIndex === ea.length - value.length;
						};
					},
					<span class="hljs-string">'~='</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attr, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-550">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-550">&#182;</a>
              </div>
              <p>E[foo~=”bar”]
    an E element whose “foo” attribute value is a list of
    space-separated values, one of which is exactly equal
    to “bar”
return “[contains(concat(‘ ‘,@”+attr+”,’ ‘), ‘ “+ value +” ‘)]”;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> tval = <span class="hljs-string">' '</span> + value + <span class="hljs-string">' '</span>;
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">var</span> ea = <span class="hljs-string">' '</span> + _getAttr(elem, attr) + <span class="hljs-string">' '</span>;
							<span class="hljs-keyword">return</span> ea.indexOf(tval) &gt;= <span class="hljs-number">0</span>;
						};
					},
					<span class="hljs-string">'|='</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attr, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-551">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-551">&#182;</a>
              </div>
              <p>E[hreflang|=”en”]
    an E element whose “hreflang” attribute has a
    hyphen-separated list of values beginning (from the
    left) with “en”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> valueDash = value + <span class="hljs-string">'-'</span>;
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">var</span> ea = _getAttr(elem, attr);
							<span class="hljs-keyword">return</span> ea === value || ea.indexOf(valueDash) === <span class="hljs-number">0</span>;
						};
					},
					<span class="hljs-string">'='</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attr, value)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">return</span> _getAttr(elem, attr) === value;
						};
					}
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-552">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-552">&#182;</a>
              </div>
              <p>avoid testing for node type if we can. Defining this in the negative
here to avoid negation in the fast path.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> _noNES = <span class="hljs-keyword">typeof</span> getDoc()
					.firstChild.nextElementSibling === <span class="hljs-string">'undefined'</span>;
				<span class="hljs-keyword">var</span> _ns = !_noNES ? <span class="hljs-string">'nextElementSibling'</span> : <span class="hljs-string">'nextSibling'</span>;
				<span class="hljs-keyword">var</span> _ps = !_noNES ? <span class="hljs-string">'previousElementSibling'</span> : <span class="hljs-string">'previousSibling'</span>;
				<span class="hljs-keyword">var</span> _simpleNodeTest = _noNES ? _isElement : yesman;
				<span class="hljs-keyword">var</span> _lookLeft = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-553">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-553">&#182;</a>
              </div>
              <p>look left</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">while</span> (node = node[_ps]) {
						<span class="hljs-keyword">if</span> (_simpleNodeTest(node)) {
							<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
						}
					}
					<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
				};
				<span class="hljs-keyword">var</span> _lookRight = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-554">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-554">&#182;</a>
              </div>
              <p>look right</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">while</span> (node = node[_ns]) {
						<span class="hljs-keyword">if</span> (_simpleNodeTest(node)) {
							<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
						}
					}
					<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
				};
				<span class="hljs-keyword">var</span> getNodeIndex = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
					<span class="hljs-keyword">var</span> root = node.parentNode;
					root = root.nodeType !== <span class="hljs-number">7</span> ? root : root.nextSibling;</pre></div></div>
            
        </li>
        
        
        <li id="section-555">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-555">&#182;</a>
              </div>
              <p>PROCESSING_INSTRUCTION_NODE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
						tret = root.children || root.childNodes,
						ci = node._i || node.getAttribute(<span class="hljs-string">'_i'</span>) || -<span class="hljs-number">1</span>,
						cl = root._l || (<span class="hljs-keyword">typeof</span> root.getAttribute !== <span class="hljs-string">'undefined'</span> ? root.getAttribute(<span class="hljs-string">'_l'</span>) : -<span class="hljs-number">1</span>);
					<span class="hljs-keyword">if</span> (!tret) {
						<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
					}
					<span class="hljs-keyword">var</span> l = tret.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-556">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-556">&#182;</a>
              </div>
              <p>we calculate the parent length as a cheap way to invalidate the
cache. It’s not 100% accurate, but it’s much more honest than what
other libraries do</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (cl === l &amp;&amp; ci &gt;= <span class="hljs-number">0</span> &amp;&amp; cl &gt;= <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-557">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-557">&#182;</a>
              </div>
              <p>if it’s legit, tag and release</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> ci;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-558">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-558">&#182;</a>
              </div>
              <p>else re-key things</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>) &amp;&amp; <span class="hljs-keyword">typeof</span> root.setAttribute !== <span class="hljs-string">'undefined'</span>) {
						root.setAttribute(<span class="hljs-string">'_l'</span>, l);
					} <span class="hljs-keyword">else</span> {
						root._l = l;
					}
					ci = -<span class="hljs-number">1</span>;
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> te = root.firstElementChild || root.firstChild; te; te = te[_ns]) {
						<span class="hljs-keyword">if</span> (_simpleNodeTest(te)) {
							<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>)) {
								te.setAttribute(<span class="hljs-string">'_i'</span>, ++i);
							} <span class="hljs-keyword">else</span> {
								te._i = ++i;
							}
							<span class="hljs-keyword">if</span> (node === te) {</pre></div></div>
            
        </li>
        
        
        <li id="section-559">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-559">&#182;</a>
              </div>
              <p>NOTE:
shortcutting the return at this step in indexing works
very well for benchmarking but we avoid it here since
it leads to potential O(n^2) behavior in sequential
getNodexIndex operations on a previously un-indexed
parent. We may revisit this at a later time, but for
now we just want to get the right answer more often
than not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								ci = i;
							}
						}
					}
					<span class="hljs-keyword">return</span> ci;
				};
				<span class="hljs-keyword">var</span> isEven = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
					<span class="hljs-keyword">return</span> !(getNodeIndex(elem) % <span class="hljs-number">2</span>);
				};
				<span class="hljs-keyword">var</span> isOdd = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
					<span class="hljs-keyword">return</span> getNodeIndex(elem) % <span class="hljs-number">2</span>;
				};
				<span class="hljs-keyword">var</span> pseudos = {
					<span class="hljs-string">'checked'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, condition)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">return</span> !!(<span class="hljs-string">'checked'</span> <span class="hljs-keyword">in</span> elem ? elem.checked : elem.selected);
						};
					},
					<span class="hljs-string">'disabled'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, condition)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">return</span> elem.disabled;
						};
					},
					<span class="hljs-string">'enabled'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, condition)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">return</span> !elem.disabled;
						};
					},
					<span class="hljs-string">'first-child'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">return</span> _lookLeft;
					},
					<span class="hljs-string">'last-child'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">return</span> _lookRight;
					},
					<span class="hljs-string">'only-child'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, condition)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
							<span class="hljs-keyword">return</span> _lookLeft(node) &amp;&amp; _lookRight(node);
						};
					},
					<span class="hljs-string">'empty'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, condition)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-560">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-560">&#182;</a>
              </div>
              <p>DomQuery and jQuery get this wrong, oddly enough.
The CSS 3 selectors spec is pretty explicit about it, too.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> cn = elem.childNodes;
							<span class="hljs-keyword">var</span> cnl = elem.childNodes.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-561">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-561">&#182;</a>
              </div>
              <p>if(!cnl){ return true; }</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = cnl - <span class="hljs-number">1</span>; x &gt;= <span class="hljs-number">0</span>; x--) {
								<span class="hljs-keyword">var</span> nt = cn[x].nodeType;
								<span class="hljs-keyword">if</span> (nt === <span class="hljs-number">1</span> || nt === <span class="hljs-number">3</span>) {
									<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
								}
							}
							<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
						};
					},
					<span class="hljs-string">'contains'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, condition)</span> {</span>
						<span class="hljs-keyword">var</span> cz = condition.charAt(<span class="hljs-number">0</span>);
						<span class="hljs-keyword">if</span> (cz === <span class="hljs-string">'"'</span> || cz === <span class="hljs-string">'\''</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-562">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-562">&#182;</a>
              </div>
              <p>remove quote</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							condition = condition.slice(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);
						}
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">return</span> elem.innerHTML.indexOf(condition) &gt;= <span class="hljs-number">0</span>;
						};
					},
					<span class="hljs-string">'not'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, condition)</span> {</span>
						<span class="hljs-keyword">var</span> p = getQueryParts(condition)[<span class="hljs-number">0</span>];
						<span class="hljs-keyword">var</span> ignores = {
							el: <span class="hljs-number">1</span>
						};
						<span class="hljs-keyword">if</span> (p.tag !== <span class="hljs-string">'*'</span>) {
							ignores.tag = <span class="hljs-number">1</span>;
						}
						<span class="hljs-keyword">if</span> (!p.classes.length) {
							ignores.classes = <span class="hljs-number">1</span>;
						}
						<span class="hljs-keyword">var</span> ntf = getSimpleFilterFunc(p, ignores);
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">return</span> !ntf(elem);
						};
					},
					<span class="hljs-string">'nth-child'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, condition)</span> {</span>
						<span class="hljs-keyword">var</span> pi = <span class="hljs-built_in">parseInt</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-563">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-563">&#182;</a>
              </div>
              <p>avoid re-defining function objects if we can</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (condition === <span class="hljs-string">'odd'</span>) {
							<span class="hljs-keyword">return</span> isOdd;
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition === <span class="hljs-string">'even'</span>) {
							<span class="hljs-keyword">return</span> isEven;
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-564">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-564">&#182;</a>
              </div>
              <p>FIXME: can we shorten this?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (condition.indexOf(<span class="hljs-string">'n'</span>) !== -<span class="hljs-number">1</span>) {
							<span class="hljs-keyword">var</span> tparts = condition.split(<span class="hljs-string">'n'</span>, <span class="hljs-number">2</span>);
							<span class="hljs-keyword">var</span> pred = tparts[<span class="hljs-number">0</span>] ? tparts[<span class="hljs-number">0</span>] === <span class="hljs-string">'-'</span> ? -<span class="hljs-number">1</span> : pi(tparts[<span class="hljs-number">0</span>]) : <span class="hljs-number">1</span>;
							<span class="hljs-keyword">var</span> idx = tparts[<span class="hljs-number">1</span>] ? pi(tparts[<span class="hljs-number">1</span>]) : <span class="hljs-number">0</span>;
							<span class="hljs-keyword">var</span> lb = <span class="hljs-number">0</span>,
								ub = -<span class="hljs-number">1</span>;
							<span class="hljs-keyword">if</span> (pred &gt; <span class="hljs-number">0</span>) {
								<span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span>) {
									idx = idx % pred &amp;&amp; pred + idx % pred;
								} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idx &gt; <span class="hljs-number">0</span>) {
									<span class="hljs-keyword">if</span> (idx &gt;= pred) {
										lb = idx - idx % pred;
									}
									idx = idx % pred;
								}
							} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pred &lt; <span class="hljs-number">0</span>) {
								pred *= -<span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-565">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-565">&#182;</a>
              </div>
              <p>idx has to be greater than 0 when pred is negative;
shall we throw an error here?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (idx &gt; <span class="hljs-number">0</span>) {
									ub = idx;
									idx = idx % pred;
								}
							}
							<span class="hljs-keyword">if</span> (pred &gt; <span class="hljs-number">0</span>) {
								<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
									<span class="hljs-keyword">var</span> i = getNodeIndex(elem);
									<span class="hljs-keyword">return</span> i &gt;= lb &amp;&amp; (ub &lt; <span class="hljs-number">0</span> || i &lt;= ub) &amp;&amp; i % pred === idx;
								};
							} <span class="hljs-keyword">else</span> {
								condition = idx;
							}
						}
						<span class="hljs-keyword">var</span> ncount = pi(condition);
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">return</span> getNodeIndex(elem) === ncount;
						};
					}
				};
				<span class="hljs-keyword">var</span> defaultGetter = has(<span class="hljs-string">'ie'</span>) &amp;&amp; (has(<span class="hljs-string">'ie'</span>) &lt; <span class="hljs-number">9</span> || has(<span class="hljs-string">'quirks'</span>)) ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cond)</span> {</span>
						<span class="hljs-keyword">var</span> clc = cond.toLowerCase();
						<span class="hljs-keyword">if</span> (clc === <span class="hljs-string">'class'</span>) {
							cond = <span class="hljs-string">'className'</span>;
						}
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">return</span> caseSensitive ? elem.getAttribute(cond) : elem[cond] || elem[clc];
						};
					} : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cond)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
							<span class="hljs-keyword">return</span> elem &amp;&amp; elem.getAttribute &amp;&amp; elem.hasAttribute(cond);
						};
					};
				<span class="hljs-keyword">var</span> getSimpleFilterFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query, ignores)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-566">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-566">&#182;</a>
              </div>
              <p>generates a node tester function based on the passed query part. The
query part is one of the structures generated by the query parser
when it creates the query AST. The “ignores” object specifies which
(if any) tests to skip, allowing the system to avoid duplicating
work where it may have already been taken into account by other
factors such as how the nodes to test were fetched in the first
place</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!query) {
						<span class="hljs-keyword">return</span> yesman;
					}
					ignores = ignores || {};
					<span class="hljs-keyword">var</span> ff = <span class="hljs-literal">null</span>;
					<span class="hljs-keyword">if</span> (!(<span class="hljs-string">'el'</span> <span class="hljs-keyword">in</span> ignores)) {
						ff = agree(ff, _isElement);
					}
					<span class="hljs-keyword">if</span> (!(<span class="hljs-string">'tag'</span> <span class="hljs-keyword">in</span> ignores)) {
						<span class="hljs-keyword">if</span> (query.tag !== <span class="hljs-string">'*'</span>) {
							ff = agree(ff, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
								<span class="hljs-keyword">return</span> elem &amp;&amp; (caseSensitive ? elem.tagName : elem.tagName.toUpperCase()) === query.getTag();
							});
						}
					}
					<span class="hljs-keyword">if</span> (!(<span class="hljs-string">'classes'</span> <span class="hljs-keyword">in</span> ignores)) {
						each(query.classes, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cname, idx, arr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-567">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-567">&#182;</a>
              </div>
              <p>get the class name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-comment">/*
                         var isWildcard = cname.charAt(cname.length-1) == "*";
                         if(isWildcard){
                         cname = cname.substr(0, cname.length-1);
                         }
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-568">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-568">&#182;</a>
              </div>
              <p>I dislike the regex thing, even if memoized in a cache, but it’s VERY short</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                         var re = new RegExp("(?:^|\\s)" + cname + (isWildcard ? ".*" : "") + "(?:\\s|$)");
                         */
							var re = new RegExp('(?:^|\\s)' + cname + '(?:\\s|$)');
							ff = agree(ff, function (elem) {
								return re.test(elem.className);
							});
							ff.count = idx;
						});
					}
					if (!('pseudos' in ignores)) {
						each(query.pseudos, function (pseudo) {
							var pn = pseudo.name;
							if (pseudos[pn]) {
								ff = agree(ff, pseudos[pn](pn, pseudo.value));
							}
						});
					}
					if (!('attrs' in ignores)) {
						each(query.attrs, function (attr) {
							var matcher;
							var a = attr.attr;</pre></div></div>
            
        </li>
        
        
        <li id="section-569">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-569">&#182;</a>
              </div>
              <p>type, attr, matchFor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (attr.type &amp;&amp; attrs[attr.type]) {
								matcher = attrs[attr.type](a, attr.matchFor);
							} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.length) {
								matcher = defaultGetter(a);
							}
							<span class="hljs-keyword">if</span> (matcher) {
								ff = agree(ff, matcher);
							}
						});
					}
					<span class="hljs-keyword">if</span> (!(<span class="hljs-string">'id'</span> <span class="hljs-keyword">in</span> ignores)) {
						<span class="hljs-keyword">if</span> (query.id) {
							ff = agree(ff, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(elem)</span> {</span>
								<span class="hljs-keyword">return</span> !!elem &amp;&amp; elem.id === query.id;
							});
						}
					}
					<span class="hljs-keyword">if</span> (!ff) {
						<span class="hljs-keyword">if</span> (!(<span class="hljs-string">'default'</span> <span class="hljs-keyword">in</span> ignores)) {
							ff = yesman;
						}
					}
					<span class="hljs-keyword">return</span> ff;
				};
				<span class="hljs-keyword">var</span> _nextSibling = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(filterFunc)</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, ret, bag)</span> {</span>
						<span class="hljs-keyword">while</span> (node = node[_ns]) {
							<span class="hljs-keyword">if</span> (_noNES &amp;&amp; !_isElement(node)) {
								<span class="hljs-keyword">continue</span>;
							}
							<span class="hljs-keyword">if</span> ((!bag || _isUnique(node, bag)) &amp;&amp; filterFunc(node)) {
								ret.push(node);
							}
							<span class="hljs-keyword">break</span>;
						}
						<span class="hljs-keyword">return</span> ret;
					};
				};
				<span class="hljs-keyword">var</span> _nextSiblings = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(filterFunc)</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root, ret, bag)</span> {</span>
						<span class="hljs-keyword">var</span> te = root[_ns];
						<span class="hljs-keyword">while</span> (te) {
							<span class="hljs-keyword">if</span> (_simpleNodeTest(te)) {
								<span class="hljs-keyword">if</span> (bag &amp;&amp; !_isUnique(te, bag)) {
									<span class="hljs-keyword">break</span>;
								}
								<span class="hljs-keyword">if</span> (filterFunc(te)) {
									ret.push(te);
								}
							}
							te = te[_ns];
						}
						<span class="hljs-keyword">return</span> ret;
					};
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-570">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-570">&#182;</a>
              </div>
              <p>get an array of child <em>elements</em>, skipping text and comment nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> _childElements = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(filterFunc)</span> {</span>
					filterFunc = filterFunc || yesman;
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root, ret, bag)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-571">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-571">&#182;</a>
              </div>
              <p>get an array of child elements, skipping text and comment nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> te, x = <span class="hljs-number">0</span>,
							tret = root.children || root.childNodes;
						<span class="hljs-keyword">while</span> (te = tret[x++]) {
							<span class="hljs-keyword">if</span> (_simpleNodeTest(te) &amp;&amp; (!bag || _isUnique(te, bag)) &amp;&amp; filterFunc(te, x)) {
								ret.push(te);
							}
						}
						<span class="hljs-keyword">return</span> ret;
					};
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-572">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-572">&#182;</a>
              </div>
              <p>test to see if node is below root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> _isDescendant = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, root)</span> {</span>
					<span class="hljs-keyword">var</span> pn = node.parentNode;
					<span class="hljs-keyword">while</span> (pn) {
						<span class="hljs-keyword">if</span> (pn === root) {
							<span class="hljs-keyword">break</span>;
						}
						pn = pn.parentNode;
					}
					<span class="hljs-keyword">return</span> !!pn;
				};
				<span class="hljs-keyword">var</span> _getElementsFuncCache = {};
				<span class="hljs-keyword">var</span> getElementsFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query)</span> {</span>
					<span class="hljs-keyword">var</span> retFunc = _getElementsFuncCache[query.query];</pre></div></div>
            
        </li>
        
        
        <li id="section-573">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-573">&#182;</a>
              </div>
              <p>if we’ve got a cached dispatcher, just use that</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (retFunc) {
						<span class="hljs-keyword">return</span> retFunc;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-574">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-574">&#182;</a>
              </div>
              <p>else, generate a new on
NOTE:
    this function returns a function that searches for nodes and
    filters them.  The search may be specialized by infix operators
    (“&gt;”, “~”, or “+”) else it will default to searching all
    descendants (the “ “ selector). Once a group of children is
    found, a test function is applied to weed out the ones we
    don’t want. Many common cases can be fast-pathed. We spend a
    lot of cycles to create a dispatcher that doesn’t do more work
    than necessary at any point since, unlike this function, the
    dispatchers will be called every time. The logic of generating
    efficient dispatchers looks like this in pseudo code:</p>
<pre><code># if it's a purely descendant query (no "&gt;", "+", or "~" modifiers)
if infixOperator == " ":
    if only(id):
        return def(root):
            return d.byId(id, root);

    elif id:
        return def(root):
            return filter(d.byId(id, root));

    elif cssClass &amp;&amp; getElementsByClassName:
        return def(root):
            return filter(root.getElementsByClassName(cssClass));

    elif only(tag):
        return def(root):
            return root.getElementsByTagName(tagName);

    else:
        # search by tag name, then filter
        return def(root):
            return filter(root.getElementsByTagName(tagName||"*"));

elif infixOperator == "&gt;":
    # search direct children
    return def(root):
        return filter(root.children);

elif infixOperator == "+":
    # search next sibling
    return def(root):
        return filter(root.nextElementSibling);

elif infixOperator == "~":
    # search rightward siblings
    return def(root):
        return filter(nextSiblings(root));
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> io = query.infixOper;
					<span class="hljs-keyword">var</span> oper = io ? io.oper : <span class="hljs-string">''</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-575">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-575">&#182;</a>
              </div>
              <p>the default filter func which tests for all conditions in the query
part. This is potentially inefficient, so some optimized paths may
re-define it to test fewer things.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> filterFunc = getSimpleFilterFunc(query, {
						el: <span class="hljs-number">1</span>
					});
					<span class="hljs-keyword">var</span> qt = query.tag;
					<span class="hljs-keyword">var</span> wildcardTag = <span class="hljs-string">'*'</span> === qt;
					<span class="hljs-keyword">var</span> ecs = getDoc()
						.getElementsByClassName;
					<span class="hljs-keyword">if</span> (!oper) {</pre></div></div>
            
        </li>
        
        
        <li id="section-576">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-576">&#182;</a>
              </div>
              <p>if there’s no infix operator, then it’s a descendant query. ID
and “elements by class name” variants can be accelerated so we
call them out explicitly:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (query.id) {</pre></div></div>
            
        </li>
        
        
        <li id="section-577">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-577">&#182;</a>
              </div>
              <p>testing shows that the overhead of yesman() is acceptable
and can save us some bytes vs. re-defining the function
everywhere.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							filterFunc = !query.loops &amp;&amp; wildcardTag ? yesman : getSimpleFilterFunc(query, {
								el: <span class="hljs-number">1</span>,
								id: <span class="hljs-number">1</span>
							});
							retFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root, arr)</span> {</span>
								<span class="hljs-keyword">var</span> te = dom.byId(query.id, root.ownerDocument || root);
								<span class="hljs-keyword">if</span> (!te || !filterFunc(te)) {
									<span class="hljs-keyword">return</span>;
								}
								<span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> === root.nodeType) {</pre></div></div>
            
        </li>
        
        
        <li id="section-578">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-578">&#182;</a>
              </div>
              <p>if root’s a doc, we just return directly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-keyword">return</span> getArr(te, arr);
								} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-579">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-579">&#182;</a>
              </div>
              <p>otherwise check ancestry</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-keyword">if</span> (_isDescendant(te, root)) {
										<span class="hljs-keyword">return</span> getArr(te, arr);
									}
								}
							};
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ecs &amp;&amp; <span class="hljs-regexp">/\{\s*\[native code\]\s*\}/</span>.test(<span class="hljs-built_in">String</span>(ecs)) &amp;&amp; query.classes.length &amp;&amp; !cssCaseBug) {</pre></div></div>
            
        </li>
        
        
        <li id="section-580">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-580">&#182;</a>
              </div>
              <p>it’s a class-based query and we’ve got a fast way to run it.
ignore class and ID filters since we will have handled both</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							filterFunc = getSimpleFilterFunc(query, {
								el: <span class="hljs-number">1</span>,
								classes: <span class="hljs-number">1</span>,
								id: <span class="hljs-number">1</span>
							});
							<span class="hljs-keyword">var</span> classesString = query.classes.join(<span class="hljs-string">' '</span>);
							retFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root, arr, bag)</span> {</span>
								<span class="hljs-keyword">var</span> ret = getArr(<span class="hljs-number">0</span>, arr),
									te, x = <span class="hljs-number">0</span>;
								<span class="hljs-keyword">var</span> tret = root.getElementsByClassName(classesString);
								<span class="hljs-keyword">while</span> (te = tret[x++]) {
									<span class="hljs-keyword">if</span> (filterFunc(te, root) &amp;&amp; _isUnique(te, bag)) {
										ret.push(te);
									}
								}
								<span class="hljs-keyword">return</span> ret;
							};
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wildcardTag &amp;&amp; !query.loops) {</pre></div></div>
            
        </li>
        
        
        <li id="section-581">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-581">&#182;</a>
              </div>
              <p>it’s tag only. Fast-path it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							retFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root, arr, bag)</span> {</span>
								<span class="hljs-keyword">var</span> ret = getArr(<span class="hljs-number">0</span>, arr),
									te, x = <span class="hljs-number">0</span>;
								<span class="hljs-keyword">var</span> tag = query.getTag(),
									tret = tag ? root.getElementsByTagName(tag) : [];
								<span class="hljs-keyword">while</span> (te = tret[x++]) {
									<span class="hljs-keyword">if</span> (_isUnique(te, bag)) {
										ret.push(te);
									}
								}
								<span class="hljs-keyword">return</span> ret;
							};
						} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-582">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-582">&#182;</a>
              </div>
              <p>the common case:
    a descendant selector without a fast path. By now it’s got
    to have a tag selector, even if it’s just “*” so we query
    by that and filter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							filterFunc = getSimpleFilterFunc(query, {
								el: <span class="hljs-number">1</span>,
								tag: <span class="hljs-number">1</span>,
								id: <span class="hljs-number">1</span>
							});
							retFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root, arr, bag)</span> {</span>
								<span class="hljs-keyword">var</span> ret = getArr(<span class="hljs-number">0</span>, arr),
									te, x = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-583">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-583">&#182;</a>
              </div>
              <p>we use getTag() to avoid case sensitivity issues</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">var</span> tag = query.getTag(),
									tret = tag ? root.getElementsByTagName(tag) : [];
								<span class="hljs-keyword">while</span> (te = tret[x++]) {
									<span class="hljs-keyword">if</span> (filterFunc(te, root) &amp;&amp; _isUnique(te, bag)) {
										ret.push(te);
									}
								}
								<span class="hljs-keyword">return</span> ret;
							};
						}
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-584">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-584">&#182;</a>
              </div>
              <p>the query is scoped in some way. Instead of querying by tag we
use some other collection to find candidate nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> skipFilters = {
							el: <span class="hljs-number">1</span>
						};
						<span class="hljs-keyword">if</span> (wildcardTag) {
							skipFilters.tag = <span class="hljs-number">1</span>;
						}
						filterFunc = getSimpleFilterFunc(query, skipFilters);
						<span class="hljs-keyword">if</span> (<span class="hljs-string">'+'</span> === oper) {
							retFunc = _nextSibling(filterFunc);
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">'~'</span> === oper) {
							retFunc = _nextSiblings(filterFunc);
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">'&gt;'</span> === oper) {
							retFunc = _childElements(filterFunc);
						}
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-585">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-585">&#182;</a>
              </div>
              <p>cache it and return</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> _getElementsFuncCache[query.query] = retFunc;
				};
				<span class="hljs-keyword">var</span> filterDown = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root, queryParts)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-586">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-586">&#182;</a>
              </div>
              <p>NOTE:
    this is the guts of the DOM query system. It takes a list of
    parsed query parts and a root and finds children which match
    the selector represented by the parts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> candidates = getArr(root),
						qp, x, te, qpl = queryParts.length,
						bag, ret;
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; qpl; i++) {
						ret = [];
						qp = queryParts[i];
						x = candidates.length - <span class="hljs-number">1</span>;
						<span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-587">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-587">&#182;</a>
              </div>
              <p>if we have more than one root at this level, provide a new
hash to use for checking group membership but tell the
system not to post-filter us since we will already have been
guaranteed to be unique</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							bag = {};
							ret.nozip = <span class="hljs-literal">true</span>;
						}
						<span class="hljs-keyword">var</span> gef = getElementsFunc(qp);
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; te = candidates[j]; j++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-588">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-588">&#182;</a>
              </div>
              <p>for every root, get the elements that match the descendant
selector, adding them to the “ret” array and filtering them
via membership in this level’s bag. If there are more query
parts, then this level’s return will be used as the next
level’s candidates</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							gef(te, ret, bag);
						}
						<span class="hljs-keyword">if</span> (!ret.length) {
							<span class="hljs-keyword">break</span>;
						}
						candidates = ret;
					}
					<span class="hljs-keyword">return</span> ret;
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-589">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-589">&#182;</a>
              </div>
              <p>//////////////////////////////////////////////////////////////////////
the query runner
//////////////////////////////////////////////////////////////////////
these are the primary caches for full-query results. The query
dispatcher functions are generated then stored here for hash lookup in
the future</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> _queryFuncCacheDOM = {}, _queryFuncCacheQSA = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-590">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-590">&#182;</a>
              </div>
              <p>this is the second level of splitting, from full-length queries (e.g.,
“div.foo .bar”) into simple query expressions (e.g., [“div.foo”,
“.bar”])</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> getStepQueryFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query)</span> {</span>
					<span class="hljs-keyword">var</span> qparts = getQueryParts(trim(query));</pre></div></div>
            
        </li>
        
        
        <li id="section-591">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-591">&#182;</a>
              </div>
              <p>if it’s trivial, avoid iteration and zipping costs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (qparts.length === <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-592">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-592">&#182;</a>
              </div>
              <p>we optimize this case here to prevent dispatch further down the
chain, potentially slowing things down. We could more elegantly
handle this in filterDown(), but it’s slower for simple things
that need to be fast (e.g., “#someId”).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> tef = getElementsFunc(qparts[<span class="hljs-number">0</span>]);
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root)</span> {</span>
							<span class="hljs-keyword">var</span> r = tef(root, []);
							<span class="hljs-keyword">if</span> (r) {
								r.nozip = <span class="hljs-literal">true</span>;
							}
							<span class="hljs-keyword">return</span> r;
						};
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-593">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-593">&#182;</a>
              </div>
              <p>otherwise, break it up and return a runner that iterates over the parts recursively</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root)</span> {</span>
						<span class="hljs-keyword">return</span> filterDown(root, qparts);
					};
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-594">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-594">&#182;</a>
              </div>
              <p>NOTES:</p>
<ul>
<li>we can’t trust QSA for anything but document-rooted queries, so
caching is split into DOM query evaluators and QSA query evaluators</li>
<li>caching query results is dirty and leak-prone (or, at a minimum,
prone to unbounded growth). Other toolkits may go this route, but
they totally destroy their own ability to manage their memory
footprint. If we implement it, it should only ever be with a fixed
total element reference # limit and an LRU-style algorithm since JS
has no weakref support. Caching compiled query evaluators is also
potentially problematic, but even on large documents the size of the
query evaluators is often &lt; 100 function objects per evaluator (and
LRU can be applied if it’s ever shown to be an issue).</li>
<li>since IE’s QSA support is currently only for HTML documents and even
then only in IE 8’s “standards mode”, we have to detect our dispatch
route at query time and keep 2 separate caches. Ugg.
we need to determine if we think we can run a given query via
querySelectorAll or if we’ll need to fall back on DOM queries to get
there. We need a lot of information about the environment and the query
to make the determination (e.g. does it support QSA, does the query in
question work in the native QSA impl, etc.).
IE QSA queries may incorrectly include comment nodes, so we throw the
zipping function into “remove” comments mode instead of the normal “skip
it” which every other QSA-clued browser enjoys</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> noZip = has(<span class="hljs-string">'ie'</span>) ? <span class="hljs-string">'commentStrip'</span> : <span class="hljs-string">'nozip'</span>;
				<span class="hljs-keyword">var</span> qsa = <span class="hljs-string">'querySelectorAll'</span>;
				<span class="hljs-keyword">var</span> qsaAvail = !! getDoc()[qsa];</pre></div></div>
            
        </li>
        
        
        <li id="section-595">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-595">&#182;</a>
              </div>
              <p>Don’t bother with n+3 type of matches, IE complains if we modify those.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> infixSpaceRe = <span class="hljs-regexp">/\\[&gt;~+]|n\+\d|([^ \\])?([&gt;~+])([^ =])?/g</span>;
				<span class="hljs-keyword">var</span> infixSpaceFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(match, pre, ch, post)</span> {</span>
					<span class="hljs-keyword">return</span> ch ? (pre ? pre + <span class="hljs-string">' '</span> : <span class="hljs-string">''</span>) + ch + (post ? <span class="hljs-string">' '</span> + post : <span class="hljs-string">''</span>) : match;
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-596">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-596">&#182;</a>
              </div>
              <p>Don’t apply the infixSpaceRe to attribute value selectors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> attRe = <span class="hljs-regexp">/([^[]*)([^\]]*])?/g</span>;
				<span class="hljs-keyword">var</span> attFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(match, nonAtt, att)</span> {</span>
					<span class="hljs-keyword">return</span> nonAtt.replace(infixSpaceRe, infixSpaceFunc) + (att || <span class="hljs-string">''</span>);
				};
				<span class="hljs-keyword">var</span> getQueryFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query, forceDOM)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-597">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-597">&#182;</a>
              </div>
              <p>Normalize query. The CSS3 selectors spec allows for omitting spaces around
infix operators, &gt;, ~ and +
Do the work here since detection for spaces is used as a simple “not use QSA”
test below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					query = query.replace(attRe, attFunc);
					<span class="hljs-keyword">if</span> (qsaAvail) {</pre></div></div>
            
        </li>
        
        
        <li id="section-598">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-598">&#182;</a>
              </div>
              <p>if we’ve got a cached variant and we think we can do it, run it!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> qsaCached = _queryFuncCacheQSA[query];
						<span class="hljs-keyword">if</span> (qsaCached &amp;&amp; !forceDOM) {
							<span class="hljs-keyword">return</span> qsaCached;
						}
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-599">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-599">&#182;</a>
              </div>
              <p>else if we’ve got a DOM cached variant, assume that we already know
all we need to and use it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> domCached = _queryFuncCacheDOM[query];
					<span class="hljs-keyword">if</span> (domCached) {
						<span class="hljs-keyword">return</span> domCached;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-600">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-600">&#182;</a>
              </div>
              <p>TODO:
    today we’re caching DOM and QSA branches separately so we
    recalc useQSA every time. If we had a way to tag root+query
    efficiently, we’d be in good shape to do a global cache.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> qcz = query.charAt(<span class="hljs-number">0</span>);
					<span class="hljs-keyword">var</span> nospace = -<span class="hljs-number">1</span> === query.indexOf(<span class="hljs-string">' '</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-601">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-601">&#182;</a>
              </div>
              <p>byId searches are wicked fast compared to QSA, even when filtering
is required</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (query.indexOf(<span class="hljs-string">'#'</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; nospace) {
						forceDOM = <span class="hljs-literal">true</span>;
					}
					<span class="hljs-keyword">var</span> useQSA = qsaAvail &amp;&amp; !forceDOM &amp;&amp; specials.indexOf(qcz) === -<span class="hljs-number">1</span> &amp;&amp; (!has(<span class="hljs-string">'ie'</span>) || query.indexOf(<span class="hljs-string">':'</span>) === -<span class="hljs-number">1</span>) &amp;&amp; !(cssCaseBug &amp;&amp; query.indexOf(<span class="hljs-string">'.'</span>) &gt;= <span class="hljs-number">0</span>) &amp;&amp; query.indexOf(<span class="hljs-string">':contains'</span>) === -<span class="hljs-number">1</span> &amp;&amp; query.indexOf(<span class="hljs-string">':checked'</span>) === -<span class="hljs-number">1</span> &amp;&amp; query.indexOf(<span class="hljs-string">'|='</span>) === -<span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-602">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-602">&#182;</a>
              </div>
              <p>TODO:
    if we’ve got a descendant query (e.g., “&gt; .thinger” instead of
    just “.thinger”) in a QSA-able doc, but are passed a child as a
    root, it should be possible to give the item a synthetic ID and
    trivially rewrite the query to the form “#synid &gt; .thinger” to
    use the QSA branch</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (useQSA) {
						<span class="hljs-keyword">var</span> tq = specials.indexOf(query.charAt(query.length - <span class="hljs-number">1</span>)) &gt;= <span class="hljs-number">0</span> ? query + <span class="hljs-string">' *'</span> : query;
						<span class="hljs-keyword">return</span> _queryFuncCacheQSA[query] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root)</span> {</span>
							<span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-603">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-603">&#182;</a>
              </div>
              <p>the QSA system contains an egregious spec bug which
limits us, effectively, to only running QSA queries over
entire documents.  See:
    <a href="http://ejohn.org/blog/thoughts-on-queryselectorall/">http://ejohn.org/blog/thoughts-on-queryselectorall/</a>
despite this, we can also handle QSA runs on simple
selectors, but we don’t want detection to be expensive
so we’re just checking for the presence of a space char
right now. Not elegant, but it’s cheaper than running
the query parser when we might not need to</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (!(<span class="hljs-number">9</span> === root.nodeType || nospace)) {
									<span class="hljs-keyword">throw</span> <span class="hljs-string">''</span>;
								}
								<span class="hljs-keyword">var</span> r = root[qsa](tq);</pre></div></div>
            
        </li>
        
        
        <li id="section-604">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-604">&#182;</a>
              </div>
              <p>skip expensive duplication checks and just wrap in a NodeList</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								r[noZip] = <span class="hljs-literal">true</span>;
								<span class="hljs-keyword">return</span> r;
							} <span class="hljs-keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-605">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-605">&#182;</a>
              </div>
              <p>else run the DOM branch on this query, ensuring that we
default that way in the future</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">return</span> getQueryFunc(query, <span class="hljs-literal">true</span>)(root);
							}
						};
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-606">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-606">&#182;</a>
              </div>
              <p>DOM branch</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> parts = query.match(<span class="hljs-regexp">/([^\s,](?:"(?:\\.|[^"])+"|'(?:\\.|[^'])+'|[^,])*)/g</span>);
						<span class="hljs-keyword">return</span> _queryFuncCacheDOM[query] = parts.length &lt; <span class="hljs-number">2</span> ? getStepQueryFunc(query) : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root)</span> {</span>
							<span class="hljs-keyword">var</span> pindex = <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-607">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-607">&#182;</a>
              </div>
              <p>avoid array alloc for every invocation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								ret = [],
								tp;
							<span class="hljs-keyword">while</span> (tp = parts[pindex++]) {
								ret = ret.concat(getStepQueryFunc(tp)(root));
							}
							<span class="hljs-keyword">return</span> ret;
						};
					}
				};
				<span class="hljs-keyword">var</span> _zipIdx = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-608">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-608">&#182;</a>
              </div>
              <p>NOTE:
    this function is Moo inspired, but our own impl to deal correctly
    with XML in IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> _nodeUID = has(<span class="hljs-string">'ie'</span>) ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
						<span class="hljs-keyword">if</span> (caseSensitive) {</pre></div></div>
            
        </li>
        
        
        <li id="section-609">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-609">&#182;</a>
              </div>
              <p>XML docs don’t have uniqueID on their nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> node.getAttribute(<span class="hljs-string">'_uid'</span>) || node.setAttribute(<span class="hljs-string">'_uid'</span>, ++_zipIdx) || _zipIdx;
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">return</span> node.uniqueID;
						}
					} : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
						<span class="hljs-keyword">return</span> node._uid || (node._uid = ++_zipIdx);
					};</pre></div></div>
            
        </li>
        
        
        <li id="section-610">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-610">&#182;</a>
              </div>
              <p>determine if a node in is unique in a “bag”. In this case we don’t want
to flatten a list of unique items, but rather just tell if the item in
question is already in the bag. Normally we’d just use hash lookup to do
this for us but IE’s DOM is busted so we can’t really count on that. On
the upside, it gives us a built in unique ID function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> _isUnique = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, bag)</span> {</span>
					<span class="hljs-keyword">if</span> (!bag) {
						<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
					}
					<span class="hljs-keyword">var</span> id = _nodeUID(node);
					<span class="hljs-keyword">if</span> (!bag[id]) {
						<span class="hljs-keyword">return</span> bag[id] = <span class="hljs-number">1</span>;
					}
					<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-611">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-611">&#182;</a>
              </div>
              <p>attempt to efficiently determine if an item in a list is a dupe,
returning a list of “uniques”, hopefully in document order</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> _zipIdxName = <span class="hljs-string">'_zipIdx'</span>;
				<span class="hljs-keyword">var</span> _zip = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr)</span> {</span>
					<span class="hljs-keyword">if</span> (arr &amp;&amp; arr.nozip) {
						<span class="hljs-keyword">return</span> arr;
					}
					<span class="hljs-keyword">var</span> ret = [];
					<span class="hljs-keyword">if</span> (!arr || !arr.length) {
						<span class="hljs-keyword">return</span> ret;
					}
					<span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>]) {
						ret.push(arr[<span class="hljs-number">0</span>]);
					}
					<span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) {
						<span class="hljs-keyword">return</span> ret;
					}
					_zipIdx++;</pre></div></div>
            
        </li>
        
        
        <li id="section-612">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-612">&#182;</a>
              </div>
              <p>we have to fork here for IE and XML docs because we can’t set
expandos on their nodes (apparently). <em>sigh</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> x, te;
					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>) &amp;&amp; caseSensitive) {
						<span class="hljs-keyword">var</span> szidx = _zipIdx + <span class="hljs-string">''</span>;
						arr[<span class="hljs-number">0</span>].setAttribute(_zipIdxName, szidx);
						<span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; te = arr[x]; x++) {
							<span class="hljs-keyword">if</span> (arr[x].getAttribute(_zipIdxName) !== szidx) {
								ret.push(te);
							}
							te.setAttribute(_zipIdxName, szidx);
						}
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>) &amp;&amp; arr.commentStrip) {
						<span class="hljs-keyword">try</span> {
							<span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; te = arr[x]; x++) {
								<span class="hljs-keyword">if</span> (_isElement(te)) {
									ret.push(te);
								}
							}
						} <span class="hljs-keyword">catch</span> (e) {}
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>]) {
							arr[<span class="hljs-number">0</span>][_zipIdxName] = _zipIdx;
						}
						<span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; te = arr[x]; x++) {
							<span class="hljs-keyword">if</span> (arr[x][_zipIdxName] !== _zipIdx) {
								ret.push(te);
							}
							te[_zipIdxName] = _zipIdx;
						}
					}
					<span class="hljs-keyword">return</span> ret;
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-613">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-613">&#182;</a>
              </div>
              <p>the main executor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> query = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query, root)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-614">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-614">&#182;</a>
              </div>
              <p>summary:
    Returns nodes which match the given CSS3 selector, searching the
    entire document by default but optionally taking a node to scope
    the search by. Returns an array.
description:
    dojo.query() is the swiss army knife of DOM node manipulation in
    Dojo. Much like Prototype’s “$$” (bling-bling) function or JQuery’s
    “$” function, dojo.query provides robust, high-performance
    CSS-based node selector support with the option of scoping searches
    to a particular sub-tree of a document.</p>
<pre><code>Supported Selectors:
--------------------

acme supports a rich set of CSS3 selectors, including:

- class selectors (e.g., `.foo`)
- node type selectors like `span`
- ` ` descendant selectors
- `&gt;` child element selectors
- `#foo` style ID selectors
- `*` universal selector
- `~`, the preceded-by sibling selector
- `+`, the immediately preceded-by sibling selector
- attribute queries:
    - `[foo]` attribute presence selector
    - `[foo='bar']` attribute value exact match
    - `[foo~='bar']` attribute value list item match
    - `[foo^='bar']` attribute start match
    - `[foo$='bar']` attribute end match
    - `[foo*='bar']` attribute substring match
- `:first-child`, `:last-child`, and `:only-child` positional selectors
- `:empty` content emtpy selector
- `:checked` pseudo selector
- `:nth-child(n)`, `:nth-child(2n+1)` style positional calculations
- `:nth-child(even)`, `:nth-child(odd)` positional selectors
- `:not(...)` negation pseudo selectors

Any legal combination of these selectors will work with
`dojo.query()`, including compound selectors ("," delimited).
Very complex and useful searches can be constructed with this
palette of selectors and when combined with functions for
manipulation presented by dojo/NodeList, many types of DOM
manipulation operations become very straightforward.

Unsupported Selectors:
----------------------

While dojo.query handles many CSS3 selectors, some fall outside of
what's reasonable for a programmatic node querying engine to
handle. Currently unsupported selectors include:

- namespace-differentiated selectors of any form
- all `::` pseduo-element selectors
- certain pseudo-selectors which don't get a lot of day-to-day use:
    - `:root`, `:lang()`, `:target`, `:focus`
- all visual and state selectors:
    - `:root`, `:active`, `:hover`, `:visited`, `:link`,
          `:enabled`, `:disabled`
    - `:*-of-type` pseudo selectors

dojo.query and XML Documents:
-----------------------------

`dojo.query` (as of dojo 1.2) supports searching XML documents
in a case-sensitive manner. If an HTML document is served with
a doctype that forces case-sensitivity (e.g., XHTML 1.1
Strict), dojo.query() will detect this and "do the right
thing". Case sensitivity is dependent upon the document being
searched and not the query used. It is therefore possible to
use case-sensitive queries on strict sub-documents (iframes,
etc.) or XML documents while still assuming case-insensitivity
for a host/root document.

Non-selector Queries:
---------------------

If something other than a String is passed for the query,
`dojo.query` will return a new `dojo/NodeList` instance
constructed from that parameter alone and all further
processing will stop. This means that if you have a reference
to a node or NodeList, you can quickly construct a new NodeList
from the original by calling `dojo.query(node)` or
`dojo.query(list)`.
</code></pre><p>query:
    The CSS3 expression to match against. For details on the syntax of
    CSS3 selectors, see <a href="http://www.w3.org/TR/css3-selectors/#selectors">http://www.w3.org/TR/css3-selectors/#selectors</a>
root:
    A DOMNode (or node id) to scope the search from. Optional.
returns: Array
example:
    search the entire document for elements with the class “foo”:
|    dojo.query(“.foo”);
    these elements will match:
|    <span class="foo"></span>
|    <span class="foo bar"></span>
|    <p class="thud foo"></p>
example:
    search the entire document for elements with the classes “foo” <em>and</em> “bar”:
|    dojo.query(“.foo.bar”);
    these elements will match:
|    <span class="foo bar"></span>
    while these will not:
|    <span class="foo"></span>
|    <p class="thud foo"></p>
example:
    find <code>&lt;span&gt;</code> elements which are descendants of paragraphs and
    which have a “highlighted” class:
|    dojo.query(“p span.highlighted”);
    the innermost span in this fragment matches:
|    <p class="foo">
|        <span>…
|            <span class="highlighted foo bar">…</span>
|        </span>
|    </p>
example:
    set an “odd” class on all odd table rows inside of the table
    <code>#tabular_data</code>, using the <code>&gt;</code> (direct child) selector to avoid
    affecting any nested tables:
|    dojo.query(“#tabular_data &gt; tbody &gt; tr:nth-child(odd)”).addClass(“odd”);
example:
    remove all elements with the class “error” from the document
    and store them in a list:
|    var errors = dojo.query(“.error”).orphan();
example:
    add an onclick handler to every submit button in the document
    which causes the form to be sent via Ajax instead:
|    dojo.query(“input[type=’submit’]”).onclick(function(e){
|        dojo.stopEvent(e); // prevent sending the form
|        var btn = e.target;
|        dojo.xhrPost({
|            form: btn.form,
|            load: function(data){
|                // replace the form with the response
|                var div = dojo.doc.createElement(“div”);
|                dojo.place(div, btn.form, “after”);
|                div.innerHTML = data;
|                dojo.style(btn.form, “display”, “none”);
|            }
|        });
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					root = root || getDoc();</pre></div></div>
            
        </li>
        
        
        <li id="section-615">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-615">&#182;</a>
              </div>
              <p>throw the big case sensitivity switch</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> od = root.ownerDocument || root;</pre></div></div>
            
        </li>
        
        
        <li id="section-616">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-616">&#182;</a>
              </div>
              <p>root is either Document or a node inside the document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					caseSensitive = od.createElement(<span class="hljs-string">'div'</span>)
						.tagName === <span class="hljs-string">'div'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-617">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-617">&#182;</a>
              </div>
              <p>NOTE:
    adding “true” as the 2nd argument to getQueryFunc is useful for
    testing the DOM branch without worrying about the
    behavior/performance of the QSA branch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> r = getQueryFunc(query)(root);</pre></div></div>
            
        </li>
        
        
        <li id="section-618">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-618">&#182;</a>
              </div>
              <p>FIXME:
    need to investigate this branch WRT #8074 and #8075</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (r &amp;&amp; r.nozip) {
						<span class="hljs-keyword">return</span> r;
					}
					<span class="hljs-keyword">return</span> _zip(r); <span class="hljs-comment">// dojo/NodeList</span>
				};
				query.filter = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(nodeList, filter, root)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-619">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-619">&#182;</a>
              </div>
              <p>summary:
    function for filtering a NodeList based on a selector, optimized for simple selectors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> tmpNodeList = [],
						parts = getQueryParts(filter),
						filterFunc = parts.length === <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-regexp">/[^\w#\.]/</span>.test(filter) ? getSimpleFilterFunc(parts[<span class="hljs-number">0</span>]) : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
							<span class="hljs-keyword">return</span> array.indexOf(query(filter, dom.byId(root)), node) !== -<span class="hljs-number">1</span>;
						};
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>, te; te = nodeList[x]; x++) {
						<span class="hljs-keyword">if</span> (filterFunc(te)) {
							tmpNodeList.push(te);
						}
					}
					<span class="hljs-keyword">return</span> tmpNodeList;
				};
				<span class="hljs-keyword">return</span> query;
			});
		},
		<span class="hljs-string">'dojo/errors/RequestTimeoutError'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/errors/RequestTimeoutError'</span>, [
				<span class="hljs-string">'./create'</span>,
				<span class="hljs-string">'./RequestError'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(create, RequestError)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-620">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-620">&#182;</a>
              </div>
              <p>module:
    dojo/errors/RequestTimeoutError</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             return function(){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-621">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-621">&#182;</a>
              </div>
              <p>summary:
    TODOC</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				return create('RequestTimeoutError', null, RequestError, {
					dojoType: 'timeout'
				});
			});
		},
		'dojo/dom-style': function () {
			define('dojo/dom-style', [
				'./sniff',
				'./dom'
			], function (has, dom) {</pre></div></div>
            
        </li>
        
        
        <li id="section-622">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-622">&#182;</a>
              </div>
              <p>module:</p>
<pre><code>dojo/dom-style
</code></pre><p>=============================</p>

            </div>
            
        </li>
        
        
        <li id="section-623">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-623">&#182;</a>
              </div>
              <h1 id="style-functions">Style Functions</h1>

            </div>
            
        </li>
        
        
        <li id="section-624">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-624">&#182;</a>
              </div>
              <p>getComputedStyle drives most of the style code.
Wherever possible, reuse the returned object.</p>
<p>API functions below that need to access computed styles accept an
optional computedStyle parameter.
If this parameter is omitted, the functions will call getComputedStyle themselves.
This way, calling code can access computedStyle once, and then pass the reference to
multiple API functions.
Although we normally eschew argument validation at this
level, here we test argument ‘node’ for (duck)type,
by testing nodeType, ecause ‘document’ is the ‘parentNode’ of ‘body’
it is frequently sent to this function even
though it is not Element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> getComputedStyle, style = {};
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'webkit'</span>)) {
					getComputedStyle = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
						<span class="hljs-keyword">var</span> s;
						<span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span>) {
							<span class="hljs-keyword">var</span> dv = node.ownerDocument.defaultView;
							s = dv.getComputedStyle(node, <span class="hljs-literal">null</span>);
							<span class="hljs-keyword">if</span> (!s &amp;&amp; node.style) {
								node.style.display = <span class="hljs-string">''</span>;
								s = dv.getComputedStyle(node, <span class="hljs-literal">null</span>);
							}
						}
						<span class="hljs-keyword">return</span> s || {};
					};
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>) &amp;&amp; (has(<span class="hljs-string">'ie'</span>) &lt; <span class="hljs-number">9</span> || has(<span class="hljs-string">'quirks'</span>))) {
					getComputedStyle = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-625">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-625">&#182;</a>
              </div>
              <p>IE (as of 7) doesn’t expose Element like sane browsers
currentStyle can be null on IE8!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> node.nodeType === <span class="hljs-number">1</span> &amp;&amp; node.currentStyle ? node.currentStyle : {};
					};
				} <span class="hljs-keyword">else</span> {
					getComputedStyle = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
						<span class="hljs-keyword">return</span> node.nodeType === <span class="hljs-number">1</span> ? node.ownerDocument.defaultView.getComputedStyle(node, <span class="hljs-literal">null</span>) : {};
					};
				}
				style.getComputedStyle = getComputedStyle;
				<span class="hljs-comment">/*=====
             style.getComputedStyle = function(node){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-626">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-626">&#182;</a>
              </div>
              <p>summary:
    Returns a “computed style” object.</p>
<p>description:
    Gets a “computed style” object which can be used to gather
    information about the current state of the rendered node.</p>
<pre><code>Note that <span class="hljs-keyword">this</span> may behave differently on different browsers.
Values may have different formats and value encodings across
browsers.

Note also that <span class="hljs-keyword">this</span> method is expensive.  Wherever possible,
reuse the returned object.

Use the dojo.style() method <span class="hljs-keyword">for</span> more consistent (pixelized)
<span class="hljs-keyword">return</span> values.
</code></pre><p>node: DOMNode
    A reference to a DOM node. Does NOT support taking an
    ID string for speed reasons.
example:
|    dojo.getComputedStyle(dojo.byId(‘foo’)).borderWidth;</p>
<p>example:
    Reusing the returned object, avoiding multiple lookups:
|    var cs = dojo.getComputedStyle(dojo.byId(“someNode”));
|    var w = cs.width, h = cs.height;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             return; // CSS2Properties
             };
             =====*/
				var toPixel;
				if (!has('ie')) {
					toPixel = function (element, value) {</pre></div></div>
            
        </li>
        
        
        <li id="section-627">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-627">&#182;</a>
              </div>
              <p>style values can be floats, client code may want
to round for integer pixels.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-built_in">parseFloat</span>(value) || <span class="hljs-number">0</span>;
					};
				} <span class="hljs-keyword">else</span> {
					toPixel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(element, avalue)</span> {</span>
						<span class="hljs-keyword">if</span> (!avalue) {
							<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-628">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-628">&#182;</a>
              </div>
              <p>on IE7, medium is usually 4 pixels</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (avalue === <span class="hljs-string">'medium'</span>) {
							<span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-629">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-629">&#182;</a>
              </div>
              <p>style values can be floats, client code may
want to round this value for integer pixels.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (avalue.slice &amp;&amp; avalue.slice(-<span class="hljs-number">2</span>) === <span class="hljs-string">'px'</span>) {
							<span class="hljs-keyword">return</span> <span class="hljs-built_in">parseFloat</span>(avalue);
						}
						<span class="hljs-keyword">var</span> s = element.style,
							rs = element.runtimeStyle,
							cs = element.currentStyle,
							sLeft = s.left,
							rsLeft = rs.left;
						rs.left = cs.left;
						<span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-630">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-630">&#182;</a>
              </div>
              <p>‘avalue’ may be incompatible with style.left, which can cause IE to throw
this has been observed for border widths using “thin”, “medium”, “thick” constants
those particular constants could be trapped by a lookup
but perhaps there are more</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							s.left = avalue;
							avalue = s.pixelLeft;
						} <span class="hljs-keyword">catch</span> (e) {
							avalue = <span class="hljs-number">0</span>;
						}
						s.left = sLeft;
						rs.left = rsLeft;
						<span class="hljs-keyword">return</span> avalue;
					};
				}
				style.toPixelValue = toPixel;
				<span class="hljs-comment">/*=====
             style.toPixelValue = function(node, value){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-631">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-631">&#182;</a>
              </div>
              <p>summary:
    converts style value to pixels on IE or return a numeric value.
node: DOMNode
value: String
returns: Number</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/</pre></div></div>
            
        </li>
        
        
        <li id="section-632">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-632">&#182;</a>
              </div>
              <p>FIXME: there opacity quirks on FF that we haven’t ported over. Hrm.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> astr = <span class="hljs-string">'DXImageTransform.Microsoft.Alpha'</span>;
				<span class="hljs-keyword">var</span> af = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n, f)</span> {</span>
					<span class="hljs-keyword">try</span> {
						<span class="hljs-keyword">return</span> n.filters.item(astr);
					} <span class="hljs-keyword">catch</span> (e) {
						<span class="hljs-keyword">return</span> f ? {} : <span class="hljs-literal">null</span>;
					}
				};
				<span class="hljs-keyword">var</span> _getOpacity = has(<span class="hljs-string">'ie'</span>) &lt; <span class="hljs-number">9</span> || has(<span class="hljs-string">'ie'</span>) &amp;&amp; has(<span class="hljs-string">'quirks'</span>) ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
						<span class="hljs-keyword">try</span> {
							<span class="hljs-keyword">return</span> af(node)
								.Opacity / <span class="hljs-number">100</span>; <span class="hljs-comment">// Number</span>
						} <span class="hljs-keyword">catch</span> (e) {
							<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// Number</span>
						}
					} : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
						<span class="hljs-keyword">return</span> getComputedStyle(node)
							.opacity;
					};
				<span class="hljs-keyword">var</span> _setOpacity = has(<span class="hljs-string">'ie'</span>) &lt; <span class="hljs-number">9</span> || has(<span class="hljs-string">'ie'</span>) &amp;&amp; has(<span class="hljs-string">'quirks'</span>) ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, opacity)</span> {</span>
						<span class="hljs-keyword">var</span> ov = opacity * <span class="hljs-number">100</span>,
							opaque = opacity === <span class="hljs-number">1</span>;
						node.style.zoom = opaque ? <span class="hljs-string">''</span> : <span class="hljs-number">1</span>;
						<span class="hljs-keyword">if</span> (!af(node)) {
							<span class="hljs-keyword">if</span> (opaque) {
								<span class="hljs-keyword">return</span> opacity;
							}
							node.style.filter += <span class="hljs-string">' progid:'</span> + astr + <span class="hljs-string">'(Opacity='</span> + ov + <span class="hljs-string">')'</span>;
						} <span class="hljs-keyword">else</span> {
							af(node, <span class="hljs-number">1</span>)
								.Opacity = ov;
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-633">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-633">&#182;</a>
              </div>
              <p>on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),
but still update the opacity value so we can get a correct reading if it is read later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						af(node, <span class="hljs-number">1</span>)
							.Enabled = !opaque;
						<span class="hljs-keyword">if</span> (node.tagName.toLowerCase() === <span class="hljs-string">'tr'</span>) {
							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> td = node.firstChild; td; td = td.nextSibling) {
								<span class="hljs-keyword">if</span> (td.tagName.toLowerCase() === <span class="hljs-string">'td'</span>) {
									_setOpacity(td, opacity);
								}
							}
						}
						<span class="hljs-keyword">return</span> opacity;
					} : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, opacity)</span> {</span>
						<span class="hljs-keyword">return</span> node.style.opacity = opacity;
					};
				<span class="hljs-keyword">var</span> _pixelNamesCache = {
					left: <span class="hljs-literal">true</span>,
					top: <span class="hljs-literal">true</span>
				};
				<span class="hljs-keyword">var</span> _pixelRegExp = <span class="hljs-regexp">/margin|padding|width|height|max|min|offset/</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-634">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-634">&#182;</a>
              </div>
              <p>|border</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_toStyleValue</span><span class="hljs-params">(node, type, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-635">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-635">&#182;</a>
              </div>
              <p>TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					type = type.toLowerCase();
					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>)) {
						<span class="hljs-keyword">if</span> (value === <span class="hljs-string">'auto'</span>) {
							<span class="hljs-keyword">if</span> (type === <span class="hljs-string">'height'</span>) {
								<span class="hljs-keyword">return</span> node.offsetHeight;
							}
							<span class="hljs-keyword">if</span> (type === <span class="hljs-string">'width'</span>) {
								<span class="hljs-keyword">return</span> node.offsetWidth;
							}
						}
						<span class="hljs-keyword">if</span> (type === <span class="hljs-string">'fontweight'</span>) {
							<span class="hljs-keyword">switch</span> (value) {
							<span class="hljs-keyword">case</span> <span class="hljs-number">700</span>:
								<span class="hljs-keyword">return</span> <span class="hljs-string">'bold'</span>;
							<span class="hljs-keyword">case</span> <span class="hljs-number">400</span>:
							<span class="hljs-keyword">default</span>:
								<span class="hljs-keyword">return</span> <span class="hljs-string">'normal'</span>;
							}
						}
					}
					<span class="hljs-keyword">if</span> (!(type <span class="hljs-keyword">in</span> _pixelNamesCache)) {
						_pixelNamesCache[type] = _pixelRegExp.test(type);
					}
					<span class="hljs-keyword">return</span> _pixelNamesCache[type] ? toPixel(node, value) : value;
				}
				<span class="hljs-keyword">var</span> _floatStyle = has(<span class="hljs-string">'ie'</span>) ? <span class="hljs-string">'styleFloat'</span> : <span class="hljs-string">'cssFloat'</span>,
					_floatAliases = {
						<span class="hljs-string">'cssFloat'</span>: _floatStyle,
						<span class="hljs-string">'styleFloat'</span>: _floatStyle,
						<span class="hljs-string">'float'</span>: _floatStyle
					};</pre></div></div>
            
        </li>
        
        
        <li id="section-636">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-636">&#182;</a>
              </div>
              <p>public API</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				style.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span><span class="hljs-params">(node, name)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-637">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-637">&#182;</a>
              </div>
              <p>summary:
    Accesses styles on a node.
description:
    Getting the style value uses the computed style for the node, so the value
    will be a calculated value, not just the immediate node.style value.
    Also when getting values, use specific style names,
    like “borderBottomWidth” instead of “border” since compound values like
    “border” are not necessarily reflected as expected.
    If you want to get node dimensions, use <code>dojo.marginBox()</code>,
    <code>dojo.contentBox()</code> or <code>dojo.position()</code>.
node: DOMNode|String
    id or reference to node to get style for
name: String?
    the style property to get
example:
    Passing only an ID or node returns the computed style object of
    the node:
|    dojo.getStyle(“thinger”);
example:
    Passing a node and a style property returns the current
    normalized, computed value for that property:
|    dojo.getStyle(“thinger”, “opacity”); // 1 by default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> n = dom.byId(node),
						l = <span class="hljs-built_in">arguments</span>.length,
						op = name === <span class="hljs-string">'opacity'</span>;
					<span class="hljs-keyword">if</span> (l === <span class="hljs-number">2</span> &amp;&amp; op) {
						<span class="hljs-keyword">return</span> _getOpacity(n);
					}
					name = _floatAliases[name] || name;
					<span class="hljs-keyword">var</span> s = style.getComputedStyle(n);
					<span class="hljs-keyword">return</span> l === <span class="hljs-number">1</span> ? s : _toStyleValue(n, name, s[name] || n.style[name]); <span class="hljs-comment">/* CSS2Properties||String||Number */</span>
				};
				style.set = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setStyle</span><span class="hljs-params">(node, name, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-638">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-638">&#182;</a>
              </div>
              <p>summary:
    Sets styles on a node.
node: DOMNode|String
    id or reference to node to set style for
name: String|Object
    the style property to set in DOM-accessor format
    (“borderWidth”, not “border-width”) or an object with key/value
    pairs suitable for setting each property.
value: String?
    If passed, sets value on the node for style, handling
    cross-browser concerns.  When setting a pixel value,
    be sure to include “px” in the value. For instance, top: “200px”.
    Otherwise, in some cases, some browsers will not apply the style.</p>
<p>example:
    Passing a node, a style property, and a value changes the
    current display of the node and returns the new computed value
|    dojo.setStyle(“thinger”, “opacity”, 0.5); // == 0.5</p>
<p>example:
    Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
|    dojo.setStyle(“thinger”, {
|        “opacity”: 0.5,
|        “border”: “3px solid black”,
|        “height”: “300px”
|    });</p>
<p>example:
    When the CSS style property is hyphenated, the JavaScript property is camelCased.
    font-size becomes fontSize, and so on.
|    dojo.setStyle(“thinger”,{
|        fontSize:”14pt”,
|        letterSpacing:”1.2em”
|    });</p>
<p>example:
    dojo/NodeList implements .style() using the same syntax, omitting the “node” parameter, calling
    dojo.style() on every element of the list. See: <code>dojo.query()</code> and <code>dojo/NodeList</code>
|    dojo.query(“.someClassName”).style(“visibility”,”hidden”);
|    // or
|    dojo.query(“#baz &gt; div”).style({
|        opacity:0.75,
|        fontSize:”13pt”
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> n = dom.byId(node),
						l = <span class="hljs-built_in">arguments</span>.length,
						op = name === <span class="hljs-string">'opacity'</span>;
					name = _floatAliases[name] || name;
					<span class="hljs-keyword">if</span> (l === <span class="hljs-number">3</span>) {
						<span class="hljs-keyword">return</span> op ? _setOpacity(n, value) : n.style[name] = value; <span class="hljs-comment">// Number</span>
					}
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">in</span> name) {
						style.set(node, x, name[x]);
					}
					<span class="hljs-keyword">return</span> style.getComputedStyle(n);
				};
				<span class="hljs-keyword">return</span> style;
			});
		},
		<span class="hljs-string">'dojo/dom-geometry'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./sniff'</span>,
				<span class="hljs-string">'./_base/window'</span>,
				<span class="hljs-string">'./dom'</span>,
				<span class="hljs-string">'./dom-style'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(has, win, dom, style)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-639">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-639">&#182;</a>
              </div>
              <p>module:
    dojo/dom-geometry
the result object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> geom = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-640">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-640">&#182;</a>
              </div>
              <p>Box functions will assume this model.
On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.
Can be set to change behavior of box setters.
can be either:
“border-box”
“content-box” (default)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				geom.boxModel = <span class="hljs-string">'content-box'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-641">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-641">&#182;</a>
              </div>
              <p>We punt per-node box mode testing completely.
If anybody cares, we can provide an additional (optional) unit
that overrides existing code to include per-node box sensitivity.
Opera documentation claims that Opera 9 uses border-box in BackCompat mode.
but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.
IIRC, earlier versions of Opera did in fact use border-box.
Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-642">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-642">&#182;</a>
              </div>
              <p>client code may have to adjust if compatMode varies across iframes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					geom.boxModel = document.compatMode === <span class="hljs-string">'BackCompat'</span> ? <span class="hljs-string">'border-box'</span> : <span class="hljs-string">'content-box'</span>;
				}
				geom.getPadExtents = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPadExtents</span><span class="hljs-params">(node, computedStyle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-643">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-643">&#182;</a>
              </div>
              <p>summary:
    Returns object with special values specifically useful for node
    fitting.
description:
    Returns an object with <code>w</code>, <code>h</code>, <code>l</code>, <code>t</code> properties:
|        l/t/r/b = left/top/right/bottom padding (respectively)
|        w = the total of the left and right padding
|        h = the total of the top and bottom padding
    If ‘node’ has position, l/t forms the origin for child nodes.
    The w/h are used for calculating boxes.
    Normally application code will not need to invoke this
    directly, and will use the …box… functions instead.
node: DOMNode
computedStyle: Object?
    This parameter accepts computed styles object.
    If this parameter is omitted, the functions will call
    dojo.getComputedStyle to get one. It is a better way, calling
    dojo.computedStyle once, and then pass the reference to this
    computedStyle parameter. Wherever possible, reuse the returned
    object of dojo/dom-style.getComputedStyle().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> s = computedStyle || style.getComputedStyle(node),
						px = style.toPixelValue,
						l = px(node, s.paddingLeft),
						t = px(node, s.paddingTop),
						r = px(node, s.paddingRight),
						b = px(node, s.paddingBottom);
					<span class="hljs-keyword">return</span> {
						l: l,
						t: t,
						r: r,
						b: b,
						w: l + r,
						h: t + b
					};
				};
				<span class="hljs-keyword">var</span> none = <span class="hljs-string">'none'</span>;
				geom.getBorderExtents = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBorderExtents</span><span class="hljs-params">(node, computedStyle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-644">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-644">&#182;</a>
              </div>
              <p>summary:
    returns an object with properties useful for noting the border
    dimensions.
description:</p>
<pre><code>- l/t/r/b = the sum of left/top/right/bottom border (respectively)
- w = the sum of the left and right border
- h = the sum of the top and bottom border

The w/h are used <span class="hljs-keyword">for</span> calculating boxes.
Normally application code will not need to invoke <span class="hljs-keyword">this</span>
directly, and will use the ...box... functions instead.
</code></pre><p>node: DOMNode
computedStyle: Object?
    This parameter accepts computed styles object.
    If this parameter is omitted, the functions will call
    dojo.getComputedStyle to get one. It is a better way, calling
    dojo.computedStyle once, and then pass the reference to this
    computedStyle parameter. Wherever possible, reuse the returned
    object of dojo/dom-style.getComputedStyle().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> px = style.toPixelValue,
						s = computedStyle || style.getComputedStyle(node),
						l = s.borderLeftStyle !== none ? px(node, s.borderLeftWidth) : <span class="hljs-number">0</span>,
						t = s.borderTopStyle !== none ? px(node, s.borderTopWidth) : <span class="hljs-number">0</span>,
						r = s.borderRightStyle !== none ? px(node, s.borderRightWidth) : <span class="hljs-number">0</span>,
						b = s.borderBottomStyle !== none ? px(node, s.borderBottomWidth) : <span class="hljs-number">0</span>;
					<span class="hljs-keyword">return</span> {
						l: l,
						t: t,
						r: r,
						b: b,
						w: l + r,
						h: t + b
					};
				};
				geom.getPadBorderExtents = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPadBorderExtents</span><span class="hljs-params">(node, computedStyle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-645">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-645">&#182;</a>
              </div>
              <p>summary:
    Returns object with properties useful for box fitting with
    regards to padding.
description:</p>
<pre><code>- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
- w = the sum of the left and right padding and border
- h = the sum of the top and bottom padding and border

The w/h are used <span class="hljs-keyword">for</span> calculating boxes.
Normally application code will not need to invoke <span class="hljs-keyword">this</span>
directly, and will use the ...box... functions instead.
</code></pre><p>node: DOMNode
computedStyle: Object?
    This parameter accepts computed styles object.
    If this parameter is omitted, the functions will call
    dojo.getComputedStyle to get one. It is a better way, calling
    dojo.computedStyle once, and then pass the reference to this
    computedStyle parameter. Wherever possible, reuse the returned
    object of dojo/dom-style.getComputedStyle().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> s = computedStyle || style.getComputedStyle(node),
						p = geom.getPadExtents(node, s),
						b = geom.getBorderExtents(node, s);
					<span class="hljs-keyword">return</span> {
						l: p.l + b.l,
						t: p.t + b.t,
						r: p.r + b.r,
						b: p.b + b.b,
						w: p.w + b.w,
						h: p.h + b.h
					};
				};
				geom.getMarginExtents = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMarginExtents</span><span class="hljs-params">(node, computedStyle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-646">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-646">&#182;</a>
              </div>
              <p>summary:
    returns object with properties useful for box fitting with
    regards to box margins (i.e., the outer-box).</p>
<pre><code>- l/t = marginLeft, marginTop, respectively
- w = total width, margin inclusive
- h = total height, margin inclusive

The w/h are used <span class="hljs-keyword">for</span> calculating boxes.
Normally application code will not need to invoke <span class="hljs-keyword">this</span>
directly, and will use the ...box... functions instead.
</code></pre><p>node: DOMNode
computedStyle: Object?
    This parameter accepts computed styles object.
    If this parameter is omitted, the functions will call
    dojo.getComputedStyle to get one. It is a better way, calling
    dojo.computedStyle once, and then pass the reference to this
    computedStyle parameter. Wherever possible, reuse the returned
    object of dojo/dom-style.getComputedStyle().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> s = computedStyle || style.getComputedStyle(node),
						px = style.toPixelValue,
						l = px(node, s.marginLeft),
						t = px(node, s.marginTop),
						r = px(node, s.marginRight),
						b = px(node, s.marginBottom);
					<span class="hljs-keyword">return</span> {
						l: l,
						t: t,
						r: r,
						b: b,
						w: l + r,
						h: t + b
					};
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-647">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-647">&#182;</a>
              </div>
              <p>Box getters work in any box context because offsetWidth/clientWidth
are invariant wrt box context</p>
<p>They do <em>not</em> work for display: inline objects that have padding styles
because the user agent ignores padding (it’s bogus styling in any case)</p>
<p>Be careful with IMGs because they are inline or block depending on
browser and browser mode.
Although it would be easier to read, there are not separate versions of
_getMarginBox for each browser because:</p>
<ol>
<li>the branching is not expensive</li>
<li>factoring the shared code wastes cycles (function call overhead)</li>
<li>duplicating the shared code wastes bytes</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>				geom.getMarginBox = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMarginBox</span><span class="hljs-params">(node, computedStyle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-648">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-648">&#182;</a>
              </div>
              <p>summary:
    returns an object that encodes the width, height, left and top
    positions of the node’s margin box.
node: DOMNode
computedStyle: Object?
    This parameter accepts computed styles object.
    If this parameter is omitted, the functions will call
    dojo.getComputedStyle to get one. It is a better way, calling
    dojo.computedStyle once, and then pass the reference to this
    computedStyle parameter. Wherever possible, reuse the returned
    object of dojo/dom-style.getComputedStyle().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> s = computedStyle || style.getComputedStyle(node),
						me = geom.getMarginExtents(node, s),
						l = node.offsetLeft - me.l,
						t = node.offsetTop - me.t,
						p = node.parentNode,
						px = style.toPixelValue,
						pcs;
					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'mozilla'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-649">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-649">&#182;</a>
              </div>
              <p>Mozilla:
If offsetParent has a computed overflow != visible, the offsetLeft is decreased
by the parent’s border.
We don’t want to compute the parent’s style, so instead we examine node’s
computed left/top which is more stable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> sl = <span class="hljs-built_in">parseFloat</span>(s.left),
							st = <span class="hljs-built_in">parseFloat</span>(s.top);
						<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(sl) &amp;&amp; !<span class="hljs-built_in">isNaN</span>(st)) {
							l = sl;
							t = st;
						} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-650">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-650">&#182;</a>
              </div>
              <p>If child’s computed left/top are not parseable as a number (e.g. “auto”), we
have no choice but to examine the parent’s computed style.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (p &amp;&amp; p.style) {
								pcs = style.getComputedStyle(p);
								<span class="hljs-keyword">if</span> (pcs.overflow !== <span class="hljs-string">'visible'</span>) {
									l += pcs.borderLeftStyle !== none ? px(node, pcs.borderLeftWidth) : <span class="hljs-number">0</span>;
									t += pcs.borderTopStyle !== none ? px(node, pcs.borderTopWidth) : <span class="hljs-number">0</span>;
								}
							}
						}
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (has(<span class="hljs-string">'opera'</span>) || has(<span class="hljs-string">'ie'</span>) === <span class="hljs-number">8</span> &amp;&amp; !has(<span class="hljs-string">'quirks'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-651">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-651">&#182;</a>
              </div>
              <p>On Opera and IE 8, offsetLeft/Top includes the parent’s border</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (p) {
							pcs = style.getComputedStyle(p);
							l -= pcs.borderLeftStyle !== none ? px(node, pcs.borderLeftWidth) : <span class="hljs-number">0</span>;
							t -= pcs.borderTopStyle !== none ? px(node, pcs.borderTopWidth) : <span class="hljs-number">0</span>;
						}
					}
					<span class="hljs-keyword">return</span> {
						l: l,
						t: t,
						w: node.offsetWidth + me.w,
						h: node.offsetHeight + me.h
					};
				};
				geom.getContentBox = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContentBox</span><span class="hljs-params">(node, computedStyle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-652">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-652">&#182;</a>
              </div>
              <p>summary:
    Returns an object that encodes the width, height, left and top
    positions of the node’s content box, irrespective of the
    current box model.
node: DOMNode
computedStyle: Object?
    This parameter accepts computed styles object.
    If this parameter is omitted, the functions will call
    dojo.getComputedStyle to get one. It is a better way, calling
    dojo.computedStyle once, and then pass the reference to this
    computedStyle parameter. Wherever possible, reuse the returned
    object of dojo/dom-style.getComputedStyle().
clientWidth/Height are important since the automatically account for scrollbars
fallback to offsetWidth/Height for special cases (see #3378)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> s = computedStyle || style.getComputedStyle(node),
						w = node.clientWidth,
						h, pe = geom.getPadExtents(node, s),
						be = geom.getBorderExtents(node, s);
					<span class="hljs-keyword">if</span> (!w) {
						w = node.offsetWidth;
						h = node.offsetHeight;
					} <span class="hljs-keyword">else</span> {
						h = node.clientHeight;
						be.w = be.h = <span class="hljs-number">0</span>;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-653">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-653">&#182;</a>
              </div>
              <p>On Opera, offsetLeft includes the parent’s border</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'opera'</span>)) {
						pe.l += be.l;
						pe.t += be.t;
					}
					<span class="hljs-keyword">return</span> {
						l: pe.l,
						t: pe.t,
						w: w - pe.w - be.w,
						h: h - pe.h - be.h
					};
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-654">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-654">&#182;</a>
              </div>
              <p>Box setters depend on box context because interpretation of width/height styles
vary wrt box context.</p>
<p>The value of boxModel is used to determine box context.
boxModel can be set directly to change behavior.</p>
<p>Beware of display: inline objects that have padding styles
because the user agent ignores padding (it’s a bogus setup anyway)</p>
<p>Be careful with IMGs because they are inline or block depending on
browser and browser mode.</p>
<p>Elements other than DIV may have special quirks, like built-in
margins or padding, or values not detectable via computedStyle.
In particular, margins on TABLE do not seems to appear
at all in computedStyle on Mozilla.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setBox</span><span class="hljs-params">(node, l, t, w, h, u)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-655">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-655">&#182;</a>
              </div>
              <p>summary:
    sets width/height/left/top in the current (native) box-model
    dimensions. Uses the unit passed in u.
node:
    DOM Node reference. Id string not supported for performance
    reasons.
l:
    left offset from parent.
t:
    top offset from parent.
w:
    width in current box model.
h:
    width in current box model.
u:
    unit measure to use for other measures. Defaults to “px”.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					u = u || <span class="hljs-string">'px'</span>;
					<span class="hljs-keyword">var</span> s = node.style;
					<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(l)) {
						s.left = l + u;
					}
					<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(t)) {
						s.top = t + u;
					}
					<span class="hljs-keyword">if</span> (w &gt;= <span class="hljs-number">0</span>) {
						s.width = w + u;
					}
					<span class="hljs-keyword">if</span> (h &gt;= <span class="hljs-number">0</span>) {
						s.height = h + u;
					}
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isButtonTag</span><span class="hljs-params">(node)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-656">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-656">&#182;</a>
              </div>
              <p>summary:
    True if the node is BUTTON or INPUT.type=”button”.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> node.tagName.toLowerCase() === <span class="hljs-string">'button'</span> || node.tagName.toLowerCase() === <span class="hljs-string">'input'</span> &amp;&amp; (node.getAttribute(<span class="hljs-string">'type'</span>) || <span class="hljs-string">''</span>)
						.toLowerCase() === <span class="hljs-string">'button'</span>; <span class="hljs-comment">// boolean</span>
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">usesBorderBox</span><span class="hljs-params">(node)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-657">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-657">&#182;</a>
              </div>
              <p>summary:
    True if the node uses border-box layout.
We could test the computed style of node to see if a particular box
has been specified, but there are details and we choose not to bother.
TABLE and BUTTON (and INPUT type=button) are always border-box by default.
If you have assigned a different box to either one via CSS then
box functions will break.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> geom.boxModel === <span class="hljs-string">'border-box'</span> || node.tagName.toLowerCase() === <span class="hljs-string">'table'</span> || isButtonTag(node); <span class="hljs-comment">// boolean</span>
				}
				geom.setContentSize = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setContentSize</span><span class="hljs-params">(node, box, computedStyle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-658">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-658">&#182;</a>
              </div>
              <p>summary:
    Sets the size of the node’s contents, irrespective of margins,
    padding, or borders.
node: DOMNode
box: Object
    hash with optional “w”, and “h” properties for “width”, and “height”
    respectively. All specified properties should have numeric values in whole pixels.
computedStyle: Object?
    This parameter accepts computed styles object.
    If this parameter is omitted, the functions will call
    dojo.getComputedStyle to get one. It is a better way, calling
    dojo.computedStyle once, and then pass the reference to this
    computedStyle parameter. Wherever possible, reuse the returned
    object of dojo/dom-style.getComputedStyle().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> w = box.w,
						h = box.h;
					<span class="hljs-keyword">if</span> (usesBorderBox(node)) {
						<span class="hljs-keyword">var</span> pb = geom.getPadBorderExtents(node, computedStyle);
						<span class="hljs-keyword">if</span> (w &gt;= <span class="hljs-number">0</span>) {
							w += pb.w;
						}
						<span class="hljs-keyword">if</span> (h &gt;= <span class="hljs-number">0</span>) {
							h += pb.h;
						}
					}
					setBox(node, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>, w, h);
				};
				<span class="hljs-keyword">var</span> nilExtents = {
					l: <span class="hljs-number">0</span>,
					t: <span class="hljs-number">0</span>,
					w: <span class="hljs-number">0</span>,
					h: <span class="hljs-number">0</span>
				};
				geom.setMarginBox = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMarginBox</span><span class="hljs-params">(node, box, computedStyle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-659">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-659">&#182;</a>
              </div>
              <p>summary:
    sets the size of the node’s margin box and placement
    (left/top), irrespective of box model. Think of it as a
    passthrough to setBox that handles box-model vagaries for
    you.
node: DOMNode
box: Object
    hash with optional “l”, “t”, “w”, and “h” properties for “left”, “right”, “width”, and “height”
    respectively. All specified properties should have numeric values in whole pixels.
computedStyle: Object?
    This parameter accepts computed styles object.
    If this parameter is omitted, the functions will call
    dojo.getComputedStyle to get one. It is a better way, calling
    dojo.computedStyle once, and then pass the reference to this
    computedStyle parameter. Wherever possible, reuse the returned
    object of dojo/dom-style.getComputedStyle().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> s = computedStyle || style.getComputedStyle(node),
						w = box.w,
						h = box.h,</pre></div></div>
            
        </li>
        
        
        <li id="section-660">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-660">&#182;</a>
              </div>
              <p>Some elements have special padding, margin, and box-model settings.
To use box functions you may need to set padding, margin explicitly.
Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),
						mb = geom.getMarginExtents(node, s);
					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'webkit'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-661">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-661">&#182;</a>
              </div>
              <p>on Safari (3.1.2), button nodes with no explicit size have a default margin
setting an explicit size eliminates the margin.
We have to swizzle the width to get correct margin reading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (isButtonTag(node)) {
							<span class="hljs-keyword">var</span> ns = node.style;
							<span class="hljs-keyword">if</span> (w &gt;= <span class="hljs-number">0</span> &amp;&amp; !ns.width) {
								ns.width = <span class="hljs-string">'4px'</span>;
							}
							<span class="hljs-keyword">if</span> (h &gt;= <span class="hljs-number">0</span> &amp;&amp; !ns.height) {
								ns.height = <span class="hljs-string">'4px'</span>;
							}
						}
					}
					<span class="hljs-keyword">if</span> (w &gt;= <span class="hljs-number">0</span>) {
						w = <span class="hljs-built_in">Math</span>.max(w - pb.w - mb.w, <span class="hljs-number">0</span>);
					}
					<span class="hljs-keyword">if</span> (h &gt;= <span class="hljs-number">0</span>) {
						h = <span class="hljs-built_in">Math</span>.max(h - pb.h - mb.h, <span class="hljs-number">0</span>);
					}
					setBox(node, box.l, box.t, w, h);
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-662">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-662">&#182;</a>
              </div>
              <p>=============================</p>

            </div>
            
        </li>
        
        
        <li id="section-663">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-663">&#182;</a>
              </div>
              <h1 id="positioning">Positioning</h1>

            </div>
            
        </li>
        
        
        <li id="section-664">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-664">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>				geom.isBodyLtr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBodyLtr</span><span class="hljs-params">(doc)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-665">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-665">&#182;</a>
              </div>
              <p>summary:
    Returns true if the current language is left-to-right, and false otherwise.
doc: Document?
    Optional document to query.   If unspecified, use win.doc.
returns: Boolean</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					doc = doc || win.doc;
					<span class="hljs-keyword">return</span> (win.body(doc)
						.dir || doc.documentElement.dir || <span class="hljs-string">'ltr'</span>)
						.toLowerCase() === <span class="hljs-string">'ltr'</span>; <span class="hljs-comment">// Boolean</span>
				};
				geom.docScroll = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">docScroll</span><span class="hljs-params">(doc)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-666">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-666">&#182;</a>
              </div>
              <p>summary:
    Returns an object with {node, x, y} with corresponding offsets.
doc: Document?
    Optional document to query.   If unspecified, use win.doc.
returns: Object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					doc = doc || win.doc;
					<span class="hljs-keyword">var</span> node = win.doc.parentWindow || win.doc.defaultView;</pre></div></div>
            
        </li>
        
        
        <li id="section-667">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-667">&#182;</a>
              </div>
              <p>use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-string">'pageXOffset'</span> <span class="hljs-keyword">in</span> node ? {
						x: node.pageXOffset,
						y: node.pageYOffset
					} : (node = has(<span class="hljs-string">'quirks'</span>) ? win.body(doc) : doc.documentElement) &amp;&amp; {
						x: geom.fixIeBiDiScrollLeft(node.scrollLeft || <span class="hljs-number">0</span>, doc),
						y: node.scrollTop || <span class="hljs-number">0</span>
					};
				};
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>)) {
					geom.getIeDocumentElementOffset = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIeDocumentElementOffset</span><span class="hljs-params">(doc)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-668">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-668">&#182;</a>
              </div>
              <p>summary:
    returns the offset in x and y from the document body to the
    visual edge of the page for IE
doc: Document?
    Optional document to query.   If unspecified, use win.doc.
description:
    The following values in IE contain an offset:
|        event.clientX
|        event.clientY
|        node.getBoundingClientRect().left
|        node.getBoundingClientRect().top
    But other position related values do not contain this offset,
    such as node.offsetLeft, node.offsetTop, node.style.left and
    node.style.top. The offset is always (2, 2) in LTR direction.
    When the body is in RTL direction, the offset counts the width
    of left scroll bar’s width.  This function computes the actual
    offset.
NOTE: assumes we’re being called in an IE browser</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						doc = doc || win.doc;
						<span class="hljs-keyword">var</span> de = doc.documentElement;</pre></div></div>
            
        </li>
        
        
        <li id="section-669">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-669">&#182;</a>
              </div>
              <p>only deal with HTML element here, position() handles body/quirks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>) &lt; <span class="hljs-number">8</span>) {
							<span class="hljs-keyword">var</span> r = de.getBoundingClientRect(),</pre></div></div>
            
        </li>
        
        
        <li id="section-670">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-670">&#182;</a>
              </div>
              <p>works well for IE6+</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								l = r.left,
								t = r.top;
							<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>) &lt; <span class="hljs-number">7</span>) {
								l += de.clientLeft;</pre></div></div>
            
        </li>
        
        
        <li id="section-671">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-671">&#182;</a>
              </div>
              <p>scrollbar size in strict/RTL, or,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								t += de.clientTop; <span class="hljs-comment">// HTML border size in strict</span>
							}
							<span class="hljs-keyword">return</span> {
								x: l &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : l,
								y: t &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : t
							};
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">return</span> {
								x: <span class="hljs-number">0</span>,
								y: <span class="hljs-number">0</span>
							};
						}
					};
				}
				geom.fixIeBiDiScrollLeft = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fixIeBiDiScrollLeft</span><span class="hljs-params">(scrollLeft, doc)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-672">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-672">&#182;</a>
              </div>
              <p>summary:
    In RTL direction, scrollLeft should be a negative value, but IE
    returns a positive one. All codes using documentElement.scrollLeft
    must call this function to fix this error, otherwise the position
    will offset to right when there is a horizontal scrollbar.
scrollLeft: Number
doc: Document?
    Optional document to query.   If unspecified, use win.doc.
returns: Number
In RTL direction, scrollLeft should be a negative value, but IE
returns a positive one. All codes using documentElement.scrollLeft
must call this function to fix this error, otherwise the position
will offset to right when there is a horizontal scrollbar.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					doc = doc || win.doc;
					<span class="hljs-keyword">var</span> ie = has(<span class="hljs-string">'ie'</span>);
					<span class="hljs-keyword">if</span> (ie &amp;&amp; !geom.isBodyLtr(doc)) {
						<span class="hljs-keyword">var</span> qk = has(<span class="hljs-string">'quirks'</span>),
							de = qk ? win.body(doc) : doc.documentElement,
							pwin = win.global;</pre></div></div>
            
        </li>
        
        
        <li id="section-673">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-673">&#182;</a>
              </div>
              <p>TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (ie === <span class="hljs-number">6</span> &amp;&amp; !qk &amp;&amp; pwin.frameElement &amp;&amp; de.scrollHeight &gt; de.clientHeight) {
							scrollLeft += de.clientLeft; <span class="hljs-comment">// workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels</span>
						}
						<span class="hljs-keyword">return</span> ie &lt; <span class="hljs-number">8</span> || qk ? scrollLeft + de.clientWidth - de.scrollWidth : -scrollLeft; <span class="hljs-comment">// Integer</span>
					}
					<span class="hljs-keyword">return</span> scrollLeft; <span class="hljs-comment">// Integer</span>
				};
				geom.position = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, includeScroll)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-674">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-674">&#182;</a>
              </div>
              <p>summary:
    Gets the position and size of the passed element relative to
    the viewport (if includeScroll==false), or relative to the
    document root (if includeScroll==true).</p>
<p>description:
    Returns an object of the form:
    <code>{ x: 100, y: 300, w: 20, h: 15 }</code>.
    If includeScroll==true, the x and y values will include any
    document offsets that may affect the position relative to the
    viewport.
    Uses the border-box model (inclusive of border and padding but
    not margin).  Does not act as a setter.
node: DOMNode|String
includeScroll: Boolean?
returns: Object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> db = win.body(node.ownerDocument),
						ret = node.getBoundingClientRect();
					ret = {
						x: ret.left,
						y: ret.top,
						w: ret.right - ret.left,
						h: ret.bottom - ret.top
					};
					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-675">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-675">&#182;</a>
              </div>
              <p>On IE there’s a 2px offset that we need to adjust for, see dojo.getIeDocumentElementOffset()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> offset = geom.getIeDocumentElementOffset(node.ownerDocument);</pre></div></div>
            
        </li>
        
        
        <li id="section-676">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-676">&#182;</a>
              </div>
              <p>fixes the position in IE, quirks mode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						ret.x -= offset.x + (has(<span class="hljs-string">'quirks'</span>) ? db.clientLeft + db.offsetLeft : <span class="hljs-number">0</span>);
						ret.y -= offset.y + (has(<span class="hljs-string">'quirks'</span>) ? db.clientTop + db.offsetTop : <span class="hljs-number">0</span>);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-677">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-677">&#182;</a>
              </div>
              <p>account for document scrolling
if offsetParent is used, ret value already includes scroll position
so we may have to actually remove that value if !includeScroll</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (includeScroll) {
						<span class="hljs-keyword">var</span> scroll = geom.docScroll(node.ownerDocument);
						ret.x += scroll.x;
						ret.y += scroll.y;
					}
					<span class="hljs-keyword">return</span> ret; <span class="hljs-comment">// Object</span>
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-678">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-678">&#182;</a>
              </div>
              <p>random “private” functions wildly used throughout the toolkit</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				geom.getMarginSize = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMarginSize</span><span class="hljs-params">(node, computedStyle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-679">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-679">&#182;</a>
              </div>
              <p>summary:
    returns an object that encodes the width and height of
    the node’s margin box
node: DOMNode|String
computedStyle: Object?
    This parameter accepts computed styles object.
    If this parameter is omitted, the functions will call
    dojo.getComputedStyle to get one. It is a better way, calling
    dojo.computedStyle once, and then pass the reference to this
    computedStyle parameter. Wherever possible, reuse the returned
    object of dojo/dom-style.getComputedStyle().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
					<span class="hljs-keyword">var</span> size = node.getBoundingClientRect();
					<span class="hljs-keyword">return</span> {
						w: size.right - size.left + me.w,
						h: size.bottom - size.top + me.h
					};
				};
				geom.normalizeEvent = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-680">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-680">&#182;</a>
              </div>
              <p>summary:
    Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
    offsetX, offsetY, layerX, and layerX properties
event: Object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!(<span class="hljs-string">'layerX'</span> <span class="hljs-keyword">in</span> event)) {
						event.layerX = event.offsetX;
						event.layerY = event.offsetY;
					}
					<span class="hljs-keyword">if</span> (!has(<span class="hljs-string">'dom-addeventlistener'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-681">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-681">&#182;</a>
              </div>
              <p>old IE version
FIXME: scroll position query is duped from dojo.html to
avoid dependency on that entire module. Now that HTML is in
Base, we should convert back to something similar there.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> se = event.target;
						<span class="hljs-keyword">var</span> doc = se &amp;&amp; se.ownerDocument || document;</pre></div></div>
            
        </li>
        
        
        <li id="section-682">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-682">&#182;</a>
              </div>
              <p>DO NOT replace the following to use dojo.body(), in IE, document.documentElement should be used
here rather than document.body</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> docBody = has(<span class="hljs-string">'quirks'</span>) ? doc.body : doc.documentElement;
						<span class="hljs-keyword">var</span> offset = geom.getIeDocumentElementOffset(doc);
						event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || <span class="hljs-number">0</span>, doc) - offset.x;
						event.pageY = event.clientY + (docBody.scrollTop || <span class="hljs-number">0</span>) - offset.y;
					}
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-683">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-683">&#182;</a>
              </div>
              <p>TODO: evaluate separate getters/setters for position and sizes?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> geom;
			});
		},
		<span class="hljs-string">'dojo/dom-prop'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'exports'</span>,
				<span class="hljs-string">'./_base/kernel'</span>,
				<span class="hljs-string">'./sniff'</span>,
				<span class="hljs-string">'./_base/lang'</span>,
				<span class="hljs-string">'./dom'</span>,
				<span class="hljs-string">'./dom-style'</span>,
				<span class="hljs-string">'./dom-construct'</span>,
				<span class="hljs-string">'./_base/connect'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, dojo, has, lang, dom, style, ctr, conn)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-684">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-684">&#182;</a>
              </div>
              <p>module:
    dojo/dom-prop
summary:
    This module defines the core dojo DOM properties API.
    Indirectly depends on dojo.empty() and dojo.toDom().</p>
<h1 id="todoc-summary-not-showing-up-in-output-see-https-github-com-csnover-js-doc-parse-issues-42">TODOC: summary not showing up in output, see <a href="https://github.com/csnover/js-doc-parse/issues/42">https://github.com/csnover/js-doc-parse/issues/42</a></h1>

            </div>
            
        </li>
        
        
        <li id="section-685">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-685">&#182;</a>
              </div>
              <h1 id="element-properties-functions">Element properties Functions</h1>

            </div>
            
        </li>
        
        
        <li id="section-686">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-686">&#182;</a>
              </div>
              <p>helper to connect events</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> _evtHdlrMap = {}, _ctr = <span class="hljs-number">0</span>,
					_attrId = dojo._scopeName + <span class="hljs-string">'attrid'</span>;
				exports.names = {
					<span class="hljs-string">'class'</span>: <span class="hljs-string">'className'</span>,
					<span class="hljs-string">'for'</span>: <span class="hljs-string">'htmlFor'</span>,
					tabindex: <span class="hljs-string">'tabIndex'</span>,
					readonly: <span class="hljs-string">'readOnly'</span>,
					colspan: <span class="hljs-string">'colSpan'</span>,
					frameborder: <span class="hljs-string">'frameBorder'</span>,
					rowspan: <span class="hljs-string">'rowSpan'</span>,
					valuetype: <span class="hljs-string">'valueType'</span>
				};
				exports.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProp</span><span class="hljs-params">(node, name)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-687">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-687">&#182;</a>
              </div>
              <p>summary:
    Gets a property on an HTML element.
description:
    Handles normalized getting of properties on DOM nodes.</p>
<p>node: DOMNode|String
    id or reference to the element to get the property on
name: String
    the name of the property to get.
returns:
    the value of the requested property or its default value</p>
<p>example:
|    // get the current value of the “foo” property on a node
|    dojo.getProp(dojo.byId(“nodeId”), “foo”);
|    // or we can just pass the id:
|    dojo.getProp(“nodeId”, “foo”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> lc = name.toLowerCase(),
						propName = exports.names[lc] || name;
					<span class="hljs-keyword">return</span> node[propName]; <span class="hljs-comment">// Anything</span>
				};
				exports.set = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setProp</span><span class="hljs-params">(node, name, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-688">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-688">&#182;</a>
              </div>
              <p>summary:
    Sets a property on an HTML element.
description:
    Handles normalized setting of properties on DOM nodes.</p>
<pre><code>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the <span class="hljs-keyword">default</span>
behavior will be removed and the <span class="hljs-keyword">new</span> behavior will be added
using `dojo.connect()`, meaning that event handler properties
will be normalized and that some caveats <span class="hljs-keyword">with</span> regards to
non-standard behaviors <span class="hljs-keyword">for</span> onsubmit apply. Namely that you
should cancel form submission using `dojo.stopEvent()` on the
passed event object instead of returning a boolean value from
the handler itself.
</code></pre><p>node: DOMNode|String
    id or reference to the element to set the property on
name: String|Object
    the name of the property to set, or a hash object to set
    multiple properties at once.
value: String?
    The value to set for the property
returns:
    the DOM node</p>
<p>example:
|    // use prop() to set the tab index
|    dojo.setProp(“nodeId”, “tabIndex”, 3);
|</p>
<p>example:
Set multiple values at once, including event handlers:
|    dojo.setProp(“formId”, {
|        “foo”: “bar”,
|        “tabIndex”: -1,
|        “method”: “POST”,
|        “onsubmit”: function(e){
|            // stop submitting the form. Note that the IE behavior
|            // of returning true or false will have no effect here
|            // since our handler is connect()ed to the built-in
|            // onsubmit behavior and so we need to use
|            // dojo.stopEvent() to ensure that the submission
|            // doesn’t proceed.
|            dojo.stopEvent(e);
|
|            // submit the form with Ajax
|            dojo.xhrPost({ form: “formId” });
|        }
|    });</p>
<p>example:
Style is s special case: Only set with an object hash of styles
|    dojo.setProp(“someNode”,{
|        id:”bar”,
|        style:{
|            width:”200px”, height:”100px”, color:”#000”
|        }
|    });</p>
<p>example:
Again, only set style as an object hash of styles:
|    var obj = { color:”#fff”, backgroundColor:”#000” };
|    dojo.setProp(“someNode”, “style”, obj);
|
|    // though shorter to use <code>dojo.style()</code> in this case:
|    dojo.style(“someNode”, obj);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> l = <span class="hljs-built_in">arguments</span>.length;
					<span class="hljs-keyword">if</span> (l === <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-keyword">typeof</span> name !== <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-689">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-689">&#182;</a>
              </div>
              <p>inline’d type check
the object form of setter: the 2nd argument is a dictionary</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">in</span> name) {
							exports.set(node, x, name[x]);
						}
						<span class="hljs-keyword">return</span> node; <span class="hljs-comment">// DomNode</span>
					}
					<span class="hljs-keyword">var</span> lc = name.toLowerCase(),
						propName = exports.names[lc] || name;
					<span class="hljs-keyword">if</span> (propName === <span class="hljs-string">'style'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-690">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-690">&#182;</a>
              </div>
              <p>inline’d type check
special case: setting a style</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						style.set(node, value);
						<span class="hljs-keyword">return</span> node; <span class="hljs-comment">// DomNode</span>
					}
					<span class="hljs-keyword">if</span> (propName === <span class="hljs-string">'innerHTML'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-691">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-691">&#182;</a>
              </div>
              <p>special case: assigning HTML
the hash lists elements with read-only innerHTML on IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>) &amp;&amp; node.tagName.toLowerCase() <span class="hljs-keyword">in</span> {
							col: <span class="hljs-number">1</span>,
							colgroup: <span class="hljs-number">1</span>,
							table: <span class="hljs-number">1</span>,
							tbody: <span class="hljs-number">1</span>,
							tfoot: <span class="hljs-number">1</span>,
							thead: <span class="hljs-number">1</span>,
							tr: <span class="hljs-number">1</span>,
							title: <span class="hljs-number">1</span>
						}) {
							ctr.empty(node);
							node.appendChild(ctr.toDom(value, node.ownerDocument));
						} <span class="hljs-keyword">else</span> {
							node[propName] = value;
						}
						<span class="hljs-keyword">return</span> node; <span class="hljs-comment">// DomNode</span>
					}
					<span class="hljs-keyword">if</span> (lang.isFunction(value)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-692">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-692">&#182;</a>
              </div>
              <p>special case: assigning an event handler
clobber if we can</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> attrId = node[_attrId];
						<span class="hljs-keyword">if</span> (!attrId) {
							attrId = _ctr++;
							node[_attrId] = attrId;
						}
						<span class="hljs-keyword">if</span> (!_evtHdlrMap[attrId]) {
							_evtHdlrMap[attrId] = {};
						}
						<span class="hljs-keyword">var</span> h = _evtHdlrMap[attrId][propName];
						<span class="hljs-keyword">if</span> (h) {</pre></div></div>
            
        </li>
        
        
        <li id="section-693">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-693">&#182;</a>
              </div>
              <p>h.remove();</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							conn.disconnect(h);
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">try</span> {
								<span class="hljs-keyword">delete</span> node[propName];
							} <span class="hljs-keyword">catch</span> (e) {}
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-694">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-694">&#182;</a>
              </div>
              <p>ensure that event objects are normalized, etc.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (value) {</pre></div></div>
            
        </li>
        
        
        <li id="section-695">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-695">&#182;</a>
              </div>
              <p>_evtHdlrMap[attrId][propName] = on(node, propName, value);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							_evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);
						} <span class="hljs-keyword">else</span> {
							node[propName] = <span class="hljs-literal">null</span>;
						}
						<span class="hljs-keyword">return</span> node; <span class="hljs-comment">// DomNode</span>
					}
					node[propName] = value;
					<span class="hljs-keyword">return</span> node; <span class="hljs-comment">// DomNode</span>
				};
			});
		},
		<span class="hljs-string">'dojo/when'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./Deferred'</span>,
				<span class="hljs-string">'./promise/Promise'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Deferred, Promise)</span> {</span>
<span class="hljs-pi">				'use strict'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-696">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-696">&#182;</a>
              </div>
              <p>module:
    dojo/when</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">when</span><span class="hljs-params">(valueOrPromise, callback, errback, progback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-697">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-697">&#182;</a>
              </div>
              <p>summary:
    Transparently applies callbacks to values and/or promises.
description:
    Accepts promises but also transparently handles non-promises. If no
    callbacks are provided returns a promise, regardless of the initial
    value. Foreign promises are converted.</p>
<pre><code>If callbacks are provided and the initial value is not a promise,
the callback is executed immediately <span class="hljs-keyword">with</span> no error handling. Returns
a promise <span class="hljs-keyword">if</span> the initial value is a promise, or the result of the
callback otherwise.
</code></pre><p>valueOrPromise:
    Either a regular value or an object with a <code>then()</code> method that
    follows the Promises/A specification.
callback: Function?
    Callback to be invoked when the promise is resolved, or a non-promise
    is received.
errback: Function?
    Callback to be invoked when the promise is rejected.
progback: Function?
    Callback to be invoked when the promise emits a progress update.
returns: dojo/promise/Promise
    Promise, or if a callback is provided, the result of the callback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> receivedPromise = valueOrPromise &amp;&amp; <span class="hljs-keyword">typeof</span> valueOrPromise.then === <span class="hljs-string">'function'</span>;
					<span class="hljs-keyword">var</span> nativePromise = receivedPromise &amp;&amp; valueOrPromise <span class="hljs-keyword">instanceof</span> Promise;
					<span class="hljs-keyword">if</span> (!receivedPromise) {
						<span class="hljs-keyword">if</span> (callback) {
							<span class="hljs-keyword">return</span> callback(valueOrPromise);
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Deferred()
								.resolve(valueOrPromise);
						}
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!nativePromise) {
						<span class="hljs-keyword">var</span> deferred = <span class="hljs-keyword">new</span> Deferred(valueOrPromise.cancel);
						valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
						valueOrPromise = deferred.promise;
					}
					<span class="hljs-keyword">if</span> (callback || errback || progback) {
						<span class="hljs-keyword">return</span> valueOrPromise.then(callback, errback, progback);
					}
					<span class="hljs-keyword">return</span> valueOrPromise;
				};
			});
		},
		<span class="hljs-string">'dojo/dom-attr'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'exports'</span>,
				<span class="hljs-string">'./sniff'</span>,
				<span class="hljs-string">'./_base/lang'</span>,
				<span class="hljs-string">'./dom'</span>,
				<span class="hljs-string">'./dom-style'</span>,
				<span class="hljs-string">'./dom-prop'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, has, lang, dom, style, prop)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-698">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-698">&#182;</a>
              </div>
              <p>module:
    dojo/dom-attr
summary:
    This module defines the core dojo DOM attributes API.</p>
<h1 id="todoc-summary-not-showing-up-in-output-see-https-github-com-csnover-js-doc-parse-issues-42">TODOC: summary not showing up in output see <a href="https://github.com/csnover/js-doc-parse/issues/42">https://github.com/csnover/js-doc-parse/issues/42</a></h1>

            </div>
            
        </li>
        
        
        <li id="section-699">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-699">&#182;</a>
              </div>
              <h1 id="element-attribute-functions">Element attribute Functions</h1>

            </div>
            
        </li>
        
        
        <li id="section-700">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-700">&#182;</a>
              </div>
              <p>This module will be obsolete soon. Use dojo/prop instead.
dojo.attr() should conform to <a href="http://www.w3.org/TR/DOM-Level-2-Core/">http://www.w3.org/TR/DOM-Level-2-Core/</a>
attribute-related functions (to be obsolete soon)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> forcePropNames = {
					innerHTML: <span class="hljs-number">1</span>,
					className: <span class="hljs-number">1</span>,
					htmlFor: has(<span class="hljs-string">'ie'</span>),
					value: <span class="hljs-number">1</span>
				}, attrNames = {
						classname: <span class="hljs-string">'class'</span>,
						htmlfor: <span class="hljs-string">'for'</span>,
						tabindex: <span class="hljs-string">'tabIndex'</span>,
						readonly: <span class="hljs-string">'readOnly'</span>
					};

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_hasAttr</span><span class="hljs-params">(node, name)</span> {</span>
					<span class="hljs-keyword">var</span> attr = node.getAttributeNode &amp;&amp; node.getAttributeNode(name);
					<span class="hljs-keyword">return</span> attr &amp;&amp; attr.specified; <span class="hljs-comment">// Boolean</span>
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-701">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-701">&#182;</a>
              </div>
              <p>There is a difference in the presence of certain properties and their default values
between browsers. For example, on IE “disabled” is present on all elements,
but it is value is “false”; “tabIndex” of <div> returns 0 by default on IE, yet other browsers
can return -1.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				exports.has = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasAttr</span><span class="hljs-params">(node, name)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-702">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-702">&#182;</a>
              </div>
              <p>summary:
    Returns true if the requested attribute is specified on the
    given element, and false otherwise.
node: DOMNode|String
    id or reference to the element to check
name: String
    the name of the attribute
returns: Boolean
    true if the requested attribute is specified on the
    given element, and false otherwise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> lc = name.toLowerCase();
					<span class="hljs-keyword">return</span> forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name); <span class="hljs-comment">// Boolean</span>
				};
				exports.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAttr</span><span class="hljs-params">(node, name)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-703">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-703">&#182;</a>
              </div>
              <p>summary:
    Gets an attribute on an HTML element.
description:
    Handles normalized getting of attributes on DOM Nodes.
node: DOMNode|String
    id or reference to the element to get the attribute on
name: String
    the name of the attribute to get.
returns:
    the value of the requested attribute or null if that attribute does not have a specified or
    default value;</p>
<p>example:
|    // get the current value of the “foo” attribute on a node
|    dojo.getAttr(dojo.byId(“nodeId”), “foo”);
|    // or we can just pass the id:
|    dojo.getAttr(“nodeId”, “foo”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> lc = name.toLowerCase(),
						propName = prop.names[lc] || name,
						forceProp = forcePropNames[propName],
						value = node[propName];</pre></div></div>
            
        </li>
        
        
        <li id="section-704">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-704">&#182;</a>
              </div>
              <p>should we access this attribute via a property or via getAttribute()?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (forceProp &amp;&amp; <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'undefined'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-705">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-705">&#182;</a>
              </div>
              <p>node’s property</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> value; <span class="hljs-comment">// Anything</span>
					}
					<span class="hljs-keyword">if</span> (propName !== <span class="hljs-string">'href'</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'boolean'</span> || lang.isFunction(value))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-706">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-706">&#182;</a>
              </div>
              <p>node’s property</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> value; <span class="hljs-comment">// Anything</span>
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-707">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-707">&#182;</a>
              </div>
              <p>node’s attribute
we need _hasAttr() here to guard against IE returning a default value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> attrName = attrNames[lc] || name;
					<span class="hljs-keyword">return</span> _hasAttr(node, attrName) ? node.getAttribute(attrName) : <span class="hljs-literal">null</span>; <span class="hljs-comment">// Anything</span>
				};
				exports.set = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAttr</span><span class="hljs-params">(node, name, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-708">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-708">&#182;</a>
              </div>
              <p>summary:
    Sets an attribute on an HTML element.
description:
    Handles normalized setting of attributes on DOM Nodes.</p>
<pre><code>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the <span class="hljs-keyword">default</span>
behavior will be removed and the <span class="hljs-keyword">new</span> behavior will be added
using `dojo.connect()`, meaning that event handler properties
will be normalized and that some caveats <span class="hljs-keyword">with</span> regards to
non-standard behaviors <span class="hljs-keyword">for</span> onsubmit apply. Namely that you
should cancel form submission using `dojo.stopEvent()` on the
passed event object instead of returning a boolean value from
the handler itself.
</code></pre><p>node: DOMNode|String
    id or reference to the element to set the attribute on
name: String|Object
    the name of the attribute to set, or a hash of key-value pairs to set.
value: String?
    the value to set for the attribute, if the name is a string.
returns:
    the DOM node</p>
<p>example:
|    // use attr() to set the tab index
|    dojo.setAttr(“nodeId”, “tabIndex”, 3);</p>
<p>example:
Set multiple values at once, including event handlers:
|    dojo.setAttr(“formId”, {
|        “foo”: “bar”,
|        “tabIndex”: -1,
|        “method”: “POST”,
|        “onsubmit”: function(e){
|            // stop submitting the form. Note that the IE behavior
|            // of returning true or false will have no effect here
|            // since our handler is connect()ed to the built-in
|            // onsubmit behavior and so we need to use
|            // dojo.stopEvent() to ensure that the submission
|            // doesn’t proceed.
|            dojo.stopEvent(e);
|
|            // submit the form with Ajax
|            dojo.xhrPost({ form: “formId” });
|        }
|    });</p>
<p>example:
Style is s special case: Only set with an object hash of styles
|    dojo.setAttr(“someNode”,{
|        id:”bar”,
|        style:{
|            width:”200px”, height:”100px”, color:”#000”
|        }
|    });</p>
<p>example:
Again, only set style as an object hash of styles:
|    var obj = { color:”#fff”, backgroundColor:”#000” };
|    dojo.setAttr(“someNode”, “style”, obj);
|
|    // though shorter to use <code>dojo.style()</code> in this case:
|    dojo.setStyle(“someNode”, obj);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-709">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-709">&#182;</a>
              </div>
              <p>inline’d type check
the object form of setter: the 2nd argument is a dictionary</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">in</span> name) {
							exports.set(node, x, name[x]);
						}
						<span class="hljs-keyword">return</span> node; <span class="hljs-comment">// DomNode</span>
					}
					<span class="hljs-keyword">var</span> lc = name.toLowerCase(),
						propName = prop.names[lc] || name,
						forceProp = forcePropNames[propName];
					<span class="hljs-keyword">if</span> (propName === <span class="hljs-string">'style'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-710">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-710">&#182;</a>
              </div>
              <p>inline’d type check
special case: setting a style</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						style.set(node, value);
						<span class="hljs-keyword">return</span> node; <span class="hljs-comment">// DomNode</span>
					}
					<span class="hljs-keyword">if</span> (forceProp || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'boolean'</span> || lang.isFunction(value)) {
						<span class="hljs-keyword">return</span> prop.set(node, name, value);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-711">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-711">&#182;</a>
              </div>
              <p>node’s attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node.setAttribute(attrNames[lc] || name, value);
					<span class="hljs-keyword">return</span> node; <span class="hljs-comment">// DomNode</span>
				};
				exports.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeAttr</span><span class="hljs-params">(node, name)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-712">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-712">&#182;</a>
              </div>
              <p>summary:
    Removes an attribute from an HTML element.
node: DOMNode|String
    id or reference to the element to remove the attribute from
name: String
    the name of the attribute to remove</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					dom.byId(node)
						.removeAttribute(attrNames[name.toLowerCase()] || name);
				};
				exports.getNodeProp = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNodeProp</span><span class="hljs-params">(node, name)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-713">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-713">&#182;</a>
              </div>
              <p>summary:
    Returns an effective value of a property or an attribute.
node: DOMNode|String
    id or reference to the element to remove the attribute from
name: String
    the name of the attribute
returns:
    the value of the attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">var</span> lc = name.toLowerCase(),
						propName = prop.names[lc] || name;
					<span class="hljs-keyword">if</span> (propName <span class="hljs-keyword">in</span> node &amp;&amp; propName !== <span class="hljs-string">'href'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-714">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-714">&#182;</a>
              </div>
              <p>node’s property</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> node[propName]; <span class="hljs-comment">// Anything</span>
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-715">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-715">&#182;</a>
              </div>
              <p>node’s attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> attrName = attrNames[lc] || name;
					<span class="hljs-keyword">return</span> _hasAttr(node, attrName) ? node.getAttribute(attrName) : <span class="hljs-literal">null</span>; <span class="hljs-comment">// Anything</span>
				};
			});
		},
		<span class="hljs-string">'dojo/dom-construct'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'exports'</span>,
				<span class="hljs-string">'./_base/kernel'</span>,
				<span class="hljs-string">'./sniff'</span>,
				<span class="hljs-string">'./_base/window'</span>,
				<span class="hljs-string">'./dom'</span>,
				<span class="hljs-string">'./dom-attr'</span>,
				<span class="hljs-string">'./on'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, dojo, has, win, dom, attr, on)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-716">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-716">&#182;</a>
              </div>
              <p>module:
    dojo/dom-construct
summary:
    This module defines the core dojo DOM construction API.
TODOC: summary not showing up in output, see <a href="https://github.com/csnover/js-doc-parse/issues/42">https://github.com/csnover/js-doc-parse/issues/42</a>
support stuff for toDom()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> tagWrap = {
					option: [<span class="hljs-string">'select'</span>],
					tbody: [<span class="hljs-string">'table'</span>],
					thead: [<span class="hljs-string">'table'</span>],
					tfoot: [<span class="hljs-string">'table'</span>],
					tr: [
						<span class="hljs-string">'table'</span>,
						<span class="hljs-string">'tbody'</span>
					],
					td: [
						<span class="hljs-string">'table'</span>,
						<span class="hljs-string">'tbody'</span>,
						<span class="hljs-string">'tr'</span>
					],
					th: [
						<span class="hljs-string">'table'</span>,
						<span class="hljs-string">'thead'</span>,
						<span class="hljs-string">'tr'</span>
					],
					legend: [<span class="hljs-string">'fieldset'</span>],
					caption: [<span class="hljs-string">'table'</span>],
					colgroup: [<span class="hljs-string">'table'</span>],
					col: [
						<span class="hljs-string">'table'</span>,
						<span class="hljs-string">'colgroup'</span>
					],
					li: [<span class="hljs-string">'ul'</span>]
				}, reTag = <span class="hljs-regexp">/&lt;\s*([\w\:]+)/</span>,
					masterNode = {}, masterNum = <span class="hljs-number">0</span>,
					masterName = <span class="hljs-string">'__'</span> + dojo._scopeName + <span class="hljs-string">'ToDomId'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-717">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-717">&#182;</a>
              </div>
              <p>generate start/end tag strings to use
for the injection for each special tag wrap case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> param <span class="hljs-keyword">in</span> tagWrap) {
					<span class="hljs-keyword">if</span> (tagWrap.hasOwnProperty(param)) {
						<span class="hljs-keyword">var</span> tw = tagWrap[param];
						tw.pre = param === <span class="hljs-string">'option'</span> ? <span class="hljs-string">'&lt;select multiple="multiple"&gt;'</span> : <span class="hljs-string">'&lt;'</span> + tw.join(<span class="hljs-string">'&gt;&lt;'</span>) + <span class="hljs-string">'&gt;'</span>;
						tw.post = <span class="hljs-string">'&lt;/'</span> + tw.reverse()
							.join(<span class="hljs-string">'&gt;&lt;/'</span>) + <span class="hljs-string">'&gt;'</span>; <span class="hljs-comment">// the last line is destructive: it reverses the array,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-718">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-718">&#182;</a>
              </div>
              <p>but we don’t care at this point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					}
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_insertBefore</span><span class="hljs-params">(node, ref)</span> {</span>
					<span class="hljs-keyword">var</span> parent = ref.parentNode;
					<span class="hljs-keyword">if</span> (parent) {
						parent.insertBefore(node, ref);
					}
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_insertAfter</span><span class="hljs-params">(node, ref)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-719">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-719">&#182;</a>
              </div>
              <p>summary:
    Try to insert node after ref</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> parent = ref.parentNode;
					<span class="hljs-keyword">if</span> (parent) {
						<span class="hljs-keyword">if</span> (parent.lastChild === ref) {
							parent.appendChild(node);
						} <span class="hljs-keyword">else</span> {
							parent.insertBefore(node, ref.nextSibling);
						}
					}
				}
				<span class="hljs-keyword">var</span> _destroyContainer = <span class="hljs-literal">null</span>,
					_destroyDoc;
				on(window, <span class="hljs-string">'unload'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					_destroyContainer = <span class="hljs-literal">null</span>; <span class="hljs-comment">//prevent IE leak</span>
				});
				exports.toDom = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toDom</span><span class="hljs-params">(frag, doc)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-720">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-720">&#182;</a>
              </div>
              <p>summary:
    instantiates an HTML fragment returning the corresponding DOM.
frag: String
    the HTML fragment
doc: DocumentNode?
    optional document to use when creating DOM nodes, defaults to
    dojo.doc if not specified.
returns:
    Document fragment, unless it’s a single node in which case it returns the node itself
example:
    Create a table row:
|    var tr = dojo.toDom(“<tr><td>First!</td></tr>“);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					doc = doc || win.doc;
					<span class="hljs-keyword">var</span> masterId = doc[masterName];
					<span class="hljs-keyword">if</span> (!masterId) {
						doc[masterName] = masterId = ++masterNum + <span class="hljs-string">''</span>;
						masterNode[masterId] = doc.createElement(<span class="hljs-string">'div'</span>);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-721">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-721">&#182;</a>
              </div>
              <p>make sure the frag is a string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					frag += <span class="hljs-string">''</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-722">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-722">&#182;</a>
              </div>
              <p>find the starting tag, and get node wrapper</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> match = frag.match(reTag),
						tag = match ? match[<span class="hljs-number">1</span>].toLowerCase() : <span class="hljs-string">''</span>,
						master = masterNode[masterId],
						wrap, i, fc, df;
					<span class="hljs-keyword">if</span> (match &amp;&amp; tagWrap[tag]) {
						wrap = tagWrap[tag];
						master.innerHTML = wrap.pre + frag + wrap.post;
						<span class="hljs-keyword">for</span> (i = wrap.length; i; --i) {
							master = master.firstChild;
						}
					} <span class="hljs-keyword">else</span> {
						master.innerHTML = frag;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-723">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-723">&#182;</a>
              </div>
              <p>one node shortcut =&gt; return the node itself</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (master.childNodes.length === <span class="hljs-number">1</span>) {
						<span class="hljs-keyword">return</span> master.removeChild(master.firstChild); <span class="hljs-comment">// DOMNode</span>
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-724">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-724">&#182;</a>
              </div>
              <p>return multiple nodes as a document fragment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					df = doc.createDocumentFragment();
					<span class="hljs-keyword">while</span> (fc = master.firstChild) {</pre></div></div>
            
        </li>
        
        
        <li id="section-725">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-725">&#182;</a>
              </div>
              <p>intentional assignment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						df.appendChild(fc);
					}
					<span class="hljs-keyword">return</span> df; <span class="hljs-comment">// DocumentFragment</span>
				};
				exports.place = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">place</span><span class="hljs-params">(node, refNode, position)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-726">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-726">&#182;</a>
              </div>
              <p>summary:
    Attempt to insert node into the DOM, choosing from various positioning options.
    Returns the first argument resolved to a DOM node.
node: DOMNode|String
    id or node reference, or HTML fragment starting with “&lt;” to place relative to refNode
refNode: DOMNode|String
    id or node reference to use as basis for placement
position: String|Number?
    string noting the position of node relative to refNode or a
    number indicating the location in the childNodes collection of refNode.
    Accepted string values are:</p>
<pre><code>- before
- after
- replace
- only
- first
- last

<span class="hljs-string">"first"</span> and <span class="hljs-string">"last"</span> indicate positions as children of refNode, <span class="hljs-string">"replace"</span> replaces refNode,
<span class="hljs-string">"only"</span> replaces all children.  position defaults to <span class="hljs-string">"last"</span> <span class="hljs-keyword">if</span> not specified
</code></pre><p>returns: DOMNode
    Returned values is the first argument resolved to a DOM node.</p>
<pre><code>.place() is also a method of `dojo/NodeList`, allowing `dojo.query` node lookups.
</code></pre><p>example:
    Place a node by string id as the last child of another node by string id:
|    dojo.place(“someNode”, “anotherNode”);
example:
    Place a node by string id before another node by string id
|    dojo.place(“someNode”, “anotherNode”, “before”);
example:
    Create a Node, and place it in the body element (last child):
|    dojo.place(“<div></div>“, dojo.body());
example:
    Put a new LI as the first child of a list by id:
|    dojo.place(“<li></li>“, “someUl”, “first”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					refNode = dom.byId(refNode);
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node === <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-727">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-727">&#182;</a>
              </div>
              <p>inline’d type check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						node = <span class="hljs-regexp">/^\s*&lt;/</span>.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> position === <span class="hljs-string">'number'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-728">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-728">&#182;</a>
              </div>
              <p>inline’d type check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> cn = refNode.childNodes;
						<span class="hljs-keyword">if</span> (!cn.length || cn.length &lt;= position) {
							refNode.appendChild(node);
						} <span class="hljs-keyword">else</span> {
							_insertBefore(node, cn[position &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : position]);
						}
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">switch</span> (position) {
						<span class="hljs-keyword">case</span> <span class="hljs-string">'before'</span>:
							_insertBefore(node, refNode);
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'after'</span>:
							_insertAfter(node, refNode);
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'replace'</span>:
							refNode.parentNode.replaceChild(node, refNode);
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'only'</span>:
							exports.empty(refNode);
							refNode.appendChild(node);
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'first'</span>:
							<span class="hljs-keyword">if</span> (refNode.firstChild) {
								_insertBefore(node, refNode.firstChild);
								<span class="hljs-keyword">break</span>;
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-729">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-729">&#182;</a>
              </div>
              <p>else fallthrough…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">default</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-730">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-730">&#182;</a>
              </div>
              <p>aka: last</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							refNode.appendChild(node);
						}
					}
					<span class="hljs-keyword">return</span> node; <span class="hljs-comment">// DomNode</span>
				};
				exports.create = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span><span class="hljs-params">(tag, attrs, refNode, pos)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-731">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-731">&#182;</a>
              </div>
              <p>summary:
    Create an element, allowing for optional attribute decoration
    and placement.
description:
    A DOM Element creation function. A shorthand method for creating a node or
    a fragment, and allowing for a convenient optional attribute setting step,
    as well as an optional DOM placement reference.</p>
<pre><code>Attributes are set by passing the optional object through `dojo.setAttr`.
See `dojo.setAttr` <span class="hljs-keyword">for</span> noted caveats and nuances, and API <span class="hljs-keyword">if</span> applicable.

Placement is done via `dojo.place`, assuming the <span class="hljs-keyword">new</span> node to be the action
node, passing along the optional reference node and position.
</code></pre><p>tag: DOMNode|String
    A string of the element to create (eg: “div”, “a”, “p”, “li”, “script”, “br”),
    or an existing DOM node to process.
attrs: Object
    An object-hash of attributes to set on the newly created node.
    Can be null, if you don’t want to set any attributes/styles.
    See: <code>dojo.setAttr</code> for a description of available attributes.
refNode: DOMNode|String?
    Optional reference node. Used by <code>dojo.place</code> to place the newly created
    node somewhere in the dom relative to refNode. Can be a DomNode reference
    or String ID of a node.
pos: String?
    Optional positional reference. Defaults to “last” by way of <code>dojo.place</code>,
    though can be set to “first”,”after”,”before”,”last”, “replace” or “only”
    to further control the placement of the new node relative to the refNode.
    ‘refNode’ is required if a ‘pos’ is specified.
example:
    Create a DIV:
|    var n = dojo.create(“div”);</p>
<p>example:
    Create a DIV with content:
|    var n = dojo.create(“div”, { innerHTML:”<p>hi</p>“ });</p>
<p>example:
    Place a new DIV in the BODY, with no attributes set
|    var n = dojo.create(“div”, null, dojo.body());</p>
<p>example:
    Create an UL, and populate it with LI’s. Place the list as the first-child of a
    node with id=”someId”:
|    var ul = dojo.create(“ul”, null, “someId”, “first”);
|    var items = [“one”, “two”, “three”, “four”];
|    dojo.forEach(items, function(data){
|        dojo.create(“li”, { innerHTML: data }, ul);
|    });</p>
<p>example:
    Create an anchor, with an href. Place in BODY:
|    dojo.create(“a”, { href:”foo.html”, title:”Goto FOO!” }, dojo.body());</p>
<p>example:
    Create a <code>dojo/NodeList()</code> from a new element (for syntactic sugar):
|    dojo.query(dojo.create(‘div’))
|        .addClass(“newDiv”)
|        .onclick(function(e){ console.log(‘clicked’, e.target) })
|        .place(“#someNode”); // redundant, but cleaner.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> doc = win.doc;
					<span class="hljs-keyword">if</span> (refNode) {
						refNode = dom.byId(refNode);
						doc = refNode.ownerDocument;
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tag === <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-732">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-732">&#182;</a>
              </div>
              <p>inline’d type check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						tag = doc.createElement(tag);
					}
					<span class="hljs-keyword">if</span> (attrs) {
						attr.set(tag, attrs);
					}
					<span class="hljs-keyword">if</span> (refNode) {
						exports.place(tag, refNode, pos);
					}
					<span class="hljs-keyword">return</span> tag; <span class="hljs-comment">// DomNode</span>
				};
				exports.empty = has(<span class="hljs-string">'ie'</span>) ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
					node = dom.byId(node);
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> c; c = node.lastChild;) {</pre></div></div>
            
        </li>
        
        
        <li id="section-733">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-733">&#182;</a>
              </div>
              <p>intentional assignment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						exports.destroy(c);
					}
				} : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> {</span>
					dom.byId(node)
						.innerHTML = <span class="hljs-string">''</span>;
				};
				<span class="hljs-comment">/*=====
                 exports.empty = function(node){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-734">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-734">&#182;</a>
              </div>
              <p>summary:
    safely removes all children of the node.
node: DOMNode|String
    a reference to a DOM node or an id.
example:
    Destroy node’s children byId:
|    dojo.empty(“someId”);</p>
<p>example:
    Destroy all nodes’ children in a list by reference:
|    dojo.query(“.someNode”).forEach(dojo.empty);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                 };
                 =====*/
				exports.destroy = function destroy(node) {</pre></div></div>
            
        </li>
        
        
        <li id="section-735">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-735">&#182;</a>
              </div>
              <p>summary:
    Removes a node from its parent, clobbering it and all of its
    children.</p>
<p>description:
    Removes a node from its parent, clobbering it and all of its
    children. Function only works with DomNodes, and returns nothing.</p>
<p>node: DOMNode|String
    A String ID or DomNode reference of the element to be destroyed</p>
<p>example:
    Destroy a node byId:
|    dojo.destroy(“someId”);</p>
<p>example:
    Destroy all nodes in a list by reference:
|    dojo.query(“.someNode”).forEach(dojo.destroy);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node = dom.byId(node);
					<span class="hljs-keyword">try</span> {
						<span class="hljs-keyword">var</span> doc = node.ownerDocument;</pre></div></div>
            
        </li>
        
        
        <li id="section-736">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-736">&#182;</a>
              </div>
              <p>cannot use _destroyContainer.ownerDocument since this can throw an exception on IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!_destroyContainer || _destroyDoc !== doc) {
							_destroyContainer = doc.createElement(<span class="hljs-string">'div'</span>);
							_destroyDoc = doc;
						}
						_destroyContainer.appendChild(node.parentNode ? node.parentNode.removeChild(node) : node);</pre></div></div>
            
        </li>
        
        
        <li id="section-737">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-737">&#182;</a>
              </div>
              <p>NOTE: see <a href="http://trac.dojotoolkit.org/ticket/2931">http://trac.dojotoolkit.org/ticket/2931</a>. This may be a bug and not a feature</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						_destroyContainer.innerHTML = <span class="hljs-string">''</span>;
					} <span class="hljs-keyword">catch</span> (e) {}
				};
			});
		},
		<span class="hljs-string">'dojo/request/xhr'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/request/xhr'</span>, [
				<span class="hljs-string">'../errors/RequestError'</span>,
				<span class="hljs-string">'./watch'</span>,
				<span class="hljs-string">'./handlers'</span>,
				<span class="hljs-string">'./util'</span>,
				<span class="hljs-string">'../has'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(RequestError, watch, handlers, util, has)</span> {</span>
				has.add(<span class="hljs-string">'native-xhr'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-738">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-738">&#182;</a>
              </div>
              <p>if true, the environment has a native XHR implementation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> XMLHttpRequest !== <span class="hljs-string">'undefined'</span>;
				});
				has.add(<span class="hljs-string">'dojo-force-activex-xhr'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">return</span> has(<span class="hljs-string">'activex'</span>) &amp;&amp; !document.addEventListener &amp;&amp; window.location.protocol === <span class="hljs-string">'file:'</span>;
				});
				has.add(<span class="hljs-string">'native-xhr2'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">if</span> (!has(<span class="hljs-string">'native-xhr'</span>)) {
						<span class="hljs-keyword">return</span>;
					}
					<span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> XMLHttpRequest();
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x.addEventListener !== <span class="hljs-string">'undefined'</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> opera === <span class="hljs-string">'undefined'</span> || <span class="hljs-keyword">typeof</span> x.upload !== <span class="hljs-string">'undefined'</span>);
				});
				has.add(<span class="hljs-string">'native-formdata'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-739">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-739">&#182;</a>
              </div>
              <p>if true, the environment has a native FormData implementation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> FormData === <span class="hljs-string">'function'</span>;
				});

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleResponse</span><span class="hljs-params">(response, error)</span> {</span>
					<span class="hljs-keyword">var</span> _xhr = response.xhr;
					response.status = response.xhr.status;
					response.text = _xhr.responseText;
					<span class="hljs-keyword">if</span> (response.options.handleAs === <span class="hljs-string">'xml'</span>) {
						response.data = _xhr.responseXML;
					}
					<span class="hljs-keyword">if</span> (!error) {
						<span class="hljs-keyword">try</span> {
							handlers(response);
						} <span class="hljs-keyword">catch</span> (e) {
							error = e;
						}
					}
					<span class="hljs-keyword">if</span> (error) {
						<span class="hljs-keyword">this</span>.reject(error);
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (util.checkStatus(_xhr.status)) {
						<span class="hljs-keyword">this</span>.resolve(response);
					} <span class="hljs-keyword">else</span> {
						error = <span class="hljs-keyword">new</span> RequestError(<span class="hljs-string">'Unable to load '</span> + response.url + <span class="hljs-string">' status: '</span> + _xhr.status, response);
						<span class="hljs-keyword">this</span>.reject(error);
					}
				}
				<span class="hljs-keyword">var</span> isValid, isReady, addListeners, cancel;
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'native-xhr2'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-740">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-740">&#182;</a>
              </div>
              <p>Any platform with XHR2 will only use the watch mechanism for timeout.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					isValid = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-741">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-741">&#182;</a>
              </div>
              <p>summary:
    Check to see if the request should be taken out of the watch queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.isFulfilled();
					};
					cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dfd, response)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-742">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-742">&#182;</a>
              </div>
              <p>summary:
    Canceler for deferred</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						response.xhr.abort();
					};
					addListeners = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(_xhr, dfd, response)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-743">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-743">&#182;</a>
              </div>
              <p>summary:
    Adds event listeners to the XMLHttpRequest object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onLoad</span><span class="hljs-params">(evt)</span> {</span>
							dfd.handleResponse(response);
						}

						<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onError</span><span class="hljs-params">(evt)</span> {</span>
							<span class="hljs-keyword">var</span> _xhr = evt.target;
							<span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> RequestError(<span class="hljs-string">'Unable to load '</span> + response.url + <span class="hljs-string">' status: '</span> + _xhr.status, response);
							dfd.handleResponse(response, error);
						}

						<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(evt)</span> {</span>
							<span class="hljs-keyword">if</span> (evt.lengthComputable) {
								response.loaded = evt.loaded;
								response.total = evt.total;
								dfd.progress(response);
							}
						}
						_xhr.addEventListener(<span class="hljs-string">'load'</span>, onLoad, <span class="hljs-literal">false</span>);
						_xhr.addEventListener(<span class="hljs-string">'error'</span>, onError, <span class="hljs-literal">false</span>);
						_xhr.addEventListener(<span class="hljs-string">'progress'</span>, onProgress, <span class="hljs-literal">false</span>);
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							_xhr.removeEventListener(<span class="hljs-string">'load'</span>, onLoad, <span class="hljs-literal">false</span>);
							_xhr.removeEventListener(<span class="hljs-string">'error'</span>, onError, <span class="hljs-literal">false</span>);
							_xhr.removeEventListener(<span class="hljs-string">'progress'</span>, onProgress, <span class="hljs-literal">false</span>);
						};
					};
				} <span class="hljs-keyword">else</span> {
					isValid = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span>
						<span class="hljs-keyword">return</span> response.xhr.readyState; <span class="hljs-comment">//boolean</span>
					};
					isReady = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-number">4</span> === response.xhr.readyState; <span class="hljs-comment">//boolean</span>
					};
					cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dfd, response)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-744">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-744">&#182;</a>
              </div>
              <p>summary:
    canceller function for util.deferred call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> xhr = response.xhr;
						<span class="hljs-keyword">var</span> _at = <span class="hljs-keyword">typeof</span> xhr.abort;
						<span class="hljs-keyword">if</span> (_at === <span class="hljs-string">'function'</span> || _at === <span class="hljs-string">'object'</span> || _at === <span class="hljs-string">'unknown'</span>) {
							xhr.abort();
						}
					};
				}
				<span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span>, defaultOptions = {
						data: <span class="hljs-literal">null</span>,
						query: <span class="hljs-literal">null</span>,
						sync: <span class="hljs-literal">false</span>,
						method: <span class="hljs-string">'GET'</span>,
						headers: {
							<span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded'</span>
						}
					};

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xhr</span><span class="hljs-params">(url, options, returnDeferred)</span> {</span>
					<span class="hljs-keyword">var</span> response = util.parseArgs(url, util.deepCreate(defaultOptions, options), has(<span class="hljs-string">'native-formdata'</span>) &amp;&amp; options &amp;&amp; options.data &amp;&amp; options.data <span class="hljs-keyword">instanceof</span> FormData);
					url = response.url;
					options = response.options;
					<span class="hljs-keyword">var</span> remover, last = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							remover &amp;&amp; remover();
						};</pre></div></div>
            
        </li>
        
        
        <li id="section-745">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-745">&#182;</a>
              </div>
              <p>Make the Deferred object for this xhr request.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> dfd = util.deferred(response, cancel, isValid, isReady, handleResponse, last);
					<span class="hljs-keyword">var</span> _xhr = response.xhr = xhr._create();
					<span class="hljs-keyword">if</span> (!_xhr) {</pre></div></div>
            
        </li>
        
        
        <li id="section-746">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-746">&#182;</a>
              </div>
              <p>If XHR factory somehow returns nothings,
cancel the deferred.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						dfd.cancel(<span class="hljs-keyword">new</span> RequestError(<span class="hljs-string">'XHR was not created'</span>));
						<span class="hljs-keyword">return</span> returnDeferred ? dfd : dfd.promise;
					}
					response.getHeader = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(headerName)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.xhr.getResponseHeader(headerName);
					};
					<span class="hljs-keyword">if</span> (addListeners) {
						remover = addListeners(_xhr, dfd, response);
					}
					<span class="hljs-keyword">var</span> data = options.data,
						async = !options.sync,
						method = options.method;
					<span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-747">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-747">&#182;</a>
              </div>
              <p>IE6 won’t let you call apply() on the native function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						_xhr.open(method, url, async, options.user || <span class="hljs-literal">undefined</span>, options.password || <span class="hljs-literal">undefined</span>);
						<span class="hljs-keyword">if</span> (options.withCredentials) {
							_xhr.withCredentials = options.withCredentials;
						}
						<span class="hljs-keyword">var</span> headers = options.headers,
							contentType;
						<span class="hljs-keyword">if</span> (headers) {
							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> hdr <span class="hljs-keyword">in</span> headers) {
								<span class="hljs-keyword">if</span> (hdr.toLowerCase() === <span class="hljs-string">'content-type'</span>) {
									contentType = headers[hdr];
								} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (headers[hdr]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-748">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-748">&#182;</a>
              </div>
              <p>Only add header if it has a value. This allows for instance, skipping
insertion of X-Requested-With by specifying empty value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									_xhr.setRequestHeader(hdr, headers[hdr]);
								}
							}
						}
						<span class="hljs-keyword">if</span> (contentType &amp;&amp; contentType !== <span class="hljs-literal">false</span>) {
							_xhr.setRequestHeader(<span class="hljs-string">'Content-Type'</span>, contentType);
						}
						<span class="hljs-keyword">if</span> (!headers || !(<span class="hljs-string">'X-Requested-With'</span> <span class="hljs-keyword">in</span> headers)) {
							_xhr.setRequestHeader(<span class="hljs-string">'X-Requested-With'</span>, <span class="hljs-string">'XMLHttpRequest'</span>);
						}
						<span class="hljs-keyword">if</span> (util.notify) {
							util.notify.emit(<span class="hljs-string">'send'</span>, response, dfd.promise.cancel);
						}
						_xhr.send(data);
					} <span class="hljs-keyword">catch</span> (e) {
						dfd.reject(e);
					}
					watch(dfd);
					_xhr = <span class="hljs-literal">null</span>;
					<span class="hljs-keyword">return</span> returnDeferred ? dfd : dfd.promise;
				}
				<span class="hljs-comment">/*=====
             xhr = function(url, options){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-749">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-749">&#182;</a>
              </div>
              <p>summary:
    Sends a request using XMLHttpRequest with the given URL and options.
url: String
    URL to request
options: dojo/request/xhr.<strong>Options?
    Options for the request.
returns: dojo/request.</strong>Promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             xhr.__BaseOptions = declare(request.__BaseOptions, {</pre></div></div>
            
        </li>
        
        
        <li id="section-750">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-750">&#182;</a>
              </div>
              <p>sync: Boolean?
    Whether to make a synchronous request or not. Default
    is <code>false</code> (asynchronous).
data: String|Object|FormData?
    Data to transfer. This is ignored for GET and DELETE
    requests.
headers: Object?
    Headers to use for the request.
user: String?
    Username to use during the request.
password: String?
    Password to use during the request.
withCredentials: Boolean?
    For cross-site requests, whether to send credentials
    or not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             });
             xhr.__MethodOptions = declare(<span class="hljs-literal">null</span>, {</pre></div></div>
            
        </li>
        
        
        <li id="section-751">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-751">&#182;</a>
              </div>
              <p>method: String?
    The HTTP method to use to make the request. Must be
    uppercase. Default is <code>&quot;GET&quot;</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             });
             xhr.__Options = declare([xhr.__BaseOptions, xhr.__MethodOptions]);

             xhr.get = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(url, options)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-752">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-752">&#182;</a>
              </div>
              <p>summary:
    Send an HTTP GET request using XMLHttpRequest with the given URL and options.
url: String
    URL to request
options: dojo/request/xhr.<strong>BaseOptions?
    Options for the request.
returns: dojo/request.</strong>Promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             xhr.post = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(url, options)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-753">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-753">&#182;</a>
              </div>
              <p>summary:
    Send an HTTP POST request using XMLHttpRequest with the given URL and options.
url: String
    URL to request
options: dojo/request/xhr.<strong>BaseOptions?
    Options for the request.
returns: dojo/request.</strong>Promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             xhr.put = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(url, options)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-754">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-754">&#182;</a>
              </div>
              <p>summary:
    Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
url: String
    URL to request
options: dojo/request/xhr.<strong>BaseOptions?
    Options for the request.
returns: dojo/request.</strong>Promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             xhr.del = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(url, options)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-755">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-755">&#182;</a>
              </div>
              <p>summary:
    Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
url: String
    URL to request
options: dojo/request/xhr.<strong>BaseOptions?
    Options for the request.
returns: dojo/request.</strong>Promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				xhr._create = function () {</pre></div></div>
            
        </li>
        
        
        <li id="section-756">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-756">&#182;</a>
              </div>
              <p>summary:
    does the work of portably generating a new XMLHTTPRequest object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'XMLHTTP not available'</span>);
				};
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'native-xhr'</span>) &amp;&amp; !has(<span class="hljs-string">'dojo-force-activex-xhr'</span>)) {
					xhr._create = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> XMLHttpRequest();
					};
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (has(<span class="hljs-string">'activex'</span>)) {
					<span class="hljs-keyword">try</span> {
						<span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">'Msxml2.XMLHTTP'</span>);
						xhr._create = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">'Msxml2.XMLHTTP'</span>);
						};
					} <span class="hljs-keyword">catch</span> (e) {
						<span class="hljs-keyword">try</span> {
							<span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">'Microsoft.XMLHTTP'</span>);
							xhr._create = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">'Microsoft.XMLHTTP'</span>);
							};
						} <span class="hljs-keyword">catch</span> (e) {}
					}
				}
				util.addCommonMethods(xhr);
				<span class="hljs-keyword">return</span> xhr;
			});
		},
		<span class="hljs-string">'dojo/text'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./_base/kernel'</span>,
				<span class="hljs-string">'require'</span>,
				<span class="hljs-string">'./has'</span>,
				<span class="hljs-string">'./_base/xhr'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, require, has, xhr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-757">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-757">&#182;</a>
              </div>
              <p>module:
    dojo/text</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> getText;
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
					getText = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(url, sync, load)</span> {</span>
						xhr(<span class="hljs-string">'GET'</span>, {
							url: url,
							sync: !! sync,
							load: load,
							headers: dojo.config.textPluginHeaders || {}
						});
					};
				} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-758">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-758">&#182;</a>
              </div>
              <p>TODOC: only works for dojo AMD loader</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (<span class="hljs-built_in">require</span>.getText) {
						getText = <span class="hljs-built_in">require</span>.getText;
					} <span class="hljs-keyword">else</span> {
						console.error(<span class="hljs-string">'dojo/text plugin failed to load because loader does not support getText'</span>);
					}
				}
				<span class="hljs-keyword">var</span> theCache = {}, strip = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-759">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-759">&#182;</a>
              </div>
              <p>Strips &lt;?xml …?&gt; declarations so that external SVG and XML
documents can be added to a document without worry. Also, if the string
is an HTML document, only the part inside the body tag is returned.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (text) {
							text = text.replace(<span class="hljs-regexp">/^\s*&lt;\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?&gt;/im</span>, <span class="hljs-string">''</span>);
							<span class="hljs-keyword">var</span> matches = text.match(<span class="hljs-regexp">/&lt;body[^&gt;]*&gt;\s*([\s\S]+)\s*&lt;\/body&gt;/im</span>);
							<span class="hljs-keyword">if</span> (matches) {
								text = matches[<span class="hljs-number">1</span>];
							}
						} <span class="hljs-keyword">else</span> {
							text = <span class="hljs-string">''</span>;
						}
						<span class="hljs-keyword">return</span> text;
					}, notFound = {}, pending = {};
				dojo.cache = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module, url, value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-760">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-760">&#182;</a>
              </div>
              <p>summary:
    A getter and setter for storing the string content associated with the
    module and url arguments.
description:
    If module is a string that contains slashes, then it is interpretted as a fully
    resolved path (typically a result returned by require.toUrl), and url should not be
    provided. This is the preferred signature. If module is a string that does not
    contain slashes, then url must also be provided and module and url are used to
    call <code>dojo.moduleUrl()</code> to generate a module URL. This signature is deprecated.
    If value is specified, the cache value for the moduleUrl will be set to
    that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
    in its internal cache and return that cached value for the URL. To clear
    a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
    the URL contents, only modules on the same domain of the page can use this capability.
    The build system can inline the cache values though, to allow for xdomain hosting.
module: String||Object
    If a String with slashes, a fully resolved path; if a String without slashes, the
    module name to use for the base part of the URL, similar to module argument
    to <code>dojo.moduleUrl</code>. If an Object, something that has a .toString() method that
    generates a valid path for the cache item. For example, a dojo._Url object.
url: String
    The rest of the path to append to the path derived from the module argument. If
    module is an object, then this second argument should be the “value” argument instead.
value: String||Object?
    If a String, the value to use in the cache for the module/url combination.
    If an Object, it can have two properties: value and sanitize. The value property
    should be the value to use in the cache, and sanitize can be set to true or false,
    to indicate if XML declarations should be removed from the value and if the HTML
    inside a body tag in the value should be extracted as the real value. The value argument
    or the value property on the value argument are usually only used by the build system
    as it inlines cache content.
example:
    To ask dojo.cache to fetch content and store it in the cache (the dojo[“cache”] style
    of call is used to avoid an issue with the build system erroneously trying to intern
    this example. To get the build system to intern your dojo.cache calls, use the
    “dojo.cache” style of call):
    | //If template.html contains “<h1>Hello</h1>“ that will be
    | //the value for the text variable.
    | var text = dojo<a href="&quot;my.module&quot;," title="template.html">“cache”</a>;
example:
    To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
     (the dojo[“cache”] style of call is used to avoid an issue with the build system
    erroneously trying to intern this example. To get the build system to intern your
    dojo.cache calls, use the “dojo.cache” style of call):
    | //If template.html contains “<html><body><h1>Hello</h1></body></html>“, the
    | //text variable will contain just “<h1>Hello</h1>“.
    | var text = dojo<a href="&quot;my.module&quot;," title="template.html&quot;, {sanitize: true});
example:
    Same example as previous, but demonstrates how an object can be passed in as
    the first argument, then the value argument can then be the second argument.
    | //If template.html contains &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;, the
    | //text variable will contain just &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;.
    | var text = dojo[&quot;cache&quot;](new dojo._Url(&quot;my/module/template.html">“cache”</a>, {sanitize: true});</p>
<ul>
<li>(string string [value]) =&gt; (module, url, value)</li>
<li><p>(object [value])        =&gt; (module, value), url defaults to “”</p>
</li>
<li><p>if module is an object, then it must be convertable to a string</p>
</li>
<li>(module, url) module + (url ? (“/“ + url) : “”) must be a legal argument to require.toUrl</li>
<li>value may be a string or an object; if an object then may have the properties “value” and/or “sanitize”</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> key;
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> module === <span class="hljs-string">'string'</span>) {
						<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\//</span>.test(module)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-761">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-761">&#182;</a>
              </div>
              <p>module is a version 1.7+ resolved path</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							key = module;
							value = url;
						} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-762">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-762">&#182;</a>
              </div>
              <p>module is a version 1.6- argument to dojo.moduleUrl</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							key = <span class="hljs-built_in">require</span>.toUrl(module.replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">'/'</span>) + (url ? <span class="hljs-string">'/'</span> + url : <span class="hljs-string">''</span>));
						}
					} <span class="hljs-keyword">else</span> {
						key = module + <span class="hljs-string">''</span>;
						value = url;
					}
					<span class="hljs-keyword">var</span> val = value !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'string'</span> ? value.value : value,
						sanitize = value &amp;&amp; value.sanitize;
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-763">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-763">&#182;</a>
              </div>
              <p>We have a string, set cache value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						theCache[key] = val;
						<span class="hljs-keyword">return</span> sanitize ? strip(val) : val;
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-764">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-764">&#182;</a>
              </div>
              <p>Remove cached value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">delete</span> theCache[key];
						<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-765">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-765">&#182;</a>
              </div>
              <p>Allow cache values to be empty strings. If key property does
not exist, fetch it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> theCache)) {
							getText(key, <span class="hljs-literal">true</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text)</span> {</span>
								theCache[key] = text;
							});
						}
						<span class="hljs-keyword">return</span> sanitize ? strip(theCache[key]) : theCache[key];
					}
				};
				<span class="hljs-keyword">return</span> {
					dynamic: <span class="hljs-literal">true</span>,
					normalize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, toAbsMid)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-766">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-766">&#182;</a>
              </div>
              <p>id is something like (path may be relative):</p>
<p> “path/to/text.html”
 “path/to/text.html!strip”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> parts = id.split(<span class="hljs-string">'!'</span>),
							url = parts[<span class="hljs-number">0</span>];
						<span class="hljs-keyword">return</span> (<span class="hljs-regexp">/^\./</span>.test(url) ? toAbsMid(url) : url) + (parts[<span class="hljs-number">1</span>] ? <span class="hljs-string">'!'</span> + parts[<span class="hljs-number">1</span>] : <span class="hljs-string">''</span>);
					},
					load: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, require, load)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-767">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-767">&#182;</a>
              </div>
              <p>id: String
    Path to the resource.
require: Function
    Object that include the function toUrl with given id returns a valid URL from which to load the text.
load: Function
    Callback function which will be called, when the loading finished.
id is something like (path is always absolute):</p>
<p> “path/to/text.html”
 “path/to/text.html!strip”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> parts = id.split(<span class="hljs-string">'!'</span>),
							stripFlag = parts.length &gt; <span class="hljs-number">1</span>,
							absMid = parts[<span class="hljs-number">0</span>],
							url = <span class="hljs-built_in">require</span>.toUrl(parts[<span class="hljs-number">0</span>]),
							requireCacheUrl = <span class="hljs-string">'url:'</span> + url,
							text = notFound,
							finish = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text)</span> {</span>
								load(stripFlag ? strip(text) : text);
							};
						<span class="hljs-keyword">if</span> (absMid <span class="hljs-keyword">in</span> theCache) {
							text = theCache[absMid];
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requireCacheUrl <span class="hljs-keyword">in</span> <span class="hljs-built_in">require</span>.cache) {
							text = <span class="hljs-built_in">require</span>.cache[requireCacheUrl];
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url <span class="hljs-keyword">in</span> theCache) {
							text = theCache[url];
						}
						<span class="hljs-keyword">if</span> (text === notFound) {
							<span class="hljs-keyword">if</span> (pending[url]) {
								pending[url].push(finish);
							} <span class="hljs-keyword">else</span> {
								<span class="hljs-keyword">var</span> pendingList = pending[url] = [finish];
								getText(url, !<span class="hljs-built_in">require</span>.async, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text)</span> {</span>
									theCache[absMid] = theCache[url] = text;
									<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pendingList.length;) {
										pendingList[i++](text);
									}
									<span class="hljs-keyword">delete</span> pending[url];
								});
							}
						} <span class="hljs-keyword">else</span> {
							finish(text);
						}
					}
				};
			});
		},
		<span class="hljs-string">'dojo/keys'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/keys'</span>, [
				<span class="hljs-string">'./_base/kernel'</span>,
				<span class="hljs-string">'./sniff'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, has)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-768">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-768">&#182;</a>
              </div>
              <p>module:
    dojo/keys</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> dojo.keys = {
					BACKSPACE: <span class="hljs-number">8</span>,
					TAB: <span class="hljs-number">9</span>,
					CLEAR: <span class="hljs-number">12</span>,
					ENTER: <span class="hljs-number">13</span>,
					SHIFT: <span class="hljs-number">16</span>,
					CTRL: <span class="hljs-number">17</span>,
					ALT: <span class="hljs-number">18</span>,
					META: has(<span class="hljs-string">'webkit'</span>) ? <span class="hljs-number">91</span> : <span class="hljs-number">224</span>,
					PAUSE: <span class="hljs-number">19</span>,
					CAPS_LOCK: <span class="hljs-number">20</span>,
					ESCAPE: <span class="hljs-number">27</span>,
					SPACE: <span class="hljs-number">32</span>,
					PAGE_UP: <span class="hljs-number">33</span>,
					PAGE_DOWN: <span class="hljs-number">34</span>,
					END: <span class="hljs-number">35</span>,
					HOME: <span class="hljs-number">36</span>,
					LEFT_ARROW: <span class="hljs-number">37</span>,
					UP_ARROW: <span class="hljs-number">38</span>,
					RIGHT_ARROW: <span class="hljs-number">39</span>,
					DOWN_ARROW: <span class="hljs-number">40</span>,
					INSERT: <span class="hljs-number">45</span>,
					DELETE: <span class="hljs-number">46</span>,
					HELP: <span class="hljs-number">47</span>,
					LEFT_WINDOW: <span class="hljs-number">91</span>,
					RIGHT_WINDOW: <span class="hljs-number">92</span>,
					SELECT: <span class="hljs-number">93</span>,
					NUMPAD_0: <span class="hljs-number">96</span>,
					NUMPAD_1: <span class="hljs-number">97</span>,
					NUMPAD_2: <span class="hljs-number">98</span>,
					NUMPAD_3: <span class="hljs-number">99</span>,
					NUMPAD_4: <span class="hljs-number">100</span>,
					NUMPAD_5: <span class="hljs-number">101</span>,
					NUMPAD_6: <span class="hljs-number">102</span>,
					NUMPAD_7: <span class="hljs-number">103</span>,
					NUMPAD_8: <span class="hljs-number">104</span>,
					NUMPAD_9: <span class="hljs-number">105</span>,
					NUMPAD_MULTIPLY: <span class="hljs-number">106</span>,
					NUMPAD_PLUS: <span class="hljs-number">107</span>,
					NUMPAD_ENTER: <span class="hljs-number">108</span>,
					NUMPAD_MINUS: <span class="hljs-number">109</span>,
					NUMPAD_PERIOD: <span class="hljs-number">110</span>,
					NUMPAD_DIVIDE: <span class="hljs-number">111</span>,
					F1: <span class="hljs-number">112</span>,
					F2: <span class="hljs-number">113</span>,
					F3: <span class="hljs-number">114</span>,
					F4: <span class="hljs-number">115</span>,
					F5: <span class="hljs-number">116</span>,
					F6: <span class="hljs-number">117</span>,
					F7: <span class="hljs-number">118</span>,
					F8: <span class="hljs-number">119</span>,
					F9: <span class="hljs-number">120</span>,
					F10: <span class="hljs-number">121</span>,
					F11: <span class="hljs-number">122</span>,
					F12: <span class="hljs-number">123</span>,
					F13: <span class="hljs-number">124</span>,
					F14: <span class="hljs-number">125</span>,
					F15: <span class="hljs-number">126</span>,
					NUM_LOCK: <span class="hljs-number">144</span>,
					SCROLL_LOCK: <span class="hljs-number">145</span>,
					UP_DPAD: <span class="hljs-number">175</span>,
					DOWN_DPAD: <span class="hljs-number">176</span>,
					LEFT_DPAD: <span class="hljs-number">177</span>,
					RIGHT_DPAD: <span class="hljs-number">178</span>,
					copyKey: has(<span class="hljs-string">'mac'</span>) &amp;&amp; !has(<span class="hljs-string">'air'</span>) ? has(<span class="hljs-string">'safari'</span>) ? <span class="hljs-number">91</span> : <span class="hljs-number">224</span> : <span class="hljs-number">17</span>
				};
			});
		},
		<span class="hljs-string">'dojo/domReady'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([<span class="hljs-string">'./has'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(has)</span> {</span>
				<span class="hljs-keyword">var</span> global = <span class="hljs-keyword">this</span>,
					doc = document,
					readyStates = {
						<span class="hljs-string">'loaded'</span>: <span class="hljs-number">1</span>,
						<span class="hljs-string">'complete'</span>: <span class="hljs-number">1</span>
					}, fixReadyState = <span class="hljs-keyword">typeof</span> doc.readyState !== <span class="hljs-string">'string'</span>,
					ready = !! readyStates[doc.readyState];</pre></div></div>
            
        </li>
        
        
        <li id="section-769">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-769">&#182;</a>
              </div>
              <p>For FF &lt;= 3.5</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (fixReadyState) {
					doc.readyState = <span class="hljs-string">'loading'</span>;
				}
				<span class="hljs-keyword">if</span> (!ready) {
					<span class="hljs-keyword">var</span> readyQ = [],
						tests = [],
						detectReady = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> {</span>
							evt = evt || global.event;
							<span class="hljs-keyword">if</span> (ready || evt.type === <span class="hljs-string">'readystatechange'</span> &amp;&amp; !readyStates[doc.readyState]) {
								<span class="hljs-keyword">return</span>;
							}
							ready = <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-770">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-770">&#182;</a>
              </div>
              <p>For FF &lt;= 3.5</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (fixReadyState) {
								doc.readyState = <span class="hljs-string">'complete'</span>;
							}
							<span class="hljs-keyword">while</span> (readyQ.length) {
								readyQ.shift()(doc);
							}
						}, on = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, event)</span> {</span>
							node.addEventListener(event, detectReady, <span class="hljs-literal">false</span>);
							readyQ.push(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								node.removeEventListener(event, detectReady, <span class="hljs-literal">false</span>);
							});
						};
					<span class="hljs-keyword">if</span> (!has(<span class="hljs-string">'dom-addeventlistener'</span>)) {
						on = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, event)</span> {</span>
							event = <span class="hljs-string">'on'</span> + event;
							node.attachEvent(event, detectReady);
							readyQ.push(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								node.detachEvent(event, detectReady);
							});
						};
						<span class="hljs-keyword">var</span> div = doc.createElement(<span class="hljs-string">'div'</span>);
						<span class="hljs-keyword">try</span> {
							<span class="hljs-keyword">if</span> (div.doScroll &amp;&amp; global.frameElement === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-771">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-771">&#182;</a>
              </div>
              <p>the doScroll test is only useful if we’re in the top-most frame</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								tests.push(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-772">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-772">&#182;</a>
              </div>
              <p>Derived with permission from Diego Perini’s IEContentLoaded
<a href="http://javascript.nwbox.com/IEContentLoaded/">http://javascript.nwbox.com/IEContentLoaded/</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-keyword">try</span> {
										div.doScroll(<span class="hljs-string">'left'</span>);
										<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
									} <span class="hljs-keyword">catch</span> (e) {}
								});
							}
						} <span class="hljs-keyword">catch</span> (e) {}
					}
					on(doc, <span class="hljs-string">'DOMContentLoaded'</span>);
					on(global, <span class="hljs-string">'load'</span>);
					<span class="hljs-keyword">if</span> (<span class="hljs-string">'onreadystatechange'</span> <span class="hljs-keyword">in</span> doc) {
						on(doc, <span class="hljs-string">'readystatechange'</span>);
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!fixReadyState) {</pre></div></div>
            
        </li>
        
        
        <li id="section-773">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-773">&#182;</a>
              </div>
              <p>if the ready state property exists and there’s
no readystatechange event, poll for the state
to change</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						tests.push(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							<span class="hljs-keyword">return</span> readyStates[doc.readyState];
						});
					}
					<span class="hljs-keyword">if</span> (tests.length) {
						<span class="hljs-keyword">var</span> poller = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							<span class="hljs-keyword">if</span> (ready) {
								<span class="hljs-keyword">return</span>;
							}
							<span class="hljs-keyword">var</span> i = tests.length;
							<span class="hljs-keyword">while</span> (i--) {
								<span class="hljs-keyword">if</span> (tests[i]()) {
									detectReady(<span class="hljs-string">'poller'</span>);
									<span class="hljs-keyword">return</span>;
								}
							}
							setTimeout(poller, <span class="hljs-number">30</span>);
						};
						poller();
					}
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">domReady</span><span class="hljs-params">(callback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-774">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-774">&#182;</a>
              </div>
              <p>summary:
    Plugin to delay require()/define() callback from firing until the DOM has finished loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (ready) {
						callback(doc);
					} <span class="hljs-keyword">else</span> {
						readyQ.push(callback);
					}
				}
				domReady.load = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, req, load)</span> {</span>
					domReady(load);
				};
				<span class="hljs-keyword">return</span> domReady;
			});
		},
		<span class="hljs-string">'dojo/_base/lang'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/_base/lang'</span>, [
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'../has'</span>,
				<span class="hljs-string">'../sniff'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, has)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-775">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-775">&#182;</a>
              </div>
              <p>module:
    dojo/_base/lang</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				has.add(<span class="hljs-string">'bug-for-in-skips-shadowed'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-776">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-776">&#182;</a>
              </div>
              <p>if true, the for-in iterator skips object properties that exist in Object’s prototype (IE 6 - ?)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> {
						toString: <span class="hljs-number">1</span>
					}) {
						<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
					}
					<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
				});</pre></div></div>
            
        </li>
        
        
        <li id="section-777">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-777">&#182;</a>
              </div>
              <p>Helper methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> _extraNames = has(<span class="hljs-string">'bug-for-in-skips-shadowed'</span>) ? <span class="hljs-string">'hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor'</span>.split(<span class="hljs-string">'.'</span>) : [],
					_extraLen = _extraNames.length,
					getProp = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(parts, create, context)</span> {</span>
						<span class="hljs-keyword">var</span> p, i = <span class="hljs-number">0</span>,
							dojoGlobal = dojo.global;
						<span class="hljs-keyword">if</span> (!context) {
							<span class="hljs-keyword">if</span> (!parts.length) {
								<span class="hljs-keyword">return</span> dojoGlobal;
							} <span class="hljs-keyword">else</span> {
								p = parts[i++];
								<span class="hljs-keyword">try</span> {
									context = dojo.scopeMap[p] &amp;&amp; dojo.scopeMap[p][<span class="hljs-number">1</span>];
								} <span class="hljs-keyword">catch</span> (e) {}
								context = context || (p <span class="hljs-keyword">in</span> dojoGlobal ? dojoGlobal[p] : create ? dojoGlobal[p] = {} : <span class="hljs-literal">undefined</span>);
							}
						}
						<span class="hljs-keyword">while</span> (context &amp;&amp; (p = parts[i++])) {
							context = p <span class="hljs-keyword">in</span> context ? context[p] : create ? context[p] = {} : <span class="hljs-literal">undefined</span>;
						}
						<span class="hljs-keyword">return</span> context; <span class="hljs-comment">// mixed</span>
					}, opts = <span class="hljs-built_in">Object</span>.prototype.toString,
					efficient = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj, offset, startWith)</span> {</span>
						<span class="hljs-keyword">return</span> (startWith || [])
							.concat(<span class="hljs-built_in">Array</span>.prototype.slice.call(obj, offset || <span class="hljs-number">0</span>));
					}, _pattern = <span class="hljs-regexp">/\{([^\}]+)\}/g</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-778">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-778">&#182;</a>
              </div>
              <p>Module export</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> lang = {
					_extraNames: _extraNames,
					_mixin: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dest, source, copyFunc)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-779">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-779">&#182;</a>
              </div>
              <p>summary:
    Copies/adds all properties of source to dest; returns dest.
dest: Object
    The object to which to copy/add all properties contained in source.
source: Object
    The object from which to draw all properties to copy into dest.
copyFunc: Function?
    The process used to copy/add a property in source; defaults to the Javascript assignment operator.
returns:
    dest, as modified
description:
    All properties, including functions (sometimes termed “methods”), excluding any non-standard extensions
    found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
    delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
    Notice that by default, _mixin executes a so-called “shallow copy” and aggregate types are copied/added by reference.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> name, s, i, empty = {};
						<span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> source) {</pre></div></div>
            
        </li>
        
        
        <li id="section-780">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-780">&#182;</a>
              </div>
              <p>the (!(name in empty) || empty[name] !== s) condition avoids copying properties in “source”
inherited from Object.prototype.     For example, if dest has a custom toString() method,
don’t overwrite it with the toString() method that source inherited from Object.prototype</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							s = source[name];
							<span class="hljs-keyword">if</span> (!(name <span class="hljs-keyword">in</span> dest) || dest[name] !== s &amp;&amp; (!(name <span class="hljs-keyword">in</span> empty) || empty[name] !== s)) {
								dest[name] = copyFunc ? copyFunc(s) : s;
							}
						}
						<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'bug-for-in-skips-shadowed'</span>)) {
							<span class="hljs-keyword">if</span> (source) {
								<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; _extraLen; ++i) {
									name = _extraNames[i];
									s = source[name];
									<span class="hljs-keyword">if</span> (!(name <span class="hljs-keyword">in</span> dest) || dest[name] !== s &amp;&amp; (!(name <span class="hljs-keyword">in</span> empty) || empty[name] !== s)) {
										dest[name] = copyFunc ? copyFunc(s) : s;
									}
								}
							}
						}
						<span class="hljs-keyword">return</span> dest; <span class="hljs-comment">// Object</span>
					},
					mixin: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dest, sources)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-781">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-781">&#182;</a>
              </div>
              <p>summary:
    Copies/adds all properties of one or more sources to dest; returns dest.
dest: Object
    The object to which to copy/add all properties contained in source. If dest is falsy, then
    a new object is manufactured before copying/adding properties begins.
sources: Object…
    One of more objects from which to draw all properties to copy into dest. sources are processed
    left-to-right and if more than one of these objects contain the same property name, the right-most
    value “wins”.
returns: Object
    dest, as modified
description:
    All properties, including functions (sometimes termed “methods”), excluding any non-standard extensions
    found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
    The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
    executes a so-called “shallow copy” and aggregate types are copied/added by reference.
example:
    make a shallow copy of an object
|    var copy = lang.mixin({}, source);
example:
    many class constructors often take an object which specifies
    values to be configured on the object. In this case, it is
    often simplest to call <code>lang.mixin</code> on the <code>this</code> object:
|    declare(“acme.Base”, null, {
|        constructor: function(properties){
|            // property configuration:
|            lang.mixin(this, properties);
|
|            console.log(this.quip);
|            //    …
|        },
|        quip: “I wasn’t born yesterday, you know - I’ve seen movies.”,
|        // …
|    });
|
|    // create an instance of the class and configure it
|    var b = new acme.Base({quip: “That’s what it does!” });
example:
    copy in properties from multiple objects
|    var flattened = lang.mixin(
|        {
|            name: “Frylock”,
|            braces: true
|        },
|        {
|            name: “Carl Brutanananadilewski”
|        }
|    );
|
|    // will print “Carl Brutanananadilewski”
|    console.log(flattened.name);
|    // will print “true”
|    console.log(flattened.braces);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!dest) {
							dest = {};
						}
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, l = <span class="hljs-built_in">arguments</span>.length; i &lt; l; i++) {
							lang._mixin(dest, <span class="hljs-built_in">arguments</span>[i]);
						}
						<span class="hljs-keyword">return</span> dest; <span class="hljs-comment">// Object</span>
					},
					setObject: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, value, context)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-782">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-782">&#182;</a>
              </div>
              <p>summary:
    Set a property from a dot-separated string, such as “A.B.C”
description:
    Useful for longer api chains where you have to test each object in
    the chain, or when you have an object reference in string format.
    Objects are created as needed along <code>path</code>. Returns the passed
    value if setting is successful or <code>undefined</code> if not.
name: String
    Path to a property, in the form “A.B.C”.
value: anything
    value or object to place at location given by name
context: Object?
    Optional. Object to use as root of path. Defaults to
    <code>dojo.global</code>.
example:
    set the value of <code>foo.bar.baz</code>, regardless of whether
    intermediate objects already exist:
| lang.setObject(“foo.bar.baz”, value);
example:
    without <code>lang.setObject</code>, we often see code like this:
| // ensure that intermediate objects are available
| if(!obj[“parent”]){ obj.parent = {}; }
| if(!obj.parent[“child”]){ obj.parent.child = {}; }
| // now we can safely set the property
| obj.parent.child.prop = “some value”;
    whereas with <code>lang.setObject</code>, we can shorten that to:
| lang.setObject(“parent.child.prop”, “some value”, obj);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> parts = name.split(<span class="hljs-string">'.'</span>),
							p = parts.pop(),
							obj = getProp(parts, <span class="hljs-literal">true</span>, context);
						<span class="hljs-keyword">return</span> obj &amp;&amp; p ? obj[p] = value : <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// Object</span>
					},
					getObject: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, create, context)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-783">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-783">&#182;</a>
              </div>
              <p>summary:
    Get a property from a dot-separated string, such as “A.B.C”
description:
    Useful for longer api chains where you have to test each object in
    the chain, or when you have an object reference in string format.
name: String
    Path to an property, in the form “A.B.C”.
create: Boolean?
    Optional. Defaults to <code>false</code>. If <code>true</code>, Objects will be
    created at any point along the ‘path’ that is undefined.
context: Object?
    Optional. Object to use as root of path. Defaults to
    ‘dojo.global’. Null may be passed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> getProp(name.split(<span class="hljs-string">'.'</span>), create, context); <span class="hljs-comment">// Object</span>
					},
					exists: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, obj)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-784">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-784">&#182;</a>
              </div>
              <p>summary:
    determine if an object supports a given method
description:
    useful for longer api chains where you have to test each object in
    the chain. Useful for object and method detection.
name: String
    Path to an object, in the form “A.B.C”.
obj: Object?
    Object to use as root of path. Defaults to
    ‘dojo.global’. Null may be passed.
example:
| // define an object
| var foo = {
|        bar: { }
| };
|
| // search the global scope
| lang.exists(“foo.bar”); // true
| lang.exists(“foo.bar.baz”); // false
|
| // search from a particular scope
| lang.exists(“bar”, foo); // true
| lang.exists(“bar.baz”, foo); // false</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> lang.getObject(name, <span class="hljs-literal">false</span>, obj) !== <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// Boolean</span>
					},
					isString: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(it)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-785">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-785">&#182;</a>
              </div>
              <p>summary:
    Return true if it is a String
it: anything
    Item to test.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> it === <span class="hljs-string">'string'</span> || it <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>; <span class="hljs-comment">// Boolean</span>
					},
					isArray: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(it)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-786">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-786">&#182;</a>
              </div>
              <p>summary:
    Return true if it is an Array.
    Does not work on Arrays created in other windows.
it: anything
    Item to test.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> it &amp;&amp; (it <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> || <span class="hljs-keyword">typeof</span> it === <span class="hljs-string">'array'</span>); <span class="hljs-comment">// Boolean</span>
					},
					isFunction: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(it)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-787">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-787">&#182;</a>
              </div>
              <p>summary:
    Return true if it is a Function
it: anything
    Item to test.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> opts.call(it) === <span class="hljs-string">'[object Function]'</span>;
					},
					isObject: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(it)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-788">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-788">&#182;</a>
              </div>
              <p>summary:
    Returns true if it is a JavaScript object (or an Array, a Function
    or null)
it: anything
    Item to test.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> it !== <span class="hljs-literal">undefined</span> &amp;&amp; (it === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> it === <span class="hljs-string">'object'</span> || lang.isArray(it) || lang.isFunction(it)); <span class="hljs-comment">// Boolean</span>
					},
					isArrayLike: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(it)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-789">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-789">&#182;</a>
              </div>
              <p>summary:
    similar to isArray() but more permissive
it: anything
    Item to test.
returns:
    If it walks like a duck and quacks like a duck, return <code>true</code>
description:
    Doesn’t strongly test for “arrayness”.  Instead, settles for “isn’t
    a string or number and has a length property”. Arguments objects
    and DOM collections will return true when passed to
    isArrayLike(), but will return false when passed to
    isArray().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> it &amp;&amp; it !== <span class="hljs-literal">undefined</span> &amp;&amp; !lang.isString(it) &amp;&amp; !lang.isFunction(it) &amp;&amp; !(it.tagName &amp;&amp; it.tagName.toLowerCase() === <span class="hljs-string">'form'</span>) &amp;&amp; (lang.isArray(it) || <span class="hljs-built_in">isFinite</span>(it.length));
					},
					isAlien: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(it)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-790">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-790">&#182;</a>
              </div>
              <p>summary:
    Returns true if it is a built-in function or some other kind of
    oddball that <em>should</em> report as a function but doesn’t</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> it &amp;&amp; !lang.isFunction(it) &amp;&amp; <span class="hljs-regexp">/\{\s*\[native code\]\s*\}/</span>.test(<span class="hljs-built_in">String</span>(it)); <span class="hljs-comment">// Boolean</span>
					},
					extend: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(ctor, props)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-791">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-791">&#182;</a>
              </div>
              <p>summary:
    Adds all properties and methods of props to constructor’s
    prototype, making them available to all instances created with
    constructor.
ctor: Object
    Target constructor to extend.
props: Object
    One or more objects to mix into ctor.prototype</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, l = <span class="hljs-built_in">arguments</span>.length; i &lt; l; i++) {
							lang._mixin(ctor.prototype, <span class="hljs-built_in">arguments</span>[i]);
						}
						<span class="hljs-keyword">return</span> ctor; <span class="hljs-comment">// Object</span>
					},
					_hitchArgs: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(scope, method)</span> {</span>
						<span class="hljs-keyword">var</span> pre = lang._toArray(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);
						<span class="hljs-keyword">var</span> named = lang.isString(method);
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-792">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-792">&#182;</a>
              </div>
              <p>arrayify arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> args = lang._toArray(<span class="hljs-built_in">arguments</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-793">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-793">&#182;</a>
              </div>
              <p>locate our method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> f = named ? (scope || dojo.global)[method] : method;</pre></div></div>
            
        </li>
        
        
        <li id="section-794">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-794">&#182;</a>
              </div>
              <p>invoke with collected args</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> f &amp;&amp; f.apply(scope || <span class="hljs-keyword">this</span>, pre.concat(args)); <span class="hljs-comment">// mixed</span>
						}; <span class="hljs-comment">// Function</span>
					},
					hitch: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(scope, method)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-795">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-795">&#182;</a>
              </div>
              <p>summary:
    Returns a function that will only ever execute in the a given scope.
    This allows for easy use of object member functions
    in callbacks and other places in which the “this” keyword may
    otherwise not reference the expected scope.
    Any number of default positional arguments may be passed as parameters
    beyond “method”.
    Each of these values will be used to “placehold” (similar to curry)
    for the hitched function.
scope: Object
    The scope to use when method executes. If method is a string,
    scope is also the object containing method.
method: Function|String…
    A function to be hitched to scope, or the name of the method in
    scope to be hitched.
example:
|    lang.hitch(foo, “bar”)();
    runs foo.bar() in the scope of foo
example:
|    lang.hitch(foo, myFunction);
    returns a function that runs myFunction in the scope of foo
example:
    Expansion on the default positional arguments passed along from
    hitch. Passed args are mixed first, additional args after.
|    var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
|    var fn = lang.hitch(foo, “bar”, 1, 2);
|    fn(3); // logs “1, 2, 3”
example:
|    var foo = { bar: 2 };
|    lang.hitch(foo, function(){ this.bar = 10; })();
    execute an anonymous function in scope of foo</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span>) {
							<span class="hljs-keyword">return</span> lang._hitchArgs.apply(dojo, <span class="hljs-built_in">arguments</span>); <span class="hljs-comment">// Function</span>
						}
						<span class="hljs-keyword">if</span> (!method) {
							method = scope;
							scope = <span class="hljs-literal">null</span>;
						}
						<span class="hljs-keyword">if</span> (lang.isString(method)) {
							scope = scope || dojo.global;
							<span class="hljs-keyword">if</span> (!scope[method]) {
								<span class="hljs-keyword">throw</span> [
									<span class="hljs-string">'lang.hitch: scope["'</span>,
									method,
									<span class="hljs-string">'"] is null (scope="'</span>,
									scope,
									<span class="hljs-string">'")'</span>
								].join(<span class="hljs-string">''</span>);
							}
							<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								<span class="hljs-keyword">return</span> scope[method].apply(scope, <span class="hljs-built_in">arguments</span> || []);
							}; <span class="hljs-comment">// Function</span>
						}
						<span class="hljs-keyword">return</span> !scope ? method : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							<span class="hljs-keyword">return</span> method.apply(scope, <span class="hljs-built_in">arguments</span> || []);
						}; <span class="hljs-comment">// Function</span>
					},
					delegate: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-796">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-796">&#182;</a>
              </div>
              <p>boodman/crockford delegation w/ cornford optimization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TMP</span><span class="hljs-params">()</span> {</span>}
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj, props)</span> {</span>
							TMP.prototype = obj;
							<span class="hljs-keyword">var</span> tmp = <span class="hljs-keyword">new</span> TMP();
							TMP.prototype = <span class="hljs-literal">null</span>;
							<span class="hljs-keyword">if</span> (props) {
								lang._mixin(tmp, props);
							}
							<span class="hljs-keyword">return</span> tmp; <span class="hljs-comment">// Object</span>
						};
					}(),
					_toArray: has(<span class="hljs-string">'ie'</span>) ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">slow</span><span class="hljs-params">(obj, offset, startWith)</span> {</span>
							<span class="hljs-keyword">var</span> arr = startWith || [];
							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = offset || <span class="hljs-number">0</span>; x &lt; obj.length; x++) {
								arr.push(obj[x]);
							}
							<span class="hljs-keyword">return</span> arr;
						}
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> {</span>
							<span class="hljs-keyword">return</span> (obj.item ? slow : efficient)
								.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
						};
					}() : efficient,
					partial: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(method)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-797">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-797">&#182;</a>
              </div>
              <p>summary:
    similar to hitch() except that the scope object is left to be
    whatever the execution context eventually becomes.
description:
    Calling lang.partial is the functional equivalent of calling:
    |    lang.hitch(null, funcName, …);
method:
    The function to “wrap”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> arr = [<span class="hljs-literal">null</span>];
						<span class="hljs-keyword">return</span> lang.hitch.apply(dojo, arr.concat(lang._toArray(<span class="hljs-built_in">arguments</span>))); <span class="hljs-comment">// Function</span>
					},
					clone: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(src)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-798">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-798">&#182;</a>
              </div>
              <p>summary:
    Clones objects (including DOM nodes) and all children.
    Warning: do not clone cyclic structures.
src:
    The object to clone</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!src || <span class="hljs-keyword">typeof</span> src !== <span class="hljs-string">'object'</span> || lang.isFunction(src)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-799">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-799">&#182;</a>
              </div>
              <p>null, undefined, any non-object, or function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> src; <span class="hljs-comment">// anything</span>
						}
						<span class="hljs-keyword">if</span> (src.nodeType &amp;&amp; <span class="hljs-string">'cloneNode'</span> <span class="hljs-keyword">in</span> src) {</pre></div></div>
            
        </li>
        
        
        <li id="section-800">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-800">&#182;</a>
              </div>
              <p>DOM Node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> src.cloneNode(<span class="hljs-literal">true</span>); <span class="hljs-comment">// Node</span>
						}
						<span class="hljs-keyword">if</span> (src <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-801">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-801">&#182;</a>
              </div>
              <p>Date</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(src.getTime()); <span class="hljs-comment">// Date</span>
						}
						<span class="hljs-keyword">if</span> (src <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-802">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-802">&#182;</a>
              </div>
              <p>RegExp</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(src); <span class="hljs-comment">// RegExp</span>
						}
						<span class="hljs-keyword">var</span> r, i, l;
						<span class="hljs-keyword">if</span> (lang.isArray(src)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-803">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-803">&#182;</a>
              </div>
              <p>array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							r = [];
							<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = src.length; i &lt; l; ++i) {
								<span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> src) {
									r.push(lang.clone(src[i]));
								}
							} <span class="hljs-comment">// we don't clone functions for performance reasons</span></pre></div></div>
            
        </li>
        
        
        <li id="section-804">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-804">&#182;</a>
              </div>
              <pre><code>}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d.isFunction(src)){
    <span class="hljs-comment">// function</span>
    r = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span> <span class="hljs-keyword">return</span> src.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>); };
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>						} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-805">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-805">&#182;</a>
              </div>
              <p>generic objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							r = src.constructor ? <span class="hljs-keyword">new</span> src.constructor() : {};
						}
						<span class="hljs-keyword">return</span> lang._mixin(r, src, lang.clone);
					},
					trim: <span class="hljs-built_in">String</span>.prototype.trim ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(str)</span> {</span>
						<span class="hljs-keyword">return</span> str.trim();
					} : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(str)</span> {</span>
						<span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/^\s\s*/</span>, <span class="hljs-string">''</span>)
							.replace(<span class="hljs-regexp">/\s\s*$/</span>, <span class="hljs-string">''</span>);
					},
					replace: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(tmpl, map, pattern)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-806">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-806">&#182;</a>
              </div>
              <p>summary:
    Performs parameterized substitutions on a string. Throws an
    exception if any parameter is unmatched.
tmpl: String
    String to be used as a template.
map: Object|Function
    If an object, it is used as a dictionary to look up substitutions.
    If a function, it is called for every substitution with following parameters:
    a whole match, a name, an offset, and the whole template
    string (see <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace</a>
    for more details).
pattern: RegEx?
    Optional regular expression objects that overrides the default pattern.
    Must be global and match one item. The default is: /{([^}]+)}/g,
    which matches patterns like that: “{xxx}”, where “xxx” is any sequence
    of characters, which doesn’t include “}”.
returns: String
    Returns the substituted string.
example:
|    // uses a dictionary for substitutions:
|    lang.replace(“Hello, {name.first} {name.last} AKA {nick}!”,
|        {
|            nick: “Bob”,
|            name: {
|                first:    “Robert”,
|                middle: “X”,
|                last:        “Cringely”
|            }
|        });
|    // returns: Hello, Robert Cringely AKA Bob!
example:
|    // uses an array for substitutions:
|    lang.replace(“Hello, {0} {2}!”,
|        [“Robert”, “X”, “Cringely”]);
|    // returns: Hello, Robert Cringely!
example:
|    // uses a function for substitutions:
|    function sum(a){
|        var t = 0;
|        arrayforEach(a, function(x){ t += x; });
|        return t;
|    }
|    lang.replace(
|        “{count} payments averaging {avg} USD per payment.”,
|        lang.hitch(
|            { payments: [11, 16, 12] },
|            function(_, key){
|                switch(key){
|                    case “count”: return this.payments.length;
|                    case “min”:        return Math.min.apply(Math, this.payments);
|                    case “max”:        return Math.max.apply(Math, this.payments);
|                    case “sum”:        return sum(this.payments);
|                    case “avg”:        return sum(this.payments) / this.payments.length;
|                }
|            }
|        )
|    );
|    // prints: 3 payments averaging 13 USD per payment.
example:
|    // uses an alternative PHP-like pattern for substitutions:
|    lang.replace(“Hello, ${0} ${2}!”,
|        [“Robert”, “X”, “Cringely”], /\${([^}]+)}/g);
|    // returns: Hello, Robert Cringely!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> tmpl.replace(pattern || _pattern, lang.isFunction(map) ? map : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(_, k)</span> {</span>
							<span class="hljs-keyword">return</span> lang.getObject(k, <span class="hljs-literal">false</span>, map);
						});
					}
				};
				<span class="hljs-number">1</span> &amp;&amp; lang.mixin(dojo, lang);
				<span class="hljs-keyword">return</span> lang;
			});
		},
		<span class="hljs-string">'dojo/request/util'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/request/util'</span>, [
				<span class="hljs-string">'exports'</span>,
				<span class="hljs-string">'../errors/RequestError'</span>,
				<span class="hljs-string">'../errors/CancelError'</span>,
				<span class="hljs-string">'../Deferred'</span>,
				<span class="hljs-string">'../io-query'</span>,
				<span class="hljs-string">'../_base/array'</span>,
				<span class="hljs-string">'../_base/lang'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, RequestError, CancelError, Deferred, ioQuery, array, lang)</span> {</span>
				exports.deepCopy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepCopy</span><span class="hljs-params">(target, source)</span> {</span>
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> source) {
						<span class="hljs-keyword">var</span> tval = target[name],
							sval = source[name];
						<span class="hljs-keyword">if</span> (tval !== sval) {
							<span class="hljs-keyword">if</span> (tval &amp;&amp; <span class="hljs-keyword">typeof</span> tval === <span class="hljs-string">'object'</span> &amp;&amp; sval &amp;&amp; <span class="hljs-keyword">typeof</span> sval === <span class="hljs-string">'object'</span>) {
								exports.deepCopy(tval, sval);
							} <span class="hljs-keyword">else</span> {
								target[name] = sval;
							}
						}
					}
					<span class="hljs-keyword">return</span> target;
				};
				exports.deepCreate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepCreate</span><span class="hljs-params">(source, properties)</span> {</span>
					properties = properties || {};
					<span class="hljs-keyword">var</span> target = lang.delegate(source),
						name, value;
					<span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> source) {
						value = source[name];
						<span class="hljs-keyword">if</span> (value &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span>) {
							target[name] = exports.deepCreate(value, properties[name]);
						}
					}
					<span class="hljs-keyword">return</span> exports.deepCopy(target, properties);
				};
				<span class="hljs-keyword">var</span> freeze = <span class="hljs-built_in">Object</span>.freeze || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> {</span>
						<span class="hljs-keyword">return</span> obj;
					};

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">okHandler</span><span class="hljs-params">(response)</span> {</span>
					<span class="hljs-keyword">return</span> freeze(response);
				}
				exports.deferred = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deferred</span><span class="hljs-params">(response, cancel, isValid, isReady, handleResponse, last)</span> {</span>
					<span class="hljs-keyword">var</span> def = <span class="hljs-keyword">new</span> Deferred(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(reason)</span> {</span>
						cancel &amp;&amp; cancel(def, response);
						<span class="hljs-keyword">if</span> (!reason || !(reason <span class="hljs-keyword">instanceof</span> RequestError) &amp;&amp; !(reason <span class="hljs-keyword">instanceof</span> CancelError)) {
							<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CancelError(<span class="hljs-string">'Request canceled'</span>, response);
						}
						<span class="hljs-keyword">return</span> reason;
					});
					def.response = response;
					def.isValid = isValid;
					def.isReady = isReady;
					def.handleResponse = handleResponse;

					<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errHandler</span><span class="hljs-params">(error)</span> {</span>
						error.response = response;
						<span class="hljs-keyword">throw</span> error;
					}
					<span class="hljs-keyword">var</span> responsePromise = def.then(okHandler)
						.otherwise(errHandler);
					<span class="hljs-keyword">if</span> (exports.notify) {
						responsePromise.then(lang.hitch(exports.notify, <span class="hljs-string">'emit'</span>, <span class="hljs-string">'load'</span>), lang.hitch(exports.notify, <span class="hljs-string">'emit'</span>, <span class="hljs-string">'error'</span>));
					}
					<span class="hljs-keyword">var</span> dataPromise = responsePromise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span>
						<span class="hljs-keyword">return</span> response.data || response.text;
					});
					<span class="hljs-keyword">var</span> promise = freeze(lang.delegate(dataPromise, {
						response: responsePromise
					}));
					<span class="hljs-keyword">if</span> (last) {
						def.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span>
							last.call(def, response);
						}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> {</span>
							last.call(def, response, error);
						});
					}
					def.promise = promise;
					def.then = promise.then;
					<span class="hljs-keyword">return</span> def;
				};
				exports.addCommonMethods = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCommonMethods</span><span class="hljs-params">(provider, methods)</span> {</span>
					array.forEach(methods || [
						<span class="hljs-string">'GET'</span>,
						<span class="hljs-string">'POST'</span>,
						<span class="hljs-string">'PUT'</span>,
						<span class="hljs-string">'DELETE'</span>
					], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(method)</span> {</span>
						provider[(method === <span class="hljs-string">'DELETE'</span> ? <span class="hljs-string">'DEL'</span> : method)
							.toLowerCase()] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(url, options)</span> {</span>
							options = lang.delegate(options || {});
							options.method = method;
							<span class="hljs-keyword">return</span> provider(url, options);
						};
					});
				};
				exports.parseArgs = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseArgs</span><span class="hljs-params">(url, options, skipData)</span> {</span>
					<span class="hljs-keyword">var</span> data = options.data,
						query = options.query;
					<span class="hljs-keyword">if</span> (data &amp;&amp; !skipData) {
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'object'</span>) {
							options.data = ioQuery.objectToQuery(data);
						}
					}
					<span class="hljs-keyword">if</span> (query) {
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> query === <span class="hljs-string">'object'</span>) {
							query = ioQuery.objectToQuery(query);
						}
						<span class="hljs-keyword">if</span> (options.preventCache) {
							query += (query ? <span class="hljs-string">'&amp;'</span> : <span class="hljs-string">''</span>) + <span class="hljs-string">'request.preventCache='</span> + +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
						}
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.preventCache) {
						query = <span class="hljs-string">'request.preventCache='</span> + +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
					}
					<span class="hljs-keyword">if</span> (url &amp;&amp; query) {
						url += (~url.indexOf(<span class="hljs-string">'?'</span>) ? <span class="hljs-string">'&amp;'</span> : <span class="hljs-string">'?'</span>) + query;
					}
					<span class="hljs-keyword">return</span> {
						url: url,
						options: options,
						getHeader: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(headerName)</span> {</span>
							<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
						}
					};
				};
				exports.checkStatus = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(stat)</span> {</span>
					stat = stat || <span class="hljs-number">0</span>;
					<span class="hljs-keyword">return</span> stat &gt;= <span class="hljs-number">200</span> &amp;&amp; stat &lt; <span class="hljs-number">300</span> || stat === <span class="hljs-number">304</span> || stat === <span class="hljs-number">1223</span> || !stat; <span class="hljs-comment">// or, we're Titanium/browser chrome/chrome extension requesting a local file</span>
				};
			});
		},
		<span class="hljs-string">'dojo/Evented'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/Evented'</span>, [
				<span class="hljs-string">'./aspect'</span>,
				<span class="hljs-string">'./on'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(aspect, on)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-807">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-807">&#182;</a>
              </div>
              <p>module:
    dojo/Evented</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">				'use strict'</span>;
				<span class="hljs-keyword">var</span> after = aspect.after;

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Evented</span><span class="hljs-params">()</span> {</span>}
				Evented.prototype = {
					on: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type, listener)</span> {</span>
						<span class="hljs-keyword">return</span> on.parse(<span class="hljs-keyword">this</span>, type, listener, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, type)</span> {</span>
							<span class="hljs-keyword">return</span> after(target, <span class="hljs-string">'on'</span> + type, listener, <span class="hljs-literal">true</span>);
						});
					},
					emit: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type, event)</span> {</span>
						<span class="hljs-keyword">var</span> args = [<span class="hljs-keyword">this</span>];
						args.push.apply(args, <span class="hljs-built_in">arguments</span>);
						<span class="hljs-keyword">return</span> on.emit.apply(on, args);
					}
				};
				<span class="hljs-keyword">return</span> Evented;
			});
		},
		<span class="hljs-string">'dojo/mouse'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/mouse'</span>, [
				<span class="hljs-string">'./_base/kernel'</span>,
				<span class="hljs-string">'./on'</span>,
				<span class="hljs-string">'./has'</span>,
				<span class="hljs-string">'./dom'</span>,
				<span class="hljs-string">'./_base/window'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, on, has, dom, win)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-808">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-808">&#182;</a>
              </div>
              <p>module:
    dojo/mouse</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				has.add(<span class="hljs-string">'dom-quirks'</span>, win.doc &amp;&amp; win.doc.compatMode === <span class="hljs-string">'BackCompat'</span>);
				has.add(<span class="hljs-string">'events-mouseenter'</span>, win.doc &amp;&amp; <span class="hljs-string">'onmouseenter'</span> <span class="hljs-keyword">in</span> win.doc.createElement(<span class="hljs-string">'div'</span>));
				has.add(<span class="hljs-string">'events-mousewheel'</span>, win.doc &amp;&amp; <span class="hljs-string">'onmousewheel'</span> <span class="hljs-keyword">in</span> win.doc);
				<span class="hljs-keyword">var</span> mouseButtons;
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'dom-quirks'</span>) &amp;&amp; has(<span class="hljs-string">'ie'</span>) || !has(<span class="hljs-string">'dom-addeventlistener'</span>)) {
					mouseButtons = {
						LEFT: <span class="hljs-number">1</span>,
						MIDDLE: <span class="hljs-number">4</span>,
						RIGHT: <span class="hljs-number">2</span>,
						isButton: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e, button)</span> {</span>
							<span class="hljs-keyword">return</span> e.button &amp; button;
						},
						isLeft: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
							<span class="hljs-keyword">return</span> e.button &amp; <span class="hljs-number">1</span>;
						},
						isMiddle: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
							<span class="hljs-keyword">return</span> e.button &amp; <span class="hljs-number">4</span>;
						},
						isRight: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
							<span class="hljs-keyword">return</span> e.button &amp; <span class="hljs-number">2</span>;
						}
					};
				} <span class="hljs-keyword">else</span> {
					mouseButtons = {
						LEFT: <span class="hljs-number">0</span>,
						MIDDLE: <span class="hljs-number">1</span>,
						RIGHT: <span class="hljs-number">2</span>,
						isButton: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e, button)</span> {</span>
							<span class="hljs-keyword">return</span> e.button === button;
						},
						isLeft: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
							<span class="hljs-keyword">return</span> e.button === <span class="hljs-number">0</span>;
						},
						isMiddle: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
							<span class="hljs-keyword">return</span> e.button === <span class="hljs-number">1</span>;
						},
						isRight: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
							<span class="hljs-keyword">return</span> e.button === <span class="hljs-number">2</span>;
						}
					};
				}
				dojo.mouseButtons = mouseButtons;
				<span class="hljs-comment">/*=====
             dojo.mouseButtons = {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-809">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-809">&#182;</a>
              </div>
              <p>LEFT: Number
    Numeric value of the left mouse button for the platform.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             LEFT:   <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-810">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-810">&#182;</a>
              </div>
              <p>MIDDLE: Number
    Numeric value of the middle mouse button for the platform.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             MIDDLE: <span class="hljs-number">1</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-811">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-811">&#182;</a>
              </div>
              <p>RIGHT: Number
    Numeric value of the right mouse button for the platform.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             RIGHT:  <span class="hljs-number">2</span>,

             isButton: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e, button)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-812">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-812">&#182;</a>
              </div>
              <p>summary:
    Checks an event object for a pressed button
e: Event
    Event object to examine
button: Number
    The button value (example: dojo.mouseButton.LEFT)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             <span class="hljs-keyword">return</span> e.button == button; <span class="hljs-comment">// Boolean</span>
             },
             isLeft: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-813">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-813">&#182;</a>
              </div>
              <p>summary:
    Checks an event object for the pressed left button
e: Event
    Event object to examine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             <span class="hljs-keyword">return</span> e.button == <span class="hljs-number">0</span>; <span class="hljs-comment">// Boolean</span>
             },
             isMiddle: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-814">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-814">&#182;</a>
              </div>
              <p>summary:
    Checks an event object for the pressed middle button
e: Event
    Event object to examine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             <span class="hljs-keyword">return</span> e.button == <span class="hljs-number">1</span>; <span class="hljs-comment">// Boolean</span>
             },
             isRight: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-815">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-815">&#182;</a>
              </div>
              <p>summary:
    Checks an event object for the pressed right button
e: Event
    Event object to examine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             return e.button == 2; // Boolean
             }
             };
             =====*/
				function eventHandler(type, selectHandler) {</pre></div></div>
            
        </li>
        
        
        <li id="section-816">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-816">&#182;</a>
              </div>
              <p>emulation of mouseenter/leave with mouseover/out using descendant checking</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, listener)</span> {</span>
						<span class="hljs-keyword">return</span> on(node, type, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> {</span>
							<span class="hljs-keyword">if</span> (selectHandler) {
								<span class="hljs-keyword">return</span> selectHandler(evt, listener);
							}
							<span class="hljs-keyword">if</span> (!dom.isDescendant(evt.relatedTarget, node)) {
								<span class="hljs-keyword">return</span> listener.call(<span class="hljs-keyword">this</span>, evt);
							}
						});
					};
					handler.bubble = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(select)</span> {</span>
						<span class="hljs-keyword">return</span> eventHandler(type, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt, listener)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-817">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-817">&#182;</a>
              </div>
              <p>using a selector, use the select function to determine if the mouse moved inside the selector and was previously outside the selector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> target = select(evt.target);
							<span class="hljs-keyword">var</span> relatedTarget = evt.relatedTarget;
							<span class="hljs-keyword">if</span> (target &amp;&amp; target !== (relatedTarget &amp;&amp; relatedTarget.nodeType === <span class="hljs-number">1</span> &amp;&amp; select(relatedTarget))) {
								<span class="hljs-keyword">return</span> listener.call(target, evt);
							}
						});
					};
					<span class="hljs-keyword">return</span> handler;
				}
				<span class="hljs-keyword">var</span> wheel;
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'events-mousewheel'</span>)) {
					wheel = <span class="hljs-string">'mousewheel'</span>;
				} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-818">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-818">&#182;</a>
              </div>
              <p>firefox</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					wheel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, listener)</span> {</span>
						<span class="hljs-keyword">return</span> on(node, <span class="hljs-string">'DOMMouseScroll'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> {</span>
							evt.wheelDelta = -evt.detail;
							listener.call(<span class="hljs-keyword">this</span>, evt);
						});
					};
				}
				<span class="hljs-keyword">return</span> {
					_eventHandler: eventHandler,
					enter: eventHandler(<span class="hljs-string">'mouseover'</span>),
					leave: eventHandler(<span class="hljs-string">'mouseout'</span>),
					wheel: wheel,
					isLeft: mouseButtons.isLeft,
					isMiddle: mouseButtons.isMiddle,
					isRight: mouseButtons.isRight
				};
			});
		},
		<span class="hljs-string">'dojo/topic'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/topic'</span>, [<span class="hljs-string">'./Evented'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Evented)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-819">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-819">&#182;</a>
              </div>
              <p>module:
    dojo/topic</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> hub = <span class="hljs-keyword">new</span> Evented();
				<span class="hljs-keyword">return</span> {
					publish: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(topic, event)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-820">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-820">&#182;</a>
              </div>
              <p>summary:
    Publishes a message to a topic on the pub/sub hub. All arguments after
    the first will be passed to the subscribers, so any number of arguments
    can be provided (not just event).
topic: String
    The name of the topic to publish to
event: Object
    An event to distribute to the topic listeners</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> hub.emit.apply(hub, <span class="hljs-built_in">arguments</span>);
					},
					subscribe: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(topic, listener)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-821">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-821">&#182;</a>
              </div>
              <p>summary:
    Subscribes to a topic on the pub/sub hub
topic: String
    The topic to subscribe to
listener: Function
    A function to call when a message is published to the given topic</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> hub.on.apply(hub, <span class="hljs-built_in">arguments</span>);
					}
				};
			});
		},
		<span class="hljs-string">'dojo/_base/xhr'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/_base/xhr'</span>, [
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'./sniff'</span>,
				<span class="hljs-string">'require'</span>,
				<span class="hljs-string">'../io-query'</span>,
				<span class="hljs-string">'../dom'</span>,
				<span class="hljs-string">'../dom-form'</span>,
				<span class="hljs-string">'./Deferred'</span>,
				<span class="hljs-string">'./config'</span>,
				<span class="hljs-string">'./json'</span>,
				<span class="hljs-string">'./lang'</span>,
				<span class="hljs-string">'./array'</span>,
				<span class="hljs-string">'../on'</span>,
				<span class="hljs-string">'../aspect'</span>,
				<span class="hljs-string">'../request/watch'</span>,
				<span class="hljs-string">'../request/xhr'</span>,
				<span class="hljs-string">'../request/util'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, has, require, ioq, dom, domForm, Deferred, config, json, lang, array, on, aspect, watch, _xhr, util)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-822">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-822">&#182;</a>
              </div>
              <p>module:
    dojo/_base/xhr</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             dojo._xhrObj = function(){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-823">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-823">&#182;</a>
              </div>
              <p>summary:
    does the work of portably generating a new XMLHTTPRequest object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				dojo._xhrObj = _xhr._create;
				var cfg = dojo.config;</pre></div></div>
            
        </li>
        
        
        <li id="section-824">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-824">&#182;</a>
              </div>
              <p>mix in io-query and dom-form</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo.objectToQuery = ioq.objectToQuery;
				dojo.queryToObject = ioq.queryToObject;
				dojo.fieldToObject = domForm.fieldToObject;
				dojo.formToObject = domForm.toObject;
				dojo.formToQuery = domForm.toQuery;
				dojo.formToJson = domForm.toJson;</pre></div></div>
            
        </li>
        
        
        <li id="section-825">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-825">&#182;</a>
              </div>
              <p>need to block async callbacks from snatching this thread as the result
of an async callback might call another sync XHR, this hangs khtml forever
must checked by watchInFlight()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo._blockAsync = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-826">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-826">&#182;</a>
              </div>
              <p>MOW: remove dojo._contentHandlers alias in 2.0</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> handlers = dojo._contentHandlers = dojo.contentHandlers = {
					<span class="hljs-string">'text'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(xhr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-827">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-827">&#182;</a>
              </div>
              <p>summary:
    A contentHandler which simply returns the plaintext response data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> xhr.responseText;
					},
					<span class="hljs-string">'json'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(xhr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-828">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-828">&#182;</a>
              </div>
              <p>summary:
    A contentHandler which returns a JavaScript object created from the response data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> json.fromJson(xhr.responseText || <span class="hljs-literal">null</span>);
					},
					<span class="hljs-string">'json-comment-filtered'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(xhr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-829">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-829">&#182;</a>
              </div>
              <p>summary:
    A contentHandler which expects comment-filtered JSON.
description:
    A contentHandler which expects comment-filtered JSON.
    the json-comment-filtered option was implemented to prevent
    “JavaScript Hijacking”, but it is less secure than standard JSON. Use
    standard JSON instead. JSON prefixing can be used to subvert hijacking.</p>
<pre><code>Will <span class="hljs-keyword">throw</span> a notice suggesting to use application/json mimetype, as
json-commenting can introduce security issues. To decrease the chances of hijacking,
use the standard `json` contentHandler, and prefix your <span class="hljs-string">"JSON"</span> <span class="hljs-keyword">with</span>: {}&amp;&amp;

use djConfig.useCommentedJson = <span class="hljs-literal">true</span> to turn off the notice
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!config.useCommentedJson) {
							console.warn(<span class="hljs-string">'Consider using the standard mimetype:application/json.'</span> + <span class="hljs-string">' json-commenting can introduce security issues. To'</span> + <span class="hljs-string">' decrease the chances of hijacking, use the standard the \'json\' handler and'</span> + <span class="hljs-string">' prefix your json with: {}&amp;&amp;\n'</span> + <span class="hljs-string">'Use djConfig.useCommentedJson=true to turn off this message.'</span>);
						}
						<span class="hljs-keyword">var</span> value = xhr.responseText;
						<span class="hljs-keyword">var</span> cStartIdx = value.indexOf(<span class="hljs-string">'/*'</span>);
						<span class="hljs-keyword">var</span> cEndIdx = value.lastIndexOf(<span class="hljs-string">'*/'</span>);
						<span class="hljs-keyword">if</span> (cStartIdx === -<span class="hljs-number">1</span> || cEndIdx === -<span class="hljs-number">1</span>) {
							<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'JSON was not comment filtered'</span>);
						}
						<span class="hljs-keyword">return</span> json.fromJson(value.substring(cStartIdx + <span class="hljs-number">2</span>, cEndIdx));
					},
					<span class="hljs-string">'javascript'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(xhr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-830">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-830">&#182;</a>
              </div>
              <p>summary:
    A contentHandler which evaluates the response data, expecting it to be valid JavaScript
FIXME: try Moz and IE specific eval variants?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> dojo.eval(xhr.responseText);
					},
					<span class="hljs-string">'xml'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(xhr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-831">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-831">&#182;</a>
              </div>
              <p>summary:
    A contentHandler returning an XML Document parsed from the response data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> result = xhr.responseXML;
						<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>)) {
							<span class="hljs-keyword">if</span> (!result || !result.documentElement) {</pre></div></div>
            
        </li>
        
        
        <li id="section-832">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-832">&#182;</a>
              </div>
              <p>WARNING: this branch used by the xml handling in dojo.io.iframe,
so be sure to test dojo.io.iframe if making changes below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">var</span> ms = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> {</span>
									<span class="hljs-keyword">return</span> <span class="hljs-string">'MSXML'</span> + n + <span class="hljs-string">'.DOMDocument'</span>;
								};
								<span class="hljs-keyword">var</span> dp = [
									<span class="hljs-string">'Microsoft.XMLDOM'</span>,
									ms(<span class="hljs-number">6</span>),
									ms(<span class="hljs-number">4</span>),
									ms(<span class="hljs-number">3</span>),
									ms(<span class="hljs-number">2</span>)
								];
								array.some(dp, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p)</span> {</span>
									<span class="hljs-keyword">try</span> {
										<span class="hljs-keyword">var</span> dom = <span class="hljs-keyword">new</span> ActiveXObject(p);
										dom.async = <span class="hljs-literal">false</span>;
										dom.loadXML(xhr.responseText);
										result = dom;
									} <span class="hljs-keyword">catch</span> (e) {
										<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
									}
									<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
								});
							}
						}
						<span class="hljs-keyword">return</span> result; <span class="hljs-comment">// DOMDocument</span>
					},
					<span class="hljs-string">'json-comment-optional'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(xhr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-833">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-833">&#182;</a>
              </div>
              <p>summary:
    A contentHandler which checks the presence of comment-filtered JSON and
    alternates between the <code>json</code> and <code>json-comment-filtered</code> contentHandlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (xhr.responseText &amp;&amp; <span class="hljs-regexp">/^[^{\[]*\/\*/</span>.test(xhr.responseText)) {
							<span class="hljs-keyword">return</span> handlers[<span class="hljs-string">'json-comment-filtered'</span>](xhr);
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">return</span> handlers.json(xhr);
						}
					}
				};
				<span class="hljs-comment">/*=====

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-834">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-834">&#182;</a>
              </div>
              <p>kwargs function parameter definitions.   Assigning to dojo namespace rather than making them local variables
because they are used by dojo/io modules too</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
             dojo.__IoArgs = declare(<span class="hljs-literal">null</span>, {</pre></div></div>
            
        </li>
        
        
        <li id="section-835">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-835">&#182;</a>
              </div>
              <p>url: String
    URL to server endpoint.
content: Object?
    Contains properties with string values. These
    properties will be serialized as name1=value2 and
    passed in the request.
timeout: Integer?
    Milliseconds to wait for the response. If this time
    passes, the then error callbacks are called.
form: DOMNode?
    DOM node for a form. Used to extract the form values
    and send to the server.
preventCache: Boolean?
    Default is false. If true, then a
    “dojo.preventCache” parameter is sent in the request
    with a value that changes with each request
    (timestamp). Useful only with GET-type requests.
handleAs: String?
    Acceptable values depend on the type of IO
    transport (see specific IO calls for more information).
rawBody: String?
    Sets the raw body for an HTTP request. If this is used, then the content
    property is ignored. This is mostly useful for HTTP methods that have
    a body to their requests, like PUT or POST. This property can be used instead
    of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.
ioPublish: Boolean?
    Set this explicitly to false to prevent publishing of topics related to
    IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
    will be published via dojo/topic.publish() for different phases of an IO operation.
    See dojo/main.__IoPublish for a list of topics that are published.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
             load: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(response, ioArgs)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-836">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-836">&#182;</a>
              </div>
              <p>summary:
    This function will be
    called on a successful HTTP response code.
ioArgs: dojo/main.__IoCallbackArgs
    Provides additional information about the request.
response: Object
    The response in the format as defined with handleAs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             },

             error: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(response, ioArgs)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-837">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-837">&#182;</a>
              </div>
              <p>summary:
    This function will
    be called when the request fails due to a network or server error, the url
    is invalid, etc. It will also be called if the load or handle callback throws an
    exception, unless djConfig.debugAtAllCosts is true.     This allows deployed applications
    to continue to run even when a logic error happens in the callback, while making
    it easier to troubleshoot while in debug mode.
ioArgs: dojo/main.__IoCallbackArgs
    Provides additional information about the request.
response: Object
    The response in the format as defined with handleAs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             },

             handle: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(loadOrError, response, ioArgs)</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-838">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-838">&#182;</a>
              </div>
              <p>summary:
    This function will
    be called at the end of every request, whether or not an error occurs.
loadOrError: String
    Provides a string that tells you whether this function
    was called because of success (load) or failure (error).
response: Object
    The response in the format as defined with handleAs.
ioArgs: dojo/main.__IoCallbackArgs
    Provides additional information about the request.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             }
             });

             dojo.__IoCallbackArgs = declare(<span class="hljs-literal">null</span>, {</pre></div></div>
            
        </li>
        
        
        <li id="section-839">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-839">&#182;</a>
              </div>
              <p>args: Object
    the original object argument to the IO call.
xhr: XMLHttpRequest
    For XMLHttpRequest calls only, the
    XMLHttpRequest object that was used for the
    request.
url: String
    The final URL used for the call. Many times it
    will be different than the original args.url
    value.
query: String
    For non-GET requests, the
    name1=value1&amp;name2=value2 parameters sent up in
    the request.
handleAs: String
    The final indicator on how the response will be
    handled.
id: String
    For dojo/io/script calls only, the internal
    script ID used for the request.
canDelete: Boolean
    For dojo/io/script calls only, indicates
    whether the script tag that represents the
    request can be deleted after callbacks have
    been called. Used internally to know when
    cleanup can happen on JSONP-type requests.
json: Object
    For dojo/io/script calls only: holds the JSON
    response for JSONP-type requests. Used
    internally to hold on to the JSON responses.
    You should not need to access it directly —
    the same object should be passed to the success
    callbacks directly.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             });

             dojo.__IoPublish = declare(<span class="hljs-literal">null</span>, {</pre></div></div>
            
        </li>
        
        
        <li id="section-840">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-840">&#182;</a>
              </div>
              <p>summary:
    This is a list of IO topics that can be published
    if djConfig.ioPublish is set to true. IO topics can be
    published for any Input/Output, network operation. So,
    dojo.xhr, dojo.io.script and dojo.io.iframe can all
    trigger these topics to be published.
start: String
    “/dojo/io/start” is sent when there are no outstanding IO
    requests, and a new IO request is started. No arguments
    are passed with this topic.
send: String
    “/dojo/io/send” is sent whenever a new IO request is started.
    It passes the dojo.Deferred for the request with the topic.
load: String
    “/dojo/io/load” is sent whenever an IO request has loaded
    successfully. It passes the response and the dojo.Deferred
    for the request with the topic.
error: String
    “/dojo/io/error” is sent whenever an IO request has errored.
    It passes the error and the dojo.Deferred
    for the request with the topic.
done: String
    “/dojo/io/done” is sent whenever an IO request has completed,
    either by loading or by erroring. It passes the error and
    the dojo.Deferred for the request with the topic.
stop: String
    “/dojo/io/stop” is sent when all outstanding IO requests have
    finished. No arguments are passed with this topic.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             });
             =====*/
				dojo._ioSetArgs = function (args, canceller, okHandler, errHandler) {</pre></div></div>
            
        </li>
        
        
        <li id="section-841">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-841">&#182;</a>
              </div>
              <p>summary:
    sets up the Deferred and ioArgs property on the Deferred so it
    can be used in an io call.
args:
    The args object passed into the public io call. Recognized properties on
    the args object are:
canceller:
    The canceller function used for the Deferred object. The function
    will receive one argument, the Deferred object that is related to the
    canceller.
okHandler:
    The first OK callback to be registered with Deferred. It has the opportunity
    to transform the OK response. It will receive one argument — the Deferred
    object returned from this function.
errHandler:
    The first error callback to be registered with Deferred. It has the opportunity
    to do cleanup on an error. It will receive two arguments: error (the
    Error object) and dfd, the Deferred object returned from this function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> ioArgs = {
						args: args,
						url: args.url
					};</pre></div></div>
            
        </li>
        
        
        <li id="section-842">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-842">&#182;</a>
              </div>
              <p>Get values from form if requested.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> formObject = <span class="hljs-literal">null</span>;
					<span class="hljs-keyword">if</span> (args.form) {
						<span class="hljs-keyword">var</span> form = dom.byId(args.form);</pre></div></div>
            
        </li>
        
        
        <li id="section-843">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-843">&#182;</a>
              </div>
              <p>IE requires going through getAttributeNode instead of just getAttribute in some form cases,
so use it for all. See #2844</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> actnNode = form.getAttributeNode(<span class="hljs-string">'action'</span>);
						ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : <span class="hljs-literal">null</span>);
						formObject = domForm.toObject(form);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-844">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-844">&#182;</a>
              </div>
              <p>set up the query params</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> miArgs = [{}];
					<span class="hljs-keyword">if</span> (formObject) {</pre></div></div>
            
        </li>
        
        
        <li id="section-845">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-845">&#182;</a>
              </div>
              <p>potentially over-ride url-provided params w/ form values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						miArgs.push(formObject);
					}
					<span class="hljs-keyword">if</span> (args.content) {</pre></div></div>
            
        </li>
        
        
        <li id="section-846">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-846">&#182;</a>
              </div>
              <p>stuff in content over-rides what’s set by form</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						miArgs.push(args.content);
					}
					<span class="hljs-keyword">if</span> (args.preventCache) {
						miArgs.push({
							<span class="hljs-string">'dojo.preventCache'</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
								.valueOf()
						});
					}
					ioArgs.query = ioq.objectToQuery(lang.mixin.apply(<span class="hljs-literal">null</span>, miArgs));</pre></div></div>
            
        </li>
        
        
        <li id="section-847">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-847">&#182;</a>
              </div>
              <p>.. and the real work of getting the deferred in order, etc.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					ioArgs.handleAs = args.handleAs || <span class="hljs-string">'text'</span>;
					<span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> Deferred(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dfd)</span> {</span>
						dfd.canceled = <span class="hljs-literal">true</span>;
						canceller &amp;&amp; canceller(dfd);
						<span class="hljs-keyword">var</span> err = dfd.ioArgs.error;
						<span class="hljs-keyword">if</span> (!err) {
							err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'request cancelled'</span>);
							err.dojoType = <span class="hljs-string">'cancel'</span>;
							dfd.ioArgs.error = err;
						}
						<span class="hljs-keyword">return</span> err;
					});
					d.addCallback(okHandler);</pre></div></div>
            
        </li>
        
        
        <li id="section-848">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-848">&#182;</a>
              </div>
              <p>Support specifying load, error and handle callback functions from the args.
For those callbacks, the “this” object will be the args object.
The callbacks will get the deferred result value as the
first argument and the ioArgs object as the second argument.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> ld = args.load;
					<span class="hljs-keyword">if</span> (ld &amp;&amp; lang.isFunction(ld)) {
						d.addCallback(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> {</span>
							<span class="hljs-keyword">return</span> ld.call(args, value, ioArgs);
						});
					}
					<span class="hljs-keyword">var</span> err = args.error;
					<span class="hljs-keyword">if</span> (err &amp;&amp; lang.isFunction(err)) {
						d.addErrback(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> {</span>
							<span class="hljs-keyword">return</span> err.call(args, value, ioArgs);
						});
					}
					<span class="hljs-keyword">var</span> handle = args.handle;
					<span class="hljs-keyword">if</span> (handle &amp;&amp; lang.isFunction(handle)) {
						d.addBoth(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> {</span>
							<span class="hljs-keyword">return</span> handle.call(args, value, ioArgs);
						});
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-849">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-849">&#182;</a>
              </div>
              <p>Attach error handler last (not including topic publishing)
to catch any errors that may have been generated from load
or handle functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					d.addErrback(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> {</span>
						<span class="hljs-keyword">return</span> errHandler(error, d);
					});</pre></div></div>
            
        </li>
        
        
        <li id="section-850">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-850">&#182;</a>
              </div>
              <p>Plug in topic publishing, if dojo.publish is loaded.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (cfg.ioPublish &amp;&amp; dojo.publish &amp;&amp; ioArgs.args.ioPublish !== <span class="hljs-literal">false</span>) {
						d.addCallbacks(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(res)</span> {</span>
							dojo.publish(<span class="hljs-string">'/dojo/io/load'</span>, [
								d,
								res
							]);
							<span class="hljs-keyword">return</span> res;
						}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(res)</span> {</span>
							dojo.publish(<span class="hljs-string">'/dojo/io/error'</span>, [
								d,
								res
							]);
							<span class="hljs-keyword">return</span> res;
						});
						d.addBoth(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(res)</span> {</span>
							dojo.publish(<span class="hljs-string">'/dojo/io/done'</span>, [
								d,
								res
							]);
							<span class="hljs-keyword">return</span> res;
						});
					}
					d.ioArgs = ioArgs;</pre></div></div>
            
        </li>
        
        
        <li id="section-851">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-851">&#182;</a>
              </div>
              <p>FIXME: need to wire up the xhr object’s abort method to something
analogous in the Deferred</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> d;
				};
				<span class="hljs-keyword">var</span> _deferredOk = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dfd)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-852">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-852">&#182;</a>
              </div>
              <p>summary:
    okHandler function for dojo._ioSetArgs call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
					<span class="hljs-keyword">return</span> ret === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : ret;
				};
				<span class="hljs-keyword">var</span> _deferError = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error, dfd)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-853">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-853">&#182;</a>
              </div>
              <p>summary:
    errHandler function for dojo._ioSetArgs call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!dfd.ioArgs.args.failOk) {
						console.error(error);
					}
					<span class="hljs-keyword">return</span> error;
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-854">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-854">&#182;</a>
              </div>
              <p>Use a separate count for knowing if we are starting/stopping io calls.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> _checkPubCount = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dfd)</span> {</span>
					<span class="hljs-keyword">if</span> (_pubCount &lt;= <span class="hljs-number">0</span>) {
						_pubCount = <span class="hljs-number">0</span>;
						<span class="hljs-keyword">if</span> (cfg.ioPublish &amp;&amp; dojo.publish &amp;&amp; (!dfd || dfd &amp;&amp; dfd.ioArgs.args.ioPublish !== <span class="hljs-literal">false</span>)) {
							dojo.publish(<span class="hljs-string">'/dojo/io/stop'</span>);
						}
					}
				};
				<span class="hljs-keyword">var</span> _pubCount = <span class="hljs-number">0</span>;
				aspect.after(watch, <span class="hljs-string">'_onAction'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					_pubCount -= <span class="hljs-number">1</span>;
				});
				aspect.after(watch, <span class="hljs-string">'_onInFlight'</span>, _checkPubCount);
				dojo._ioCancelAll = watch.cancelAll;
				<span class="hljs-comment">/*=====
             dojo._ioCancelAll = function(){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-855">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-855">&#182;</a>
              </div>
              <p>summary:
    Cancels all pending IO requests, regardless of IO type
    (xhr, script, iframe).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				dojo._ioNotifyStart = function (dfd) {</pre></div></div>
            
        </li>
        
        
        <li id="section-856">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-856">&#182;</a>
              </div>
              <p>summary:
    If dojo.publish is available, publish topics
    about the start of a request queue and/or the
    the beginning of request.</p>
<pre><code>Used by IO transports. An IO transport should
call <span class="hljs-keyword">this</span> method before making the network connection.
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (cfg.ioPublish &amp;&amp; dojo.publish &amp;&amp; dfd.ioArgs.args.ioPublish !== <span class="hljs-literal">false</span>) {
						<span class="hljs-keyword">if</span> (!_pubCount) {
							dojo.publish(<span class="hljs-string">'/dojo/io/start'</span>);
						}
						_pubCount += <span class="hljs-number">1</span>;
						dojo.publish(<span class="hljs-string">'/dojo/io/send'</span>, [dfd]);
					}
				};
				dojo._ioWatch = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dfd, validCheck, ioCheck, resHandle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-857">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-857">&#182;</a>
              </div>
              <p>summary:
    Watches the io request represented by dfd to see if it completes.
dfd: Deferred
    The Deferred object to watch.
validCheck: Function
    Function used to check if the IO request is still valid. Gets the dfd
    object as its only argument.
ioCheck: Function
    Function used to check if basic IO call worked. Gets the dfd
    object as its only argument.
resHandle: Function
    Function used to process response. Gets the dfd
    object as its only argument.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> args = dfd.ioArgs.options = dfd.ioArgs.args;
					lang.mixin(dfd, {
						response: dfd.ioArgs,
						isValid: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span>
							<span class="hljs-keyword">return</span> validCheck(dfd);
						},
						isReady: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span>
							<span class="hljs-keyword">return</span> ioCheck(dfd);
						},
						handleResponse: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span>
							<span class="hljs-keyword">return</span> resHandle(dfd);
						}
					});
					watch(dfd);
					_checkPubCount(dfd);
				};
				<span class="hljs-keyword">var</span> _defaultContentType = <span class="hljs-string">'application/x-www-form-urlencoded'</span>;
				dojo._ioAddQueryToUrl = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(ioArgs)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-858">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-858">&#182;</a>
              </div>
              <p>summary:
    Adds query params discovered by the io deferred construction to the URL.
    Only use this for operations which are fundamentally GET-type operations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (ioArgs.query.length) {
						ioArgs.url += (ioArgs.url.indexOf(<span class="hljs-string">'?'</span>) === -<span class="hljs-number">1</span> ? <span class="hljs-string">'?'</span> : <span class="hljs-string">'&amp;'</span>) + ioArgs.query;
						ioArgs.query = <span class="hljs-literal">null</span>;
					}
				};
				<span class="hljs-comment">/*=====
             dojo.__XhrArgs = declare(dojo.__IoArgs, {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-859">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-859">&#182;</a>
              </div>
              <p>summary:
    In addition to the properties listed for the dojo._IoArgs type,
    the following properties are allowed for dojo.xhr* methods.
handleAs: String?
    Acceptable values are: text (default), json, json-comment-optional,
    json-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code>
sync: Boolean?
    false is default. Indicates whether the request should
    be a synchronous (blocking) request.
headers: Object?
    Additional HTTP headers to send in the request.
failOk: Boolean?
    false is default. Indicates whether a request should be
    allowed to fail (and therefore no console error message in
    the event of a failure)
contentType: String|Boolean
    “application/x-www-form-urlencoded” is default. Set to false to
    prevent a Content-Type header from being sent, or to a string
    to send a different Content-Type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             });
             =====*/
				dojo.xhr = function (method, args, hasBody) {</pre></div></div>
            
        </li>
        
        
        <li id="section-860">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-860">&#182;</a>
              </div>
              <p>summary:
    Deprecated.   Use dojo/request instead.
description:
    Sends an HTTP request with the given method.
    See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
    for those HTTP methods. There are also methods for “raw” PUT and POST methods
    via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.
method:
    HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.
hasBody:
    If the request has an HTTP body, then pass true for hasBody.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> rDfd;</pre></div></div>
            
        </li>
        
        
        <li id="section-861">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-861">&#182;</a>
              </div>
              <p>Make the Deferred object for this xhr request.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> dfd = dojo._ioSetArgs(args, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dfd)</span> {</span>
						rDfd &amp;&amp; rDfd.cancel();
					}, _deferredOk, _deferError);
					<span class="hljs-keyword">var</span> ioArgs = dfd.ioArgs;</pre></div></div>
            
        </li>
        
        
        <li id="section-862">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-862">&#182;</a>
              </div>
              <p>Allow for specifying the HTTP body completely.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (<span class="hljs-string">'postData'</span> <span class="hljs-keyword">in</span> args) {
						ioArgs.query = args.postData;
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">'putData'</span> <span class="hljs-keyword">in</span> args) {
						ioArgs.query = args.putData;
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">'rawBody'</span> <span class="hljs-keyword">in</span> args) {
						ioArgs.query = args.rawBody;
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span> &amp;&amp; !hasBody || <span class="hljs-string">'POST|PUT'</span>.indexOf(method.toUpperCase()) === -<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-863">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-863">&#182;</a>
              </div>
              <p>Check for hasBody being passed. If no hasBody,
then only append query string if not a POST or PUT request.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						dojo._ioAddQueryToUrl(ioArgs);
					}
					<span class="hljs-keyword">var</span> options = {
						method: method,
						handleAs: <span class="hljs-string">'text'</span>,
						timeout: args.timeout,
						withCredentials: args.withCredentials,
						ioArgs: ioArgs
					};
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args.headers !== <span class="hljs-string">'undefined'</span>) {
						options.headers = args.headers;
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args.contentType !== <span class="hljs-string">'undefined'</span>) {
						<span class="hljs-keyword">if</span> (!options.headers) {
							options.headers = {};
						}
						options.headers[<span class="hljs-string">'Content-Type'</span>] = args.contentType;
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ioArgs.query !== <span class="hljs-string">'undefined'</span>) {
						options.data = ioArgs.query;
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args.sync !== <span class="hljs-string">'undefined'</span>) {
						options.sync = args.sync;
					}
					dojo._ioNotifyStart(dfd);
					<span class="hljs-keyword">try</span> {
						rDfd = _xhr(ioArgs.url, options, <span class="hljs-literal">true</span>);
					} <span class="hljs-keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-864">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-864">&#182;</a>
              </div>
              <p>If XHR creation fails, dojo/request/xhr throws
When this happens, cancel the deferred</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						dfd.cancel();
						<span class="hljs-keyword">return</span> dfd;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-865">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-865">&#182;</a>
              </div>
              <p>sync ioArgs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					dfd.ioArgs.xhr = rDfd.response.xhr;
					rDfd.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						dfd.resolve(dfd);
					})
						.otherwise(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> {</span>
							ioArgs.error = error;
							<span class="hljs-keyword">if</span> (error.response) {
								error.status = error.response.status;
								error.responseText = error.response.text;
								error.xhr = error.response.xhr;
							}
							dfd.reject(error);
						});
					<span class="hljs-keyword">return</span> dfd; <span class="hljs-comment">// dojo/_base/Deferred</span>
				};
				dojo.xhrGet = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(args)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-866">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-866">&#182;</a>
              </div>
              <p>summary:
    Sends an HTTP GET request to the server.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> dojo.xhr(<span class="hljs-string">'GET'</span>, args); <span class="hljs-comment">// dojo/_base/Deferred</span>
				};
				dojo.rawXhrPost = dojo.xhrPost = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(args)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-867">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-867">&#182;</a>
              </div>
              <p>summary:
    Sends an HTTP POST request to the server. In addition to the properties
    listed for the dojo.__XhrArgs type, the following property is allowed:
postData:
    String. Send raw data in the body of the POST request.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> dojo.xhr(<span class="hljs-string">'POST'</span>, args, <span class="hljs-literal">true</span>); <span class="hljs-comment">// dojo/_base/Deferred</span>
				};
				dojo.rawXhrPut = dojo.xhrPut = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(args)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-868">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-868">&#182;</a>
              </div>
              <p>summary:
    Sends an HTTP PUT request to the server. In addition to the properties
    listed for the dojo.__XhrArgs type, the following property is allowed:
putData:
    String. Send raw data in the body of the PUT request.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> dojo.xhr(<span class="hljs-string">'PUT'</span>, args, <span class="hljs-literal">true</span>); <span class="hljs-comment">// dojo/_base/Deferred</span>
				};
				dojo.xhrDelete = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(args)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-869">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-869">&#182;</a>
              </div>
              <p>summary:
    Sends an HTTP DELETE request to the server.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> dojo.xhr(<span class="hljs-string">'DELETE'</span>, args); <span class="hljs-comment">// dojo/_base/Deferred</span>
				};
				<span class="hljs-comment">/*
             dojo.wrapForm = function(formNode){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-870">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-870">&#182;</a>
              </div>
              <p>summary:
    A replacement for FormBind, but not implemented yet.</p>

            </div>
            
        </li>
        
        
        <li id="section-871">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-871">&#182;</a>
              </div>
              <p>FIXME: need to think harder about what extensions to this we might
want. What should we allow folks to do w/ this? What events to
set/send?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             throw new Error("dojo.wrapForm not yet implemented");
             }
             */
				dojo._isDocumentOk = function (x) {
					return util.checkStatus(x.status);
				};
				dojo._getText = function (url) {
					var result;
					dojo.xhrGet({
						url: url,
						sync: true,
						load: function (text) {
							result = text;
						}
					});
					return result;
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-872">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-872">&#182;</a>
              </div>
              <p>Add aliases for static functions to dojo.xhr since dojo.xhr is what’s returned from this module</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				lang.mixin(dojo.xhr, {
					_xhrObj: dojo._xhrObj,
					fieldToObject: domForm.fieldToObject,
					formToObject: domForm.toObject,
					objectToQuery: ioq.objectToQuery,
					formToQuery: domForm.toQuery,
					formToJson: domForm.toJson,
					queryToObject: ioq.queryToObject,
					contentHandlers: handlers,
					_ioSetArgs: dojo._ioSetArgs,
					_ioCancelAll: dojo._ioCancelAll,
					_ioNotifyStart: dojo._ioNotifyStart,
					_ioWatch: dojo._ioWatch,
					_ioAddQueryToUrl: dojo._ioAddQueryToUrl,
					_isDocumentOk: dojo._isDocumentOk,
					_getText: dojo._getText,
					get: dojo.xhrGet,
					post: dojo.xhrPost,
					put: dojo.xhrPut,
					del: dojo.xhrDelete
				});
				<span class="hljs-keyword">return</span> dojo.xhr;
			});
		},
		<span class="hljs-string">'dojo/loadInit'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/loadInit'</span>, [<span class="hljs-string">'./_base/loader'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(loader)</span> {</span>
				<span class="hljs-keyword">return</span> {
					dynamic: <span class="hljs-number">0</span>,
					normalize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> {</span>
						<span class="hljs-keyword">return</span> id;
					},
					load: loader.loadInit
				};
			});
		},
		<span class="hljs-string">'dojo/_base/unload'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'./lang'</span>,
				<span class="hljs-string">'../on'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, lang, on)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-873">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-873">&#182;</a>
              </div>
              <p>module:
    dojo/unload</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> win = window;
				<span class="hljs-keyword">var</span> unload = {
					addOnWindowUnload: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj, functionName)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-874">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-874">&#182;</a>
              </div>
              <p>summary:
    registers a function to be triggered when window.onunload
    fires.
description:
    The first time that addOnWindowUnload is called Dojo
    will register a page listener to trigger your unload
    handler with. Note that registering these handlers may
    destroy “fastback” page caching in browsers that support
    it. Be careful trying to modify the DOM or access
    JavaScript properties during this phase of page unloading:
    they may not always be available. Consider
    addOnUnload() if you need to modify the DOM or do
    heavy JavaScript work since it fires at the equivalent of
    the page’s “onbeforeunload” event.
example:
|    unload.addOnWindowUnload(functionPointer)
|    unload.addOnWindowUnload(object, “functionName”);
|    unload.addOnWindowUnload(object, function(){ /<em> … </em>/});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!dojo.windowUnloaded) {
							on(win, <span class="hljs-string">'unload'</span>, dojo.windowUnloaded = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>});
						}
						on(win, <span class="hljs-string">'unload'</span>, lang.hitch(obj, functionName));
					},
					addOnUnload: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj, functionName)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-875">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-875">&#182;</a>
              </div>
              <p>summary:
    registers a function to be triggered when the page unloads.
description:
    The first time that addOnUnload is called Dojo will
    register a page listener to trigger your unload handler
    with.</p>
<pre><code>In a browser environment, the functions will be triggered
during the window.onbeforeunload event. Be careful of doing
too much work <span class="hljs-keyword">in</span> an unload handler. onbeforeunload can be
triggered <span class="hljs-keyword">if</span> a link to download a file is clicked, or <span class="hljs-keyword">if</span>
the link is a javascript: link. In these cases, the
onbeforeunload event fires, but the document is not
actually destroyed. So be careful about doing destructive
operations <span class="hljs-keyword">in</span> a dojo.addOnUnload callback.

Further note that calling dojo.addOnUnload will prevent
browsers from using a <span class="hljs-string">"fast back"</span> cache to make page
loading via back button instantaneous.
</code></pre><p>example:
|    dojo.addOnUnload(functionPointer)
|    dojo.addOnUnload(object, “functionName”)
|    dojo.addOnUnload(object, function(){ /<em> … </em>/});</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						on(win, <span class="hljs-string">'beforeunload'</span>, lang.hitch(obj, functionName));
					}
				};
				dojo.addOnWindowUnload = unload.addOnWindowUnload;
				dojo.addOnUnload = unload.addOnUnload;
				<span class="hljs-keyword">return</span> unload;
			});
		},
		<span class="hljs-string">'dojo/Deferred'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./has'</span>,
				<span class="hljs-string">'./_base/lang'</span>,
				<span class="hljs-string">'./errors/CancelError'</span>,
				<span class="hljs-string">'./promise/Promise'</span>,
				<span class="hljs-string">'./promise/instrumentation'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(has, lang, CancelError, Promise, instrumentation)</span> {</span>
<span class="hljs-pi">				'use strict'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-876">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-876">&#182;</a>
              </div>
              <p>module:
    dojo/Deferred</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> PROGRESS = <span class="hljs-number">0</span>,
					RESOLVED = <span class="hljs-number">1</span>,
					REJECTED = <span class="hljs-number">2</span>;
				<span class="hljs-keyword">var</span> FULFILLED_ERROR_MESSAGE = <span class="hljs-string">'This deferred has already been fulfilled.'</span>;
				<span class="hljs-keyword">var</span> freezeObject = <span class="hljs-built_in">Object</span>.freeze || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>};
				<span class="hljs-keyword">var</span> signalWaiting = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(waiting, type, result, rejection, deferred)</span> {</span>
					<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
						<span class="hljs-keyword">if</span> (type === REJECTED &amp;&amp; Deferred.instrumentRejected &amp;&amp; waiting.length === <span class="hljs-number">0</span>) {
							Deferred.instrumentRejected(result, <span class="hljs-literal">false</span>, rejection, deferred);
						}
					}
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; waiting.length; i++) {
						signalListener(waiting[i], type, result, rejection);
					}
				};
				<span class="hljs-keyword">var</span> signalListener = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(listener, type, result, rejection)</span> {</span>
					<span class="hljs-keyword">var</span> func = listener[type];
					<span class="hljs-keyword">var</span> deferred = listener.deferred;
					<span class="hljs-keyword">if</span> (func) {
						<span class="hljs-keyword">try</span> {
							<span class="hljs-keyword">var</span> newResult = func(result);
							<span class="hljs-keyword">if</span> (type === PROGRESS) {
								<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newResult !== <span class="hljs-string">'undefined'</span>) {
									signalDeferred(deferred, type, newResult);
								}
							} <span class="hljs-keyword">else</span> {
								<span class="hljs-keyword">if</span> (newResult &amp;&amp; <span class="hljs-keyword">typeof</span> newResult.then === <span class="hljs-string">'function'</span>) {
									listener.cancel = newResult.cancel;
									newResult.then(makeDeferredSignaler(deferred, RESOLVED), makeDeferredSignaler(deferred, REJECTED), makeDeferredSignaler(deferred, PROGRESS));
									<span class="hljs-keyword">return</span>;
								}
								signalDeferred(deferred, RESOLVED, newResult);
							}
						} <span class="hljs-keyword">catch</span> (error) {
							signalDeferred(deferred, REJECTED, error);
						}
					} <span class="hljs-keyword">else</span> {
						signalDeferred(deferred, type, result);
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
						<span class="hljs-keyword">if</span> (type === REJECTED &amp;&amp; Deferred.instrumentRejected) {
							Deferred.instrumentRejected(result, !! func, rejection, deferred.promise);
						}
					}
				};
				<span class="hljs-keyword">var</span> makeDeferredSignaler = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(deferred, type)</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> {</span>
						signalDeferred(deferred, type, value);
					};
				};
				<span class="hljs-keyword">var</span> signalDeferred = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(deferred, type, result)</span> {</span>
					<span class="hljs-keyword">if</span> (!deferred.isCanceled()) {
						<span class="hljs-keyword">switch</span> (type) {
						<span class="hljs-keyword">case</span> PROGRESS:
							deferred.progress(result);
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> RESOLVED:
							deferred.resolve(result);
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> REJECTED:
							deferred.reject(result);
							<span class="hljs-keyword">break</span>;
						}
					}
				};
				<span class="hljs-keyword">var</span> Deferred = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(canceler)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-877">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-877">&#182;</a>
              </div>
              <p>summary:
    Creates a new deferred. This API is preferred over
    <code>dojo/_base/Deferred</code>.
description:
    Creates a new deferred, as an abstraction over (primarily)
    asynchronous operations. The deferred is the private interface
    that should not be returned to calling code. That’s what the
    <code>promise</code> is for. See <code>dojo/promise/Promise</code>.
canceler: Function?
    Will be invoked if the deferred is canceled. The canceler
    receives the reason the deferred was canceled as its argument.
    The deferred is rejected with its return value, or a new
    <code>dojo/errors/CancelError</code> instance.
promise: dojo/promise/Promise
    The public promise object that clients can add callbacks to. </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">this</span>.promise = <span class="hljs-keyword">new</span> Promise();
					<span class="hljs-keyword">var</span> deferred = <span class="hljs-keyword">this</span>;
					<span class="hljs-keyword">var</span> fulfilled, result, rejection;
					<span class="hljs-keyword">var</span> canceled = <span class="hljs-literal">false</span>;
					<span class="hljs-keyword">var</span> waiting = [];
					<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">Error</span>.captureStackTrace) {
						<span class="hljs-built_in">Error</span>.captureStackTrace(deferred, Deferred);
						<span class="hljs-built_in">Error</span>.captureStackTrace(promise, Deferred);
					}
					<span class="hljs-keyword">this</span>.isResolved = promise.isResolved = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-878">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-878">&#182;</a>
              </div>
              <p>summary:
    Checks whether the deferred has been resolved.
returns: Boolean</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> fulfilled === RESOLVED;
					};
					<span class="hljs-keyword">this</span>.isRejected = promise.isRejected = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-879">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-879">&#182;</a>
              </div>
              <p>summary:
    Checks whether the deferred has been rejected.
returns: Boolean</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> fulfilled === REJECTED;
					};
					<span class="hljs-keyword">this</span>.isFulfilled = promise.isFulfilled = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-880">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-880">&#182;</a>
              </div>
              <p>summary:
    Checks whether the deferred has been resolved or rejected.
returns: Boolean</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> !!fulfilled;
					};
					<span class="hljs-keyword">this</span>.isCanceled = promise.isCanceled = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-881">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-881">&#182;</a>
              </div>
              <p>summary:
    Checks whether the deferred has been canceled.
returns: Boolean</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> canceled;
					};
					<span class="hljs-keyword">this</span>.progress = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(update, strict)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-882">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-882">&#182;</a>
              </div>
              <p>summary:
    Emit a progress update on the deferred.
description:
    Emit a progress update on the deferred. Progress updates
    can be used to communicate updates about the asynchronous
    operation before it has finished.
update: any
    The progress update. Passed to progbacks.
strict: Boolean?
    If strict, will throw an error if the deferred has already
    been fulfilled and consequently no progress can be emitted.
returns: dojo/promise/Promise
    Returns the original promise for the deferred.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!fulfilled) {
							signalWaiting(waiting, PROGRESS, update, <span class="hljs-literal">null</span>, deferred);
							<span class="hljs-keyword">return</span> promise;
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strict === <span class="hljs-literal">true</span>) {
							<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(FULFILLED_ERROR_MESSAGE);
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">return</span> promise;
						}
					};
					<span class="hljs-keyword">this</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value, strict)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-883">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-883">&#182;</a>
              </div>
              <p>summary:
    Resolve the deferred.
description:
    Resolve the deferred, putting it in a success state.
value: any
    The result of the deferred. Passed to callbacks.
strict: Boolean?
    If strict, will throw an error if the deferred has already
    been fulfilled and consequently cannot be resolved.
returns: dojo/promise/Promise
    Returns the original promise for the deferred.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!fulfilled) {</pre></div></div>
            
        </li>
        
        
        <li id="section-884">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-884">&#182;</a>
              </div>
              <p>Set fulfilled, store value. After signaling waiting listeners unset
waiting.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							signalWaiting(waiting, fulfilled = RESOLVED, result = value, <span class="hljs-literal">null</span>, deferred);
							waiting = <span class="hljs-literal">null</span>;
							<span class="hljs-keyword">return</span> promise;
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strict === <span class="hljs-literal">true</span>) {
							<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(FULFILLED_ERROR_MESSAGE);
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">return</span> promise;
						}
					};
					<span class="hljs-keyword">var</span> reject = <span class="hljs-keyword">this</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error, strict)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-885">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-885">&#182;</a>
              </div>
              <p>summary:
    Reject the deferred.
description:
    Reject the deferred, putting it in an error state.
error: any
    The error result of the deferred. Passed to errbacks.
strict: Boolean?
    If strict, will throw an error if the deferred has already
    been fulfilled and consequently cannot be rejected.
returns: dojo/promise/Promise
    Returns the original promise for the deferred.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!fulfilled) {
							<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">Error</span>.captureStackTrace) {
								<span class="hljs-built_in">Error</span>.captureStackTrace(rejection = {}, reject);
							}
							signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
							waiting = <span class="hljs-literal">null</span>;
							<span class="hljs-keyword">return</span> promise;
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strict === <span class="hljs-literal">true</span>) {
							<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(FULFILLED_ERROR_MESSAGE);
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">return</span> promise;
						}
					};
					<span class="hljs-keyword">this</span>.then = promise.then = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback, errback, progback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-886">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-886">&#182;</a>
              </div>
              <p>summary:
    Add new callbacks to the deferred.
description:
    Add new callbacks to the deferred. Callbacks can be added
    before or after the deferred is fulfilled.
callback: Function?
    Callback to be invoked when the promise is resolved.
    Receives the resolution value.
errback: Function?
    Callback to be invoked when the promise is rejected.
    Receives the rejection error.
progback: Function?
    Callback to be invoked when the promise emits a progress
    update. Receives the progress update.
returns: dojo/promise/Promise
    Returns a new promise for the result of the callback(s).
    This can be used for chaining many asynchronous operations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> listener = [
							progback,
							callback,
							errback
						];</pre></div></div>
            
        </li>
        
        
        <li id="section-887">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-887">&#182;</a>
              </div>
              <p>Ensure we cancel the promise we’re waiting for, or if callback/errback
have returned a promise, cancel that one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						listener.cancel = promise.cancel;
						listener.deferred = <span class="hljs-keyword">new</span> Deferred(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(reason)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-888">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-888">&#182;</a>
              </div>
              <p>Check whether cancel is really available, returned promises are not
required to expose <code>cancel</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> listener.cancel &amp;&amp; listener.cancel(reason);
						});
						<span class="hljs-keyword">if</span> (fulfilled &amp;&amp; !waiting) {
							signalListener(listener, fulfilled, result, rejection);
						} <span class="hljs-keyword">else</span> {
							waiting.push(listener);
						}
						<span class="hljs-keyword">return</span> listener.deferred.promise;
					};
					<span class="hljs-keyword">this</span>.cancel = promise.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(reason, strict)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-889">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-889">&#182;</a>
              </div>
              <p>summary:
    Inform the deferred it may cancel its asynchronous operation.
description:
    Inform the deferred it may cancel its asynchronous operation.
    The deferred’s (optional) canceler is invoked and the
    deferred will be left in a rejected state. Can affect other
    promises that originate with the same deferred.
reason: any
    A message that may be sent to the deferred’s canceler,
    explaining why it’s being canceled.
strict: Boolean?
    If strict, will throw an error if the deferred has already
    been fulfilled and consequently cannot be canceled.
returns: any
    Returns the rejection reason if the deferred was canceled
    normally.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!fulfilled) {</pre></div></div>
            
        </li>
        
        
        <li id="section-890">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-890">&#182;</a>
              </div>
              <p>Cancel can be called even after the deferred is fulfilled</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (canceler) {
								<span class="hljs-keyword">var</span> returnedReason = canceler(reason);
								reason = <span class="hljs-keyword">typeof</span> returnedReason === <span class="hljs-string">'undefined'</span> ? reason : returnedReason;
							}
							canceled = <span class="hljs-literal">true</span>;
							<span class="hljs-keyword">if</span> (!fulfilled) {</pre></div></div>
            
        </li>
        
        
        <li id="section-891">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-891">&#182;</a>
              </div>
              <p>Allow canceler to provide its own reason, but fall back to a CancelError</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reason === <span class="hljs-string">'undefined'</span>) {
									reason = <span class="hljs-keyword">new</span> CancelError();
								}
								reject(reason);
								<span class="hljs-keyword">return</span> reason;
							} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fulfilled === REJECTED &amp;&amp; result === reason) {
								<span class="hljs-keyword">return</span> reason;
							}
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strict === <span class="hljs-literal">true</span>) {
							<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(FULFILLED_ERROR_MESSAGE);
						}
					};
					freezeObject(promise);
				};
				Deferred.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-892">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-892">&#182;</a>
              </div>
              <p>returns: String
    Returns <code>[object Deferred]</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-string">'[object Deferred]'</span>;
				};
				<span class="hljs-keyword">if</span> (instrumentation) {
					instrumentation(Deferred);
				}
				<span class="hljs-keyword">return</span> Deferred;
			});
		},
		<span class="hljs-string">'dojo/_base/NodeList'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/_base/NodeList'</span>, [
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'../query'</span>,
				<span class="hljs-string">'./array'</span>,
				<span class="hljs-string">'./html'</span>,
				<span class="hljs-string">'../NodeList-dom'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, query, array)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-893">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-893">&#182;</a>
              </div>
              <p>module:
    dojo/_base/NodeList</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             return {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-894">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-894">&#182;</a>
              </div>
              <p>summary:
    This module extends dojo/NodeList with the legacy connect(), coords(),
    blur(), focus(), change(), click(), error(), keydown(), keypress(),
    keyup(), load(), mousedown(), mouseenter(), mouseleave(), mousemove(),
    mouseout(), mouseover(), mouseup(), and submit() methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				var NodeList = query.NodeList,
					nlp = NodeList.prototype;
				nlp.connect = NodeList._adaptAsForEach(function () {</pre></div></div>
            
        </li>
        
        
        <li id="section-895">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-895">&#182;</a>
              </div>
              <p>don’t bind early to dojo.connect since we no longer explicitly depend on it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> dojo.connect.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
				});
				<span class="hljs-comment">/*=====
             nlp.connect = function(methodName, objOrFunc, funcName){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-896">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-896">&#182;</a>
              </div>
              <p>summary:
    Attach event handlers to every item of the NodeList. Uses dojo.connect()
    so event properties are normalized.</p>
<pre><code>Application must manually <span class="hljs-built_in">require</span>() <span class="hljs-string">"dojo/_base/connect"</span> before using <span class="hljs-keyword">this</span> method.
</code></pre><p>methodName: String
    the name of the method to attach to. For DOM events, this should be
    the lower-case name of the event
objOrFunc: Object|Function|String
    if 2 arguments are passed (methodName, objOrFunc), objOrFunc should
    reference a function or be the name of the function in the global
    namespace to attach. If 3 arguments are provided
    (methodName, objOrFunc, funcName), objOrFunc must be the scope to
    locate the bound function in
funcName: String?
    optional. A string naming the function in objOrFunc to bind to the
    event. May also be a function reference.
example:
    add an onclick handler to every button on the page
    |    query(“div:nth-child(odd)”).connect(“onclick”, function(e){
    |        console.log(“clicked!”);
    |    });
example:
    attach foo.bar() to every odd div’s onmouseover
    |    query(“div:nth-child(odd)”).connect(“onmouseover”, foo, “bar”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
             return null;	// NodeList
             };
             =====*/
				nlp.coords = NodeList._adaptAsMap(dojo.coords);
				/*=====
             nlp.coords = function(){</pre></div></div>
            
        </li>
        
        
        <li id="section-897">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-897">&#182;</a>
              </div>
              <p>summary:
    Deprecated: Use position() for border-box x/y/w/h
    or marginBox() for margin-box w/h/l/t.
    Returns the box objects of all elements in a node list as
    an Array (<em>not</em> a NodeList). Acts like <code>domGeom.coords</code>, though assumes
    the node passed is each node in this list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
             return []; // Array
             };
             =====*/
				NodeList.events = [
					'blur',
					'focus',
					'change',
					'click',
					'error',
					'keydown',
					'keypress',
					'keyup',
					'load',
					'mousedown',
					'mouseenter',
					'mouseleave',
					'mousemove',
					'mouseout',
					'mouseover',
					'mouseup',
					'submit'
				];</pre></div></div>
            
        </li>
        
        
        <li id="section-898">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-898">&#182;</a>
              </div>
              <p>FIXME: pseudo-doc the above automatically generated on-event functions
syntactic sugar for DOM events</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				array.forEach(NodeList.events, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> {</span>
					<span class="hljs-keyword">var</span> _oe = <span class="hljs-string">'on'</span> + evt;
					nlp[_oe] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.connect(_oe, a, b);
					}; <span class="hljs-comment">// FIXME: should these events trigger publishes?</span>
					<span class="hljs-comment">/*
                     return (a ? this.connect(_oe, a, b) :
                     this.forEach(function(n){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-899">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-899">&#182;</a>
              </div>
              <p>FIXME:
    listeners get buried by
    addEventListener and can’t be dug back
    out to be triggered externally.
see:
    <a href="http://developer.mozilla.org/en/docs/DOM:element">http://developer.mozilla.org/en/docs/DOM:element</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
                     console.log(n, evt, _oe);</pre></div></div>
            
        </li>
        
        
        <li id="section-900">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-900">&#182;</a>
              </div>
              <p>FIXME: need synthetic event support!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                     <span class="hljs-keyword">var</span> _e = { target: n, faux: <span class="hljs-literal">true</span>, type: evt };</pre></div></div>
            
        </li>
        
        
        <li id="section-901">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-901">&#182;</a>
              </div>
              <p>dojo._event_listener._synthesizeEvent({}, { target: n, faux: true, type: evt });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                     try{ n[evt](_e); }catch(e){ console.log(e); }
                     try{ n[_oe](_e); }catch(e){ console.log(e); }
                     })
                     );
                     */
				});
				dojo.NodeList = NodeList;
				return NodeList;
			});
		},
		'dojo/_base/Color': function () {
			define([
				'./kernel',
				'./lang',
				'./array',
				'./config'
			], function (dojo, lang, ArrayUtil, config) {
				var Color = dojo.Color = function (color) {</pre></div></div>
            
        </li>
        
        
        <li id="section-902">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-902">&#182;</a>
              </div>
              <p>summary:
    Takes a named string, hex string, array of rgb or rgba values,
    an object with r, g, b, and a properties, or another <code>Color</code> object
    and creates a new Color instance to work from.</p>
<p>example:
    Work with a Color instance:
 | var c = new Color();
 | c.setColor([0,0,0]); // black
 | var hex = c.toHex(); // #000000</p>
<p>example:
    Work with a node’s color:
 | var color = dojo.style(“someNode”, “backgroundColor”);
 | var n = new Color(color);
 | // adjust the color some
 | n.r *= .5;
 | console.log(n.toString()); // rgb(128, 255, 255);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (color) {
						<span class="hljs-keyword">this</span>.setColor(color);
					}
				};</pre></div></div>
            
        </li>
        
        
        <li id="section-903">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-903">&#182;</a>
              </div>
              <p>FIXME:
there’s got to be a more space-efficient way to encode or discover
these!! Use hex?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				Color.named = {
					<span class="hljs-string">'black'</span>: [
						<span class="hljs-number">0</span>,
						<span class="hljs-number">0</span>,
						<span class="hljs-number">0</span>
					],
					<span class="hljs-string">'silver'</span>: [
						<span class="hljs-number">192</span>,
						<span class="hljs-number">192</span>,
						<span class="hljs-number">192</span>
					],
					<span class="hljs-string">'gray'</span>: [
						<span class="hljs-number">128</span>,
						<span class="hljs-number">128</span>,
						<span class="hljs-number">128</span>
					],
					<span class="hljs-string">'white'</span>: [
						<span class="hljs-number">255</span>,
						<span class="hljs-number">255</span>,
						<span class="hljs-number">255</span>
					],
					<span class="hljs-string">'maroon'</span>: [
						<span class="hljs-number">128</span>,
						<span class="hljs-number">0</span>,
						<span class="hljs-number">0</span>
					],
					<span class="hljs-string">'red'</span>: [
						<span class="hljs-number">255</span>,
						<span class="hljs-number">0</span>,
						<span class="hljs-number">0</span>
					],
					<span class="hljs-string">'purple'</span>: [
						<span class="hljs-number">128</span>,
						<span class="hljs-number">0</span>,
						<span class="hljs-number">128</span>
					],
					<span class="hljs-string">'fuchsia'</span>: [
						<span class="hljs-number">255</span>,
						<span class="hljs-number">0</span>,
						<span class="hljs-number">255</span>
					],
					<span class="hljs-string">'green'</span>: [
						<span class="hljs-number">0</span>,
						<span class="hljs-number">128</span>,
						<span class="hljs-number">0</span>
					],
					<span class="hljs-string">'lime'</span>: [
						<span class="hljs-number">0</span>,
						<span class="hljs-number">255</span>,
						<span class="hljs-number">0</span>
					],
					<span class="hljs-string">'olive'</span>: [
						<span class="hljs-number">128</span>,
						<span class="hljs-number">128</span>,
						<span class="hljs-number">0</span>
					],
					<span class="hljs-string">'yellow'</span>: [
						<span class="hljs-number">255</span>,
						<span class="hljs-number">255</span>,
						<span class="hljs-number">0</span>
					],
					<span class="hljs-string">'navy'</span>: [
						<span class="hljs-number">0</span>,
						<span class="hljs-number">0</span>,
						<span class="hljs-number">128</span>
					],
					<span class="hljs-string">'blue'</span>: [
						<span class="hljs-number">0</span>,
						<span class="hljs-number">0</span>,
						<span class="hljs-number">255</span>
					],
					<span class="hljs-string">'teal'</span>: [
						<span class="hljs-number">0</span>,
						<span class="hljs-number">128</span>,
						<span class="hljs-number">128</span>
					],
					<span class="hljs-string">'aqua'</span>: [
						<span class="hljs-number">0</span>,
						<span class="hljs-number">255</span>,
						<span class="hljs-number">255</span>
					],
					<span class="hljs-string">'transparent'</span>: config.transparentColor || [
						<span class="hljs-number">0</span>,
						<span class="hljs-number">0</span>,
						<span class="hljs-number">0</span>,
						<span class="hljs-number">0</span>
					]
				};
				lang.extend(Color, {
					r: <span class="hljs-number">255</span>,
					g: <span class="hljs-number">255</span>,
					b: <span class="hljs-number">255</span>,
					a: <span class="hljs-number">1</span>,
					_set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(r, g, b, a)</span> {</span>
						<span class="hljs-keyword">var</span> t = <span class="hljs-keyword">this</span>;
						t.r = r;
						t.g = g;
						t.b = b;
						t.a = a;
					},
					setColor: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(color)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-904">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-904">&#182;</a>
              </div>
              <p>summary:
    Takes a named string, hex string, array of rgb or rgba values,
    an object with r, g, b, and a properties, or another <code>Color</code> object
    and sets this color instance to that value.</p>
<p>example:
|    var c = new Color(); // no color
|    c.setColor(“#ededed”); // greyish</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (lang.isString(color)) {
							Color.fromString(color, <span class="hljs-keyword">this</span>);
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lang.isArray(color)) {
							Color.fromArray(color, <span class="hljs-keyword">this</span>);
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">this</span>._set(color.r, color.g, color.b, color.a);
							<span class="hljs-keyword">if</span> (!(color <span class="hljs-keyword">instanceof</span> Color)) {
								<span class="hljs-keyword">this</span>.sanitize();
							}
						}
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// Color</span>
					},
					sanitize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-905">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-905">&#182;</a>
              </div>
              <p>summary:
    Ensures the object has correct attributes
description:
    the default implementation does nothing, include dojo.colors to
    augment it with real checks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// Color</span>
					},
					toRgb: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-906">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-906">&#182;</a>
              </div>
              <p>summary:
    Returns 3 component array of rgb values
example:
|    var c = new Color(“#000000”);
|    console.log(c.toRgb()); // [0,0,0]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> t = <span class="hljs-keyword">this</span>;
						<span class="hljs-keyword">return</span> [
							t.r,
							t.g,
							t.b
						]; <span class="hljs-comment">// Array</span>
					},
					toRgba: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-907">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-907">&#182;</a>
              </div>
              <p>summary:
    Returns a 4 component array of rgba values from the color
    represented by this object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> t = <span class="hljs-keyword">this</span>;
						<span class="hljs-keyword">return</span> [
							t.r,
							t.g,
							t.b,
							t.a
						]; <span class="hljs-comment">// Array</span>
					},
					toHex: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-908">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-908">&#182;</a>
              </div>
              <p>summary:
    Returns a CSS color string in hexadecimal representation
example:
|    console.log(new Color([0,0,0]).toHex()); // #000000</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> arr = ArrayUtil.map([
							<span class="hljs-string">'r'</span>,
							<span class="hljs-string">'g'</span>,
							<span class="hljs-string">'b'</span>
						], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span> {</span>
							<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">this</span>[x].toString(<span class="hljs-number">16</span>);
							<span class="hljs-keyword">return</span> s.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-string">'0'</span> + s : s;
						}, <span class="hljs-keyword">this</span>);
						<span class="hljs-keyword">return</span> <span class="hljs-string">'#'</span> + arr.join(<span class="hljs-string">''</span>); <span class="hljs-comment">// String</span>
					},
					toCss: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(includeAlpha)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-909">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-909">&#182;</a>
              </div>
              <p>summary:
    Returns a css color string in rgb(a) representation
example:
|    var c = new Color(“#FFF”).toCss();
|    console.log(c); // rgb(‘255’,’255’,’255’)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> t = <span class="hljs-keyword">this</span>,
							rgb = t.r + <span class="hljs-string">', '</span> + t.g + <span class="hljs-string">', '</span> + t.b;
						<span class="hljs-keyword">return</span> (includeAlpha ? <span class="hljs-string">'rgba('</span> + rgb + <span class="hljs-string">', '</span> + t.a : <span class="hljs-string">'rgb('</span> + rgb) + <span class="hljs-string">')'</span>; <span class="hljs-comment">// String</span>
					},
					toString: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-910">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-910">&#182;</a>
              </div>
              <p>summary:
    Returns a visual representation of the color</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toCss(<span class="hljs-literal">true</span>); <span class="hljs-comment">// String</span>
					}
				});
				Color.blendColors = dojo.blendColors = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(start, end, weight, obj)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-911">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-911">&#182;</a>
              </div>
              <p>summary:
    Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
    can reuse a previously allocated Color object for the result</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> t = obj || <span class="hljs-keyword">new</span> Color();
					ArrayUtil.forEach([
						<span class="hljs-string">'r'</span>,
						<span class="hljs-string">'g'</span>,
						<span class="hljs-string">'b'</span>,
						<span class="hljs-string">'a'</span>
					], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span> {</span>
						t[x] = start[x] + (end[x] - start[x]) * weight;
						<span class="hljs-keyword">if</span> (x !== <span class="hljs-string">'a'</span>) {
							t[x] = <span class="hljs-built_in">Math</span>.round(t[x]);
						}
					});
					<span class="hljs-keyword">return</span> t.sanitize(); <span class="hljs-comment">// Color</span>
				};
				Color.fromRgb = dojo.colorFromRgb = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(color, obj)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-912">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-912">&#182;</a>
              </div>
              <p>summary:
    Returns a <code>Color</code> instance from a string of the form
    “rgb(…)” or “rgba(…)”. Optionally accepts a <code>Color</code>
    object to update with the parsed value and return instead of
    creating a new object.
returns:
    A Color object. If obj is passed, it will be the return value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> m = color.toLowerCase()
						.match(<span class="hljs-regexp">/^rgba?\(([\s\.,0-9]+)\)/</span>);
					<span class="hljs-keyword">return</span> m &amp;&amp; Color.fromArray(m[<span class="hljs-number">1</span>].split(<span class="hljs-regexp">/\s*,\s*/</span>), obj); <span class="hljs-comment">// Color</span>
				};
				Color.fromHex = dojo.colorFromHex = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(color, obj)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-913">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-913">&#182;</a>
              </div>
              <p>summary:
    Converts a hex string with a ‘#’ prefix to a color object.
    Supports 12-bit #rgb shorthand. Optionally accepts a
    <code>Color</code> object to update with the parsed value.</p>
<p>returns:
    A Color object. If obj is passed, it will be the return value.</p>
<p>example:
 | var thing = dojo.colorFromHex(“#ededed”); // grey, longhand</p>
<p>example:
| var thing = dojo.colorFromHex(“#000”); // black, shorthand</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> t = obj || <span class="hljs-keyword">new</span> Color(),
						bits = color.length === <span class="hljs-number">4</span> ? <span class="hljs-number">4</span> : <span class="hljs-number">8</span>,
						mask = (<span class="hljs-number">1</span> &lt;&lt; bits) - <span class="hljs-number">1</span>;
					color = <span class="hljs-built_in">Number</span>(<span class="hljs-string">'0x'</span> + color.substr(<span class="hljs-number">1</span>));
					<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(color)) {
						<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// Color</span>
					}
					ArrayUtil.forEach([
						<span class="hljs-string">'b'</span>,
						<span class="hljs-string">'g'</span>,
						<span class="hljs-string">'r'</span>
					], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span> {</span>
						<span class="hljs-keyword">var</span> c = color &amp; mask;
						color &gt;&gt;= bits;
						t[x] = bits === <span class="hljs-number">4</span> ? <span class="hljs-number">17</span> * c : c;
					});
					t.a = <span class="hljs-number">1</span>;
					<span class="hljs-keyword">return</span> t; <span class="hljs-comment">// Color</span>
				};
				Color.fromArray = dojo.colorFromArray = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, obj)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-914">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-914">&#182;</a>
              </div>
              <p>summary:
    Builds a <code>Color</code> from a 3 or 4 element array, mapping each
    element in sequence to the rgb(a) values of the color.
example:
    | var myColor = dojo.colorFromArray([237,237,237,0.5]); // grey, 50% alpha
returns:
    A Color object. If obj is passed, it will be the return value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> t = obj || <span class="hljs-keyword">new</span> Color();
					t._set(<span class="hljs-built_in">Number</span>(a[<span class="hljs-number">0</span>]), <span class="hljs-built_in">Number</span>(a[<span class="hljs-number">1</span>]), <span class="hljs-built_in">Number</span>(a[<span class="hljs-number">2</span>]), <span class="hljs-built_in">Number</span>(a[<span class="hljs-number">3</span>]));
					<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(t.a)) {
						t.a = <span class="hljs-number">1</span>;
					}
					<span class="hljs-keyword">return</span> t.sanitize(); <span class="hljs-comment">// Color</span>
				};
				Color.fromString = dojo.colorFromString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(str, obj)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-915">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-915">&#182;</a>
              </div>
              <p>summary:
    Parses <code>str</code> for a color value. Accepts hex, rgb, and rgba
    style color values.
description:
    Acceptable input values for str may include arrays of any form
    accepted by dojo.colorFromArray, hex strings such as “#aaaaaa”, or
    rgb or rgba strings such as “rgb(133, 200, 16)” or “rgba(10, 10,
    10, 50)”
returns:
    A Color object. If obj is passed, it will be the return value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> a = Color.named[str];
					<span class="hljs-keyword">return</span> a &amp;&amp; Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj); <span class="hljs-comment">// Color</span>
				};
				<span class="hljs-keyword">return</span> Color;
			});
		},
		<span class="hljs-string">'dojo/promise/instrumentation'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./tracer'</span>,
				<span class="hljs-string">'../has'</span>,
				<span class="hljs-string">'../_base/lang'</span>,
				<span class="hljs-string">'../_base/array'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(tracer, has, lang, arrayUtil)</span> {</span>
				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logError</span><span class="hljs-params">(error, rejection, deferred)</span> {</span>
					<span class="hljs-keyword">var</span> stack = <span class="hljs-string">''</span>;
					<span class="hljs-keyword">if</span> (error &amp;&amp; error.stack) {
						stack += error.stack;
					}
					<span class="hljs-keyword">if</span> (rejection &amp;&amp; rejection.stack) {
						stack += <span class="hljs-string">'\n    ----------------------------------------\n    rejected'</span> + rejection.stack.split(<span class="hljs-string">'\n'</span>)
							.slice(<span class="hljs-number">1</span>)
							.join(<span class="hljs-string">'\n'</span>)
							.replace(<span class="hljs-regexp">/^\s+/</span>, <span class="hljs-string">' '</span>);
					}
					<span class="hljs-keyword">if</span> (deferred &amp;&amp; deferred.stack) {
						stack += <span class="hljs-string">'\n    ----------------------------------------\n'</span> + deferred.stack;
					}
					console.error(error, stack);
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reportRejections</span><span class="hljs-params">(error, handled, rejection, deferred)</span> {</span>
					<span class="hljs-keyword">if</span> (!handled) {
						logError(error, rejection, deferred);
					}
				}
				<span class="hljs-keyword">var</span> errors = [];
				<span class="hljs-keyword">var</span> activeTimeout = <span class="hljs-literal">false</span>;
				<span class="hljs-keyword">var</span> unhandledWait = <span class="hljs-number">1000</span>;

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trackUnhandledRejections</span><span class="hljs-params">(error, handled, rejection, deferred)</span> {</span>
					<span class="hljs-keyword">if</span> (handled) {
						arrayUtil.some(errors, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj, ix)</span> {</span>
							<span class="hljs-keyword">if</span> (obj.error === error) {
								errors.splice(ix, <span class="hljs-number">1</span>);
								<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
							}
						});
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!arrayUtil.some(errors, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> {</span>
						<span class="hljs-keyword">return</span> obj.error === error;
					})) {
						errors.push({
							error: error,
							rejection: rejection,
							deferred: deferred,
							timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
								.getTime()
						});
					}
					<span class="hljs-keyword">if</span> (!activeTimeout) {
						activeTimeout = setTimeout(logRejected, unhandledWait);
					}
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logRejected</span><span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
						.getTime();
					<span class="hljs-keyword">var</span> reportBefore = now - unhandledWait;
					errors = arrayUtil.filter(errors, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> {</span>
						<span class="hljs-keyword">if</span> (obj.timestamp &lt; reportBefore) {
							logError(obj.error, obj.rejection, obj.deferred);
							<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
						}
						<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
					});
					<span class="hljs-keyword">if</span> (errors.length) {
						activeTimeout = setTimeout(logRejected, errors[<span class="hljs-number">0</span>].timestamp + unhandledWait - now);
					}
				}
				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Deferred)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-916">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-916">&#182;</a>
              </div>
              <p>summary:
    Initialize instrumentation for the Deferred class.
description:
    Initialize instrumentation for the Deferred class.
    Done automatically by <code>dojo/Deferred</code> if the
    <code>deferredInstrumentation</code> and <code>useDeferredInstrumentation</code>
    config options are set.</p>
<pre><code>Sets up `dojo/promise/tracer` to log to the console.

Sets up instrumentation of rejected deferreds so unhandled
errors are logged to the console.
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> usage = has(<span class="hljs-string">'config-useDeferredInstrumentation'</span>);
					<span class="hljs-keyword">if</span> (usage) {
						tracer.on(<span class="hljs-string">'resolved'</span>, lang.hitch(console, <span class="hljs-string">'log'</span>, <span class="hljs-string">'resolved'</span>));
						tracer.on(<span class="hljs-string">'rejected'</span>, lang.hitch(console, <span class="hljs-string">'log'</span>, <span class="hljs-string">'rejected'</span>));
						tracer.on(<span class="hljs-string">'progress'</span>, lang.hitch(console, <span class="hljs-string">'log'</span>, <span class="hljs-string">'progress'</span>));
						<span class="hljs-keyword">var</span> args = [];
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> usage === <span class="hljs-string">'string'</span>) {
							args = usage.split(<span class="hljs-string">','</span>);
							usage = args.shift();
						}
						<span class="hljs-keyword">if</span> (usage === <span class="hljs-string">'report-rejections'</span>) {
							Deferred.instrumentRejected = reportRejections;
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (usage === <span class="hljs-string">'report-unhandled-rejections'</span> || usage === <span class="hljs-literal">true</span> || usage === <span class="hljs-number">1</span>) {
							Deferred.instrumentRejected = trackUnhandledRejections;
							unhandledWait = <span class="hljs-built_in">parseInt</span>(args[<span class="hljs-number">0</span>], <span class="hljs-number">10</span>) || unhandledWait;
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unsupported instrumentation usage &lt;'</span> + usage + <span class="hljs-string">'&gt;'</span>);
						}
					}
				};
			});
		},
		<span class="hljs-string">'dojo/selector/_loader'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'../has'</span>,
				<span class="hljs-string">'require'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(has, require)</span> {</span>
<span class="hljs-pi">				'use strict'</span>;
				<span class="hljs-keyword">var</span> testDiv = document.createElement(<span class="hljs-string">'div'</span>);
				has.add(<span class="hljs-string">'dom-qsa2.1'</span>, !! testDiv.querySelectorAll);
				has.add(<span class="hljs-string">'dom-qsa3'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-917">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-917">&#182;</a>
              </div>
              <p>test to see if we have a reasonable native selector engine available</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">try</span> {
						testDiv.innerHTML = <span class="hljs-string">'&lt;p class=\'TEST\'&gt;&lt;/p&gt;'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-918">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-918">&#182;</a>
              </div>
              <p>test kind of from sizzle
Safari can’t handle uppercase or unicode characters when
in quirks mode, IE8 can’t handle pseudos like :empty</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> testDiv.querySelectorAll(<span class="hljs-string">'.TEST:empty'</span>)
							.length === <span class="hljs-number">1</span>;
					} <span class="hljs-keyword">catch</span> (e) {}
				});
				<span class="hljs-keyword">var</span> fullEngine;
				<span class="hljs-keyword">var</span> acme = <span class="hljs-string">'./acme'</span>,
					lite = <span class="hljs-string">'./lite'</span>;
				<span class="hljs-keyword">return</span> {
					load: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, parentRequire, loaded, config)</span> {</span>
						<span class="hljs-keyword">var</span> req = <span class="hljs-built_in">require</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-919">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-919">&#182;</a>
              </div>
              <p>here we implement the default logic for choosing a selector engine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						id = id === <span class="hljs-string">'default'</span> ? has(<span class="hljs-string">'config-selectorEngine'</span>) || <span class="hljs-string">'css3'</span> : id;
						id = id === <span class="hljs-string">'css2'</span> || id === <span class="hljs-string">'lite'</span> ? lite : id === <span class="hljs-string">'css2.1'</span> ? has(<span class="hljs-string">'dom-qsa2.1'</span>) ? lite : acme : id === <span class="hljs-string">'css3'</span> ? has(<span class="hljs-string">'dom-qsa3'</span>) ? lite : acme : id === <span class="hljs-string">'acme'</span> ? acme : (req = parentRequire) &amp;&amp; id;
						<span class="hljs-keyword">if</span> (id.charAt(id.length - <span class="hljs-number">1</span>) === <span class="hljs-string">'?'</span>) {
							id = id.substring(<span class="hljs-number">0</span>, id.length - <span class="hljs-number">1</span>);
							<span class="hljs-keyword">var</span> optionalLoad = <span class="hljs-literal">true</span>;
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-920">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-920">&#182;</a>
              </div>
              <p>the query engine is optional, only load it if a native one is not available or existing one has not been loaded</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (optionalLoad &amp;&amp; (has(<span class="hljs-string">'dom-compliant-qsa'</span>) || fullEngine)) {
							<span class="hljs-keyword">return</span> loaded(fullEngine);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-921">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-921">&#182;</a>
              </div>
              <p>load the referenced selector engine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						req([id], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(engine)</span> {</span>
							<span class="hljs-keyword">if</span> (id !== <span class="hljs-string">'./lite'</span>) {
								fullEngine = engine;
							}
							loaded(engine);
						});
					}
				};
			});
		},
		<span class="hljs-string">'dojo/promise/Promise'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([<span class="hljs-string">'../_base/lang'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(lang)</span> {</span>
<span class="hljs-pi">				'use strict'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-922">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-922">&#182;</a>
              </div>
              <p>module:
    dojo/promise/Promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwAbstract</span><span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'abstract'</span>);
				}
				<span class="hljs-keyword">return</span> lang.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span><span class="hljs-params">()</span> {</span>}, {
					then: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback, errback, progback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-923">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-923">&#182;</a>
              </div>
              <p>summary:
    Add new callbacks to the promise.
description:
    Add new callbacks to the deferred. Callbacks can be added
    before or after the deferred is fulfilled.
callback: Function?
    Callback to be invoked when the promise is resolved.
    Receives the resolution value.
errback: Function?
    Callback to be invoked when the promise is rejected.
    Receives the rejection error.
progback: Function?
    Callback to be invoked when the promise emits a progress
    update. Receives the progress update.
returns: dojo/promise/Promise
    Returns a new promise for the result of the callback(s).
    This can be used for chaining many asynchronous operations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						throwAbstract();
					},
					cancel: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(reason, strict)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-924">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-924">&#182;</a>
              </div>
              <p>summary:
    Inform the deferred it may cancel its asynchronous operation.
description:
    Inform the deferred it may cancel its asynchronous operation.
    The deferred’s (optional) canceler is invoked and the
    deferred will be left in a rejected state. Can affect other
    promises that originate with the same deferred.
reason: any
    A message that may be sent to the deferred’s canceler,
    explaining why it’s being canceled.
strict: Boolean?
    If strict, will throw an error if the deferred has already
    been fulfilled and consequently cannot be canceled.
returns: any
    Returns the rejection reason if the deferred was canceled
    normally.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						throwAbstract();
					},
					isResolved: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-925">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-925">&#182;</a>
              </div>
              <p>summary:
    Checks whether the promise has been resolved.
returns: Boolean</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						throwAbstract();
					},
					isRejected: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-926">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-926">&#182;</a>
              </div>
              <p>summary:
    Checks whether the promise has been rejected.
returns: Boolean</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						throwAbstract();
					},
					isFulfilled: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-927">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-927">&#182;</a>
              </div>
              <p>summary:
    Checks whether the promise has been resolved or rejected.
returns: Boolean</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						throwAbstract();
					},
					isCanceled: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-928">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-928">&#182;</a>
              </div>
              <p>summary:
    Checks whether the promise has been canceled.
returns: Boolean</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						throwAbstract();
					},
					always: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callbackOrErrback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-929">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-929">&#182;</a>
              </div>
              <p>summary:
    Add a callback to be invoked when the promise is resolved
    or rejected.
callbackOrErrback: Function?
    A function that is used both as a callback and errback.
returns: dojo/promise/Promise
    Returns a new promise for the result of the callback/errback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(callbackOrErrback, callbackOrErrback);
					},
					otherwise: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(errback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-930">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-930">&#182;</a>
              </div>
              <p>summary:
    Add new errbacks to the promise.
errback: Function?
    Callback to be invoked when the promise is rejected.
returns: dojo/promise/Promise
    Returns a new promise for the result of the errback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, errback);
					},
					trace: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
					},
					traceRejected: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
					},
					toString: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-931">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-931">&#182;</a>
              </div>
              <p>returns: string
    Returns <code>[object Promise]</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-string">'[object Promise]'</span>;
					}
				});
			});
		},
		<span class="hljs-string">'dojo/request/watch'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./util'</span>,
				<span class="hljs-string">'../errors/RequestTimeoutError'</span>,
				<span class="hljs-string">'../errors/CancelError'</span>,
				<span class="hljs-string">'../_base/array'</span>,
				<span class="hljs-string">'../_base/window'</span>,
				<span class="hljs-string">'../has!host-browser?dom-addeventlistener?:../on:'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(util, RequestTimeoutError, CancelError, array, win, on)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-932">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-932">&#182;</a>
              </div>
              <p>avoid setting a timer per request. It degrades performance on IE
something fierece if we don’t use unified loops.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> _inFlightIntvl = <span class="hljs-literal">null</span>,
					_inFlight = [];

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watchInFlight</span><span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-933">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-933">&#182;</a>
              </div>
              <p>summary:
    internal method that checks each inflight XMLHttpRequest to see
    if it has completed or if the timeout situation applies.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</pre></div></div>
            
        </li>
        
        
        <li id="section-934">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-934">&#182;</a>
              </div>
              <p>we need manual loop because we often modify _inFlight (and therefore ‘i’) while iterating</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, dfd; i &lt; _inFlight.length &amp;&amp; (dfd = _inFlight[i]); i++) {
						<span class="hljs-keyword">var</span> response = dfd.response,
							options = response.options;
						<span class="hljs-keyword">if</span> (dfd.isCanceled &amp;&amp; dfd.isCanceled() || dfd.isValid &amp;&amp; !dfd.isValid(response)) {
							_inFlight.splice(i--, <span class="hljs-number">1</span>);
							watch._onAction &amp;&amp; watch._onAction();
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dfd.isReady &amp;&amp; dfd.isReady(response)) {
							_inFlight.splice(i--, <span class="hljs-number">1</span>);
							dfd.handleResponse(response);
							watch._onAction &amp;&amp; watch._onAction();
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dfd.startTime) {</pre></div></div>
            
        </li>
        
        
        <li id="section-935">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-935">&#182;</a>
              </div>
              <p>did we timeout?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (dfd.startTime + (options.timeout || <span class="hljs-number">0</span>) &lt; now) {
								_inFlight.splice(i--, <span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-936">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-936">&#182;</a>
              </div>
              <p>Cancel the request so the io module can do appropriate cleanup.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								dfd.cancel(<span class="hljs-keyword">new</span> RequestTimeoutError(<span class="hljs-string">'Timeout exceeded'</span>, response));
								watch._onAction &amp;&amp; watch._onAction();
							}
						}
					}
					watch._onInFlight &amp;&amp; watch._onInFlight(dfd);
					<span class="hljs-keyword">if</span> (!_inFlight.length) {
						clearInterval(_inFlightIntvl);
						_inFlightIntvl = <span class="hljs-literal">null</span>;
					}
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watch</span><span class="hljs-params">(dfd)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-937">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-937">&#182;</a>
              </div>
              <p>summary:
    Watches the io request represented by dfd to see if it completes.
dfd: Deferred
    The Deferred object to watch.
response: Object
    The object used as the value of the request promise.
validCheck: Function
    Function used to check if the IO request is still valid. Gets the dfd
    object as its only argument.
ioCheck: Function
    Function used to check if basic IO call worked. Gets the dfd
    object as its only argument.
resHandle: Function
    Function used to process response. Gets the dfd
    object as its only argument.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (dfd.response.options.timeout) {
						dfd.startTime = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
					}
					<span class="hljs-keyword">if</span> (dfd.isFulfilled()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-938">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-938">&#182;</a>
              </div>
              <p>bail out if the deferred is already fulfilled</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span>;
					}
					_inFlight.push(dfd);
					<span class="hljs-keyword">if</span> (!_inFlightIntvl) {
						_inFlightIntvl = setInterval(watchInFlight, <span class="hljs-number">50</span>);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-939">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-939">&#182;</a>
              </div>
              <p>handle sync requests separately from async:
<a href="http://bugs.dojotoolkit.org/ticket/8467">http://bugs.dojotoolkit.org/ticket/8467</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (dfd.response.options.sync) {
						watchInFlight();
					}
				}
				watch.cancelAll = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancelAll</span><span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-940">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-940">&#182;</a>
              </div>
              <p>summary:
    Cancels all pending IO requests, regardless of IO type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">try</span> {
						array.forEach(_inFlight, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dfd)</span> {</span>
							<span class="hljs-keyword">try</span> {
								dfd.cancel(<span class="hljs-keyword">new</span> CancelError(<span class="hljs-string">'All requests canceled.'</span>));
							} <span class="hljs-keyword">catch</span> (e) {}
						});
					} <span class="hljs-keyword">catch</span> (e) {}
				};
				<span class="hljs-keyword">if</span> (win &amp;&amp; on &amp;&amp; win.doc.attachEvent) {</pre></div></div>
            
        </li>
        
        
        <li id="section-941">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-941">&#182;</a>
              </div>
              <p>Automatically call cancel all io calls on unload in IE
<a href="http://bugs.dojotoolkit.org/ticket/2357">http://bugs.dojotoolkit.org/ticket/2357</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					on(win.global, <span class="hljs-string">'unload'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						watch.cancelAll();
					});
				}
				<span class="hljs-keyword">return</span> watch;
			});
		},
		<span class="hljs-string">'dojo/on'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./has!dom-addeventlistener?:./aspect'</span>,
				<span class="hljs-string">'./_base/kernel'</span>,
				<span class="hljs-string">'./has'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(aspect, dojo, has)</span> {</span>
<span class="hljs-pi">				'use strict'</span>;
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-942">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-942">&#182;</a>
              </div>
              <p>check to make sure we are in a browser, this module should work anywhere</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> major = window.ScriptEngineMajorVersion;
					has.add(<span class="hljs-string">'jscript'</span>, major &amp;&amp; major() + ScriptEngineMinorVersion() / <span class="hljs-number">10</span>);
					has.add(<span class="hljs-string">'event-orientationchange'</span>, has(<span class="hljs-string">'touch'</span>) &amp;&amp; !has(<span class="hljs-string">'android'</span>));</pre></div></div>
            
        </li>
        
        
        <li id="section-943">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-943">&#182;</a>
              </div>
              <p>TODO: how do we detect this?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					has.add(<span class="hljs-string">'event-stopimmediatepropagation'</span>, window.Event &amp;&amp; !! window.Event.prototype &amp;&amp; !! window.Event.prototype.stopImmediatePropagation);
				}
				<span class="hljs-keyword">var</span> on = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, type, listener, dontFix)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-944">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-944">&#182;</a>
              </div>
              <p>summary:
    A function that provides core event listening functionality. With this function
    you can provide a target, event type, and listener to be notified of
    future matching events that are fired.
target: Element|Object
    This is the target object or DOM element that to receive events from
type: String|Function
    This is the name of the event to listen for or an extension event type.
listener: Function
    This is the function that should be called when the event fires.
returns: Object
    An object with a remove() method that can be used to stop listening for this
    event.
description:
    To listen for “click” events on a button node, we can do:
    |    define([“dojo/on”], function(listen){
    |        on(button, “click”, clickHandler);
    |        …
    Evented JavaScript objects can also have their own events.
    |    var obj = new Evented;
    |    on(obj, “foo”, fooHandler);
    And then we could publish a “foo” event:
    |    on.emit(obj, “foo”, {key: “value”});
    We can use extension events as well. For example, you could listen for a tap gesture:
    |    define([“dojo/on”, “dojo/gesture/tap”, function(listen, tap){
    |        on(button, tap, tapHandler);
    |        …
    which would trigger fooHandler. Note that for a simple object this is equivalent to calling:
    |    obj.onfoo({key:”value”});
    If you use on.emit on a DOM node, it will use native event dispatching when possible.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target.on === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> type !== <span class="hljs-string">'function'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-945">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-945">&#182;</a>
              </div>
              <p>delegate to the target’s on() method, so it can handle it’s own listening if it wants</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> target.on(type, listener);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-946">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-946">&#182;</a>
              </div>
              <p>delegate to main listener code</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> on.parse(target, type, listener, addListener, dontFix, <span class="hljs-keyword">this</span>);
				};
				on.pausable = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, type, listener, dontFix)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-947">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-947">&#182;</a>
              </div>
              <p>summary:
    This function acts the same as on(), but with pausable functionality. The
    returned signal object has pause() and resume() functions. Calling the
    pause() method will cause the listener to not be called for future events. Calling the
    resume() method will cause the listener to again be called for future events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> paused;
					<span class="hljs-keyword">var</span> signal = on(target, type, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">if</span> (!paused) {
							<span class="hljs-keyword">return</span> listener.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
						}
					}, dontFix);
					signal.pause = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						paused = <span class="hljs-literal">true</span>;
					};
					signal.resume = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						paused = <span class="hljs-literal">false</span>;
					};
					<span class="hljs-keyword">return</span> signal;
				};
				on.once = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, type, listener, dontFix)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-948">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-948">&#182;</a>
              </div>
              <p>summary:
    This function acts the same as on(), but will only call the listener once. The 
    listener will be called for the first
    event that takes place and then listener will automatically be removed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> signal = on(target, type, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-949">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-949">&#182;</a>
              </div>
              <p>remove this listener</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						signal.remove();</pre></div></div>
            
        </li>
        
        
        <li id="section-950">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-950">&#182;</a>
              </div>
              <p>proceed to call the listener</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> listener.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
					});
					<span class="hljs-keyword">return</span> signal;
				};
				on.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, type, listener, addListener, dontFix, matchesTarget)</span> {</span>
					<span class="hljs-keyword">if</span> (type.call) {</pre></div></div>
            
        </li>
        
        
        <li id="section-951">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-951">&#182;</a>
              </div>
              <p>event handler function
on(node, touch.press, touchListener);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> type.call(matchesTarget, target, listener);
					}
					<span class="hljs-keyword">if</span> (type.indexOf(<span class="hljs-string">','</span>) &gt; -<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-952">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-952">&#182;</a>
              </div>
              <p>we allow comma delimited event names, so you can register for multiple events at once</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> events = type.split(<span class="hljs-regexp">/\s*,\s*/</span>);
						<span class="hljs-keyword">var</span> handles = [];
						<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
						<span class="hljs-keyword">var</span> eventName;
						<span class="hljs-keyword">while</span> (eventName = events[i++]) {
							handles.push(addListener(target, eventName, listener, dontFix, matchesTarget));
						}
						handles.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; handles.length; i++) {
								handles[i].remove();
							}
						};
						<span class="hljs-keyword">return</span> handles;
					}
					<span class="hljs-keyword">return</span> addListener(target, type, listener, dontFix, matchesTarget);
				};
				<span class="hljs-keyword">var</span> touchEvents = <span class="hljs-regexp">/^touch/</span>;

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addListener</span><span class="hljs-params">(target, type, listener, dontFix, matchesTarget)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-953">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-953">&#182;</a>
              </div>
              <p>event delegation:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> selector = type.match(<span class="hljs-regexp">/(.*):(.*)/</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-954">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-954">&#182;</a>
              </div>
              <p>if we have a selector:event, the last one is interpreted as an event, and we use event delegation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (selector) {
						type = selector[<span class="hljs-number">2</span>];
						selector = selector[<span class="hljs-number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-955">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-955">&#182;</a>
              </div>
              <p>create the extension event for selectors and directly call it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> on.selector(selector, type)
							.call(matchesTarget, target, listener);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-956">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-956">&#182;</a>
              </div>
              <p>test to see if it a touch event right now, so we don’t have to do it every time it fires</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'touch'</span>)) {
						<span class="hljs-keyword">if</span> (touchEvents.test(type)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-957">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-957">&#182;</a>
              </div>
              <p>touch event, fix it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							listener = fixTouchListener(listener);
						}
						<span class="hljs-keyword">if</span> (!has(<span class="hljs-string">'event-orientationchange'</span>) &amp;&amp; type === <span class="hljs-string">'orientationchange'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-958">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-958">&#182;</a>
              </div>
              <p>“orientationchange” not supported &lt;= Android 2.1, 
but works through “resize” on window</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							type = <span class="hljs-string">'resize'</span>;
							target = window;
							listener = fixTouchListener(listener);
						}
					}
					<span class="hljs-keyword">if</span> (addStopImmediate) {</pre></div></div>
            
        </li>
        
        
        <li id="section-959">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-959">&#182;</a>
              </div>
              <p>add stopImmediatePropagation if it doesn’t exist</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						listener = addStopImmediate(listener);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-960">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-960">&#182;</a>
              </div>
              <p>normal path, the target is |this|</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (target.addEventListener) {</pre></div></div>
            
        </li>
        
        
        <li id="section-961">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-961">&#182;</a>
              </div>
              <p>the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)
check for capture conversions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> capture = type <span class="hljs-keyword">in</span> captures,
							adjustedType = capture ? captures[type] : type;
						target.addEventListener(adjustedType, listener, capture);</pre></div></div>
            
        </li>
        
        
        <li id="section-962">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-962">&#182;</a>
              </div>
              <p>create and return the signal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> {
							remove: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								target.removeEventListener(adjustedType, listener, capture);
							}
						};
					}
					type = <span class="hljs-string">'on'</span> + type;
					<span class="hljs-keyword">if</span> (fixAttach &amp;&amp; target.attachEvent) {
						<span class="hljs-keyword">return</span> fixAttach(target, type, listener);
					}
					<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Target must be an event emitter'</span>);
				}
				on.selector = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(selector, eventType, children)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-963">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-963">&#182;</a>
              </div>
              <p>summary:
    Creates a new extension event with event delegation. This is based on
    the provided event type (can be extension event) that
    only calls the listener when the CSS selector matches the target of the event.</p>
<pre><code>The application must <span class="hljs-built_in">require</span>() an appropriate level of dojo/query to handle the selector.
</code></pre><p>selector:
    The CSS selector to use for filter events and determine the |this| of the event listener.
eventType:
    The event to listen for
children:
    Indicates if children elements of the selector should be allowed. This defaults to 
    true
example:
|    require([“dojo/on”, “dojo/mouse”, “dojo/query!css2”], function(listen, mouse){
|        on(node, on.selector(“.my-class”, mouse.enter), handlerForMyHover);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, listener)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-964">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-964">&#182;</a>
              </div>
              <p>if the selector is function, use it to select the node, otherwise use the matches method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> matchesTarget = <span class="hljs-keyword">typeof</span> selector === <span class="hljs-string">'function'</span> ? {
							matches: selector
						} : <span class="hljs-keyword">this</span>,
							bubble = eventType.bubble;

						<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">select</span><span class="hljs-params">(eventTarget)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-965">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-965">&#182;</a>
              </div>
              <p>see if we have a valid matchesTarget or default to dojo.query</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							matchesTarget = matchesTarget &amp;&amp; matchesTarget.matches ? matchesTarget : dojo.query;</pre></div></div>
            
        </li>
        
        
        <li id="section-966">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-966">&#182;</a>
              </div>
              <p>there is a selector, so make sure it matches</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">while</span> (!matchesTarget.matches(eventTarget, selector, target)) {
								<span class="hljs-keyword">if</span> (eventTarget === target || children === <span class="hljs-literal">false</span> || !(eventTarget = eventTarget.parentNode) || eventTarget.nodeType !== <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-967">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-967">&#182;</a>
              </div>
              <p>intentional assignment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-keyword">return</span>;
								}
							}
							<span class="hljs-keyword">return</span> eventTarget;
						}
						<span class="hljs-keyword">if</span> (bubble) {</pre></div></div>
            
        </li>
        
        
        <li id="section-968">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-968">&#182;</a>
              </div>
              <p>the event type doesn’t naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> on(target, bubble(select), listener);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-969">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-969">&#182;</a>
              </div>
              <p>standard event delegation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> on(target, eventType, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-970">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-970">&#182;</a>
              </div>
              <p>call select to see if we match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> eventTarget = select(event.target);</pre></div></div>
            
        </li>
        
        
        <li id="section-971">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-971">&#182;</a>
              </div>
              <p>if it matches we call the listener</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> eventTarget &amp;&amp; listener.call(eventTarget, event);
						});
					};
				};

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">syntheticPreventDefault</span><span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">this</span>.cancelable = <span class="hljs-literal">false</span>;
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">syntheticStopPropagation</span><span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">this</span>.bubbles = <span class="hljs-literal">false</span>;
				}
				<span class="hljs-keyword">var</span> slice = [].slice,
					syntheticDispatch = on.emit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, type, event)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-972">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-972">&#182;</a>
              </div>
              <p>summary:
    Fires an event on the target object.
target:
    The target object to fire the event on. This can be a DOM element or a plain 
    JS object. If the target is a DOM element, native event emiting mechanisms
    are used when possible.
type:
    The event type name. You can emulate standard native events like “click” and 
    “mouseover” or create custom events like “open” or “finish”.
event:
    An object that provides the properties for the event. See <a href="https://developer.mozilla.org/en/DOM/event.initEvent">https://developer.mozilla.org/en/DOM/event.initEvent</a> 
    for some of the properties. These properties are copied to the event object.
    Of particular importance are the cancelable and bubbles properties. The
    cancelable property indicates whether or not the event has a default action
    that can be cancelled. The event is cancelled by calling preventDefault() on
    the event object. The bubbles property indicates whether or not the
    event will bubble up the DOM tree. If bubbles is true, the event will be called
    on the target and then each parent successively until the top of the tree
    is reached or stopPropagation() is called. Both bubbles and cancelable 
    default to false.
returns:
    If the event is cancelable and the event is not cancelled,
    emit will return true. If the event is cancelable and the event is cancelled,
    emit will return false.
details:
    Note that this is designed to emit events for listeners registered through
    dojo/on. It should actually work with any event listener except those
    added through IE’s attachEvent (IE8 and below’s non-W3C event emiting
    doesn’t support custom event types). It should work with all events registered
    through dojo/on. Also note that the emit method does do any default
    action, it only returns a value to indicate if the default action should take
    place. For example, emiting a keypress event would not cause a character
    to appear in a textbox.
example:
    To fire our own click event
|    on.emit(dojo.byId(“button”), “click”, {
|        cancelable: true,
|        bubbles: true,
|        screenX: 33,
|        screenY: 44
|    });
    We can also fire our own custom events:
|    on.emit(dojo.byId(“slider”), “slide”, {
|        cancelable: true,
|        bubbles: true,
|        direction: “left-to-right”
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> args = slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);
						<span class="hljs-keyword">var</span> method = <span class="hljs-string">'on'</span> + type;
						<span class="hljs-keyword">if</span> (<span class="hljs-string">'parentNode'</span> <span class="hljs-keyword">in</span> target) {</pre></div></div>
            
        </li>
        
        
        <li id="section-973">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-973">&#182;</a>
              </div>
              <p>node (or node-like), create event controller methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> newEvent = args[<span class="hljs-number">0</span>] = {};
							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> event) {
								newEvent[i] = event[i];
							}
							newEvent.preventDefault = syntheticPreventDefault;
							newEvent.stopPropagation = syntheticStopPropagation;
							newEvent.target = target;
							newEvent.type = type;
							event = newEvent;
						}
						<span class="hljs-keyword">do</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-974">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-974">&#182;</a>
              </div>
              <p>call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							target[method] &amp;&amp; target[method].apply(target, args); <span class="hljs-comment">// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)</span>
						} <span class="hljs-keyword">while</span> (event &amp;&amp; event.bubbles &amp;&amp; (target = target.parentNode));
						<span class="hljs-keyword">return</span> event &amp;&amp; event.cancelable &amp;&amp; event; <span class="hljs-comment">// if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen</span>
					};
				<span class="hljs-keyword">var</span> captures = {};
				<span class="hljs-keyword">if</span> (!has(<span class="hljs-string">'event-stopimmediatepropagation'</span>)) {
					<span class="hljs-keyword">var</span> stopImmediatePropagation = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">this</span>.immediatelyStopped = <span class="hljs-literal">true</span>;
						<span class="hljs-keyword">this</span>.modified = <span class="hljs-literal">true</span>; <span class="hljs-comment">// mark it as modified so the event will be cached in IE</span>
					};
					<span class="hljs-keyword">var</span> addStopImmediate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(listener)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> {</span>
							<span class="hljs-keyword">if</span> (!event.immediatelyStopped) {</pre></div></div>
            
        </li>
        
        
        <li id="section-975">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-975">&#182;</a>
              </div>
              <p>check to make sure it hasn’t been stopped immediately</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								event.stopImmediatePropagation = stopImmediatePropagation;
								<span class="hljs-keyword">return</span> listener.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
							}
						};
					};
				}
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'dom-addeventlistener'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-976">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-976">&#182;</a>
              </div>
              <p>normalize focusin and focusout</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					captures = {
						focusin: <span class="hljs-string">'focus'</span>,
						focusout: <span class="hljs-string">'blur'</span>
					};
					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'opera'</span>)) {
						captures.keydown = <span class="hljs-string">'keypress'</span>; <span class="hljs-comment">// this one needs to be transformed because Opera doesn't support repeating keys on keydown (and keypress works because it incorrectly fires on all keydown events)</span>
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-977">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-977">&#182;</a>
              </div>
              <p>emiter that works with native event handling</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					on.emit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, type, event)</span> {</span>
						<span class="hljs-keyword">if</span> (target.dispatchEvent &amp;&amp; document.createEvent) {</pre></div></div>
            
        </li>
        
        
        <li id="section-978">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-978">&#182;</a>
              </div>
              <p>use the native event emiting mechanism if it is available on the target object
create a generic event<br>we could create branch into the different types of event constructors, but 
that would be a lot of extra code, with little benefit that I can see, seems 
best to use the generic constructor and copy properties over, making it 
easy to have events look like the ones created with specific initializers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> nativeEvent = target.ownerDocument.createEvent(<span class="hljs-string">'HTMLEvents'</span>);
							nativeEvent.initEvent(type, !! event.bubbles, !! event.cancelable);</pre></div></div>
            
        </li>
        
        
        <li id="section-979">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-979">&#182;</a>
              </div>
              <p>and copy all our properties over</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> event) {
								<span class="hljs-keyword">var</span> value = event[i];
								<span class="hljs-keyword">if</span> (!(i <span class="hljs-keyword">in</span> nativeEvent)) {
									nativeEvent[i] = event[i];
								}
							}
							<span class="hljs-keyword">return</span> target.dispatchEvent(nativeEvent) &amp;&amp; nativeEvent;
						}
						<span class="hljs-keyword">return</span> syntheticDispatch.apply(on, <span class="hljs-built_in">arguments</span>); <span class="hljs-comment">// emit for a non-node</span>
					};
				} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-980">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-980">&#182;</a>
              </div>
              <p>no addEventListener, basically old IE event normalization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					on._fixEvent = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt, sender)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-981">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-981">&#182;</a>
              </div>
              <p>summary:
    normalizes properties on the event object including event
    bubbling methods, keystroke normalization, and x/y positions
evt:
    native event object
sender:
    node to treat as “currentTarget”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!evt) {
							<span class="hljs-keyword">var</span> w = sender &amp;&amp; (sender.ownerDocument || sender.document || sender)
								.parentWindow || window;
							evt = w.event;
						}
						<span class="hljs-keyword">if</span> (!evt) {
							<span class="hljs-keyword">return</span> evt;
						}
						<span class="hljs-keyword">if</span> (lastEvent &amp;&amp; evt.type === lastEvent.type) {</pre></div></div>
            
        </li>
        
        
        <li id="section-982">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-982">&#182;</a>
              </div>
              <p>should be same event, reuse event object (so it can be augmented)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							evt = lastEvent;
						}
						<span class="hljs-keyword">if</span> (!evt.target) {</pre></div></div>
            
        </li>
        
        
        <li id="section-983">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-983">&#182;</a>
              </div>
              <p>check to see if it has been fixed yet</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							evt.target = evt.srcElement;
							evt.currentTarget = sender || evt.srcElement;
							<span class="hljs-keyword">if</span> (evt.type === <span class="hljs-string">'mouseover'</span>) {
								evt.relatedTarget = evt.fromElement;
							}
							<span class="hljs-keyword">if</span> (evt.type === <span class="hljs-string">'mouseout'</span>) {
								evt.relatedTarget = evt.toElement;
							}
							<span class="hljs-keyword">if</span> (!evt.stopPropagation) {
								evt.stopPropagation = stopPropagation;
								evt.preventDefault = preventDefault;
							}
							<span class="hljs-keyword">switch</span> (evt.type) {
							<span class="hljs-keyword">case</span> <span class="hljs-string">'keypress'</span>:
								<span class="hljs-keyword">var</span> c = <span class="hljs-string">'charCode'</span> <span class="hljs-keyword">in</span> evt ? evt.charCode : evt.keyCode;
								<span class="hljs-keyword">if</span> (c === <span class="hljs-number">10</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-984">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-984">&#182;</a>
              </div>
              <p>CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									c = <span class="hljs-number">0</span>;
									evt.keyCode = <span class="hljs-number">13</span>;
								} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c === <span class="hljs-number">13</span> || c === <span class="hljs-number">27</span>) {
									c = <span class="hljs-number">0</span>; <span class="hljs-comment">// Mozilla considers ENTER and ESC non-printable</span>
								} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c === <span class="hljs-number">3</span>) {
									c = <span class="hljs-number">99</span>; <span class="hljs-comment">// Mozilla maps CTRL-BREAK to CTRL-c</span>
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-985">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-985">&#182;</a>
              </div>
              <p>Mozilla sets keyCode to 0 when there is a charCode
but that stops the event on IE.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								evt.charCode = c;
								_setKeyChar(evt);
								<span class="hljs-keyword">break</span>;
							}
						}
						<span class="hljs-keyword">return</span> evt;
					};
					<span class="hljs-keyword">var</span> lastEvent, IESignal = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(handle)</span> {</span>
							<span class="hljs-keyword">this</span>.handle = handle;
						};
					IESignal.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">delete</span> _dojoIEListeners_[<span class="hljs-keyword">this</span>.handle];
					};
					<span class="hljs-keyword">var</span> fixListener = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(listener)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-986">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-986">&#182;</a>
              </div>
              <p>this is a minimal function for closing on the previous listener with as few as variables as possible</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> {</span>
							evt = on._fixEvent(evt, <span class="hljs-keyword">this</span>);
							<span class="hljs-keyword">var</span> result = listener.call(<span class="hljs-keyword">this</span>, evt);
							<span class="hljs-keyword">if</span> (evt.modified) {</pre></div></div>
            
        </li>
        
        
        <li id="section-987">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-987">&#182;</a>
              </div>
              <p>cache the last event and reuse it if we can</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (!lastEvent) {
									setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
										lastEvent = <span class="hljs-literal">null</span>;
									});
								}
								lastEvent = evt;
							}
							<span class="hljs-keyword">return</span> result;
						};
					};
					<span class="hljs-keyword">var</span> fixAttach = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, type, listener)</span> {</span>
						listener = fixListener(listener);
						<span class="hljs-keyword">if</span> (((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) !== top || has(<span class="hljs-string">'jscript'</span>) &lt; <span class="hljs-number">5.8</span>) &amp;&amp; !has(<span class="hljs-string">'config-_allow_leaks'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-988">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-988">&#182;</a>
              </div>
              <p>IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.
Here we use global redirection to solve the memory leaks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> _dojoIEListeners_ === <span class="hljs-string">'undefined'</span>) {
								_dojoIEListeners_ = [];
							}
							<span class="hljs-keyword">var</span> emiter = target[type];
							<span class="hljs-keyword">if</span> (!emiter || !emiter.listeners) {
								<span class="hljs-keyword">var</span> oldListener = emiter;
								emiter = <span class="hljs-built_in">Function</span>(<span class="hljs-string">'event'</span>, <span class="hljs-string">'var callee = arguments.callee; for(var i = 0; i&lt;callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}'</span>);
								emiter.listeners = [];
								target[type] = emiter;
								emiter.global = <span class="hljs-keyword">this</span>;
								<span class="hljs-keyword">if</span> (oldListener) {
									emiter.listeners.push(_dojoIEListeners_.push(oldListener) - <span class="hljs-number">1</span>);
								}
							}
							<span class="hljs-keyword">var</span> handle;
							emiter.listeners.push(handle = emiter.global._dojoIEListeners_.push(listener) - <span class="hljs-number">1</span>);
							<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IESignal(handle);
						}
						<span class="hljs-keyword">return</span> aspect.after(target, type, listener, <span class="hljs-literal">true</span>);
					};
					<span class="hljs-keyword">var</span> _setKeyChar = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> {</span>
						evt.keyChar = evt.charCode ? <span class="hljs-built_in">String</span>.fromCharCode(evt.charCode) : <span class="hljs-string">''</span>;
						evt.charOrCode = evt.keyChar || evt.keyCode;
					};</pre></div></div>
            
        </li>
        
        
        <li id="section-989">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-989">&#182;</a>
              </div>
              <p>Called in Event scope</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> stopPropagation = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">this</span>.cancelBubble = <span class="hljs-literal">true</span>;
					};
					<span class="hljs-keyword">var</span> preventDefault = on._preventDefault = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-990">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-990">&#182;</a>
              </div>
              <p>Setting keyCode to 0 is the only way to prevent certain keypresses (namely
ctrl-combinations that correspond to menu accelerator keys).
Otoh, it prevents upstream listeners from getting this information
Try to split the difference here by clobbering keyCode only for ctrl
combinations. If you still need to access the key upstream, bubbledKeyCode is
provided as a workaround.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">this</span>.bubbledKeyCode = <span class="hljs-keyword">this</span>.keyCode;
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ctrlKey) {
							<span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-991">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-991">&#182;</a>
              </div>
              <p>squelch errors when keyCode is read-only
(e.g. if keyCode is ctrl or shift)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">this</span>.keyCode = <span class="hljs-number">0</span>;
							} <span class="hljs-keyword">catch</span> (e) {}
						}
						<span class="hljs-keyword">this</span>.defaultPrevented = <span class="hljs-literal">true</span>;
						<span class="hljs-keyword">this</span>.returnValue = <span class="hljs-literal">false</span>;
					};
				}
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'touch'</span>)) {
					<span class="hljs-keyword">var</span> Event = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>};
					<span class="hljs-keyword">var</span> windowOrientation = window.orientation;
					<span class="hljs-keyword">var</span> fixTouchListener = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(listener)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(originalEvent)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-992">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-992">&#182;</a>
              </div>
              <p>Event normalization(for ontouchxxx and resize): 
1.incorrect e.pageX|pageY in iOS 
2.there are no “e.rotation”, “e.scale” and “onorientationchange” in Andriod
3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY
see if it has already been corrected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> event = originalEvent.corrected;
							<span class="hljs-keyword">if</span> (!event) {
								<span class="hljs-keyword">var</span> type = originalEvent.type;
								<span class="hljs-keyword">try</span> {
									<span class="hljs-keyword">delete</span> originalEvent.type; <span class="hljs-comment">// on some JS engines (android), deleting properties make them mutable</span>
								} <span class="hljs-keyword">catch</span> (e) {}
								<span class="hljs-keyword">if</span> (originalEvent.type) {</pre></div></div>
            
        </li>
        
        
        <li id="section-993">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-993">&#182;</a>
              </div>
              <p>deleting properties doesn’t work (older iOS), have to use delegation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									Event.prototype = originalEvent;
									<span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> Event();</pre></div></div>
            
        </li>
        
        
        <li id="section-994">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-994">&#182;</a>
              </div>
              <p>have to delegate methods to make them work</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									event.preventDefault = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
										originalEvent.preventDefault();
									};
									event.stopPropagation = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
										originalEvent.stopPropagation();
									};
								} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-995">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-995">&#182;</a>
              </div>
              <p>deletion worked, use property as is</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									event = originalEvent;
									event.type = type;
								}
								originalEvent.corrected = event;
								<span class="hljs-keyword">if</span> (type === <span class="hljs-string">'resize'</span>) {
									<span class="hljs-keyword">if</span> (windowOrientation === window.orientation) {
										<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//double tap causes an unexpected 'resize' in Andriod </span>
									}
									windowOrientation = window.orientation;
									event.type = <span class="hljs-string">'orientationchange'</span>;
									<span class="hljs-keyword">return</span> listener.call(<span class="hljs-keyword">this</span>, event);
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-996">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-996">&#182;</a>
              </div>
              <p>We use the original event and augment, rather than doing an expensive mixin operation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (!(<span class="hljs-string">'rotation'</span> <span class="hljs-keyword">in</span> event)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-997">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-997">&#182;</a>
              </div>
              <p>test to see if it has rotation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									event.rotation = <span class="hljs-number">0</span>;
									event.scale = <span class="hljs-number">1</span>;
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-998">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-998">&#182;</a>
              </div>
              <p>use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">var</span> firstChangeTouch = event.changedTouches[<span class="hljs-number">0</span>];
								<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> firstChangeTouch) {</pre></div></div>
            
        </li>
        
        
        <li id="section-999">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-999">&#182;</a>
              </div>
              <p>use for-in, we don’t need to have dependency on dojo/_base/lang here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-keyword">delete</span> event[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-1000">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1000">&#182;</a>
              </div>
              <p>delete it first to make it mutable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									event[i] = firstChangeTouch[i];
								}
							}
							<span class="hljs-keyword">return</span> listener.call(<span class="hljs-keyword">this</span>, event);
						};
					};
				}
				<span class="hljs-keyword">return</span> on;
			});
		},
		<span class="hljs-string">'dojo/_base/sniff'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'./lang'</span>,
				<span class="hljs-string">'../sniff'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, lang, has)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1001">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1001">&#182;</a>
              </div>
              <p>module:
    dojo/_base/sniff</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             return {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1002">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1002">&#182;</a>
              </div>
              <p>summary:
    Deprecated.   New code should use dojo/sniff.
    This module populates the dojo browser version sniffing properties like dojo.isIE.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				if (!1) {
					return has;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-1003">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1003">&#182;</a>
              </div>
              <p>no idea what this is for, or if it’s used</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo._name = <span class="hljs-string">'browser'</span>;
				lang.mixin(dojo, {
					isBrowser: <span class="hljs-literal">true</span>,
					isFF: has(<span class="hljs-string">'ff'</span>),
					isIE: has(<span class="hljs-string">'ie'</span>),
					isKhtml: has(<span class="hljs-string">'khtml'</span>),
					isWebKit: has(<span class="hljs-string">'webkit'</span>),
					isMozilla: has(<span class="hljs-string">'mozilla'</span>),
					isMoz: has(<span class="hljs-string">'mozilla'</span>),
					isOpera: has(<span class="hljs-string">'opera'</span>),
					isSafari: has(<span class="hljs-string">'safari'</span>),
					isChrome: has(<span class="hljs-string">'chrome'</span>),
					isMac: has(<span class="hljs-string">'mac'</span>),
					isIos: has(<span class="hljs-string">'ios'</span>),
					isAndroid: has(<span class="hljs-string">'android'</span>),
					isWii: has(<span class="hljs-string">'wii'</span>),
					isQuirks: has(<span class="hljs-string">'quirks'</span>),
					isAir: has(<span class="hljs-string">'air'</span>)
				});
				dojo.locale = dojo.locale || (has(<span class="hljs-string">'ie'</span>) ? navigator.userLanguage : navigator.language)
					.toLowerCase();
				<span class="hljs-keyword">return</span> has;
			});
		},
		<span class="hljs-string">'dojo/errors/create'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([<span class="hljs-string">'../_base/lang'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(lang)</span> {</span>
				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, ctor, base, props)</span> {</span>
					base = base || <span class="hljs-built_in">Error</span>;
					<span class="hljs-keyword">var</span> ErrorCtor = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(message)</span> {</span>
						<span class="hljs-keyword">if</span> (base === <span class="hljs-built_in">Error</span>) {
							<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Error</span>.captureStackTrace) {
								<span class="hljs-built_in">Error</span>.captureStackTrace(<span class="hljs-keyword">this</span>, ErrorCtor);
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-1004">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1004">&#182;</a>
              </div>
              <p>Error.call() operates on the returned error
object rather than operating on |this|</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> err = <span class="hljs-built_in">Error</span>.call(<span class="hljs-keyword">this</span>, message),
								prop;</pre></div></div>
            
        </li>
        
        
        <li id="section-1005">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1005">&#182;</a>
              </div>
              <p>Copy own properties from err to |this|</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> err) {
								<span class="hljs-keyword">if</span> (err.hasOwnProperty(prop)) {
									<span class="hljs-keyword">this</span>[prop] = err[prop];
								}
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-1006">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1006">&#182;</a>
              </div>
              <p>messsage is non-enumerable in ES5</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">this</span>.message = message;</pre></div></div>
            
        </li>
        
        
        <li id="section-1007">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1007">&#182;</a>
              </div>
              <p>stack is non-enumerable in at least Firefox</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">this</span>.stack = err.stack;
						} <span class="hljs-keyword">else</span> {
							base.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
						}
						<span class="hljs-keyword">if</span> (ctor) {
							ctor.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
						}
					};
					ErrorCtor.prototype = lang.delegate(base.prototype, props);
					ErrorCtor.prototype.name = name;
					ErrorCtor.prototype.constructor = ErrorCtor;
					<span class="hljs-keyword">return</span> ErrorCtor;
				};
			});
		},
		<span class="hljs-string">'dojo/_base/array'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'../has'</span>,
				<span class="hljs-string">'./lang'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, has, lang)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1008">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1008">&#182;</a>
              </div>
              <p>module:
    dojo/_base/array
our old simple function builder stuff</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> cache = {}, u;

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildFn</span><span class="hljs-params">(fn)</span> {</span>
					<span class="hljs-keyword">return</span> cache[fn] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'item'</span>, <span class="hljs-string">'index'</span>, <span class="hljs-string">'array'</span>, fn); <span class="hljs-comment">// Function</span>
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-1009">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1009">&#182;</a>
              </div>
              <p>magic snippet: if(typeof fn == “string”) fn = cache[fn] || buildFn(fn);
every &amp; some</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">everyOrSome</span><span class="hljs-params">(some)</span> {</span>
					<span class="hljs-keyword">var</span> every = !some;
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, fn, o)</span> {</span>
						<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
							l = a &amp;&amp; a.length || <span class="hljs-number">0</span>,
							result;
						<span class="hljs-keyword">if</span> (l &amp;&amp; <span class="hljs-keyword">typeof</span> a === <span class="hljs-string">'string'</span>) {
							a = a.split(<span class="hljs-string">''</span>);
						}
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">'string'</span>) {
							fn = cache[fn] || buildFn(fn);
						}
						<span class="hljs-keyword">if</span> (o) {
							<span class="hljs-keyword">for</span> (; i &lt; l; ++i) {
								result = !fn.call(o, a[i], i, a);
								<span class="hljs-keyword">if</span> (some ^ result) {
									<span class="hljs-keyword">return</span> !result;
								}
							}
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">for</span> (; i &lt; l; ++i) {
								result = !fn(a[i], i, a);
								<span class="hljs-keyword">if</span> (some ^ result) {
									<span class="hljs-keyword">return</span> !result;
								}
							}
						}
						<span class="hljs-keyword">return</span> every; <span class="hljs-comment">// Boolean</span>
					};
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-1010">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1010">&#182;</a>
              </div>
              <p>indexOf, lastIndexOf</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span><span class="hljs-params">(up)</span> {</span>
					<span class="hljs-keyword">var</span> delta = <span class="hljs-number">1</span>,
						lOver = <span class="hljs-number">0</span>,
						uOver = <span class="hljs-number">0</span>;
					<span class="hljs-keyword">if</span> (!up) {
						delta = lOver = uOver = -<span class="hljs-number">1</span>;
					}
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, x, from, last)</span> {</span>
						<span class="hljs-keyword">if</span> (last &amp;&amp; delta &gt; <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1011">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1011">&#182;</a>
              </div>
              <p>TODO: why do we use a non-standard signature? why do we need “last”?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> array.lastIndexOf(a, x, from);
						}
						<span class="hljs-keyword">var</span> l = a &amp;&amp; a.length || <span class="hljs-number">0</span>,
							end = up ? l + uOver : lOver,
							i;
						<span class="hljs-keyword">if</span> (from === u) {
							i = up ? lOver : l + uOver;
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">if</span> (from &lt; <span class="hljs-number">0</span>) {
								i = l + from;
								<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) {
									i = lOver;
								}
							} <span class="hljs-keyword">else</span> {
								i = from &gt;= l ? l + uOver : from;
							}
						}
						<span class="hljs-keyword">if</span> (l &amp;&amp; <span class="hljs-keyword">typeof</span> a === <span class="hljs-string">'string'</span>) {
							a = a.split(<span class="hljs-string">''</span>);
						}
						<span class="hljs-keyword">for</span> (; i !== end; i += delta) {
							<span class="hljs-keyword">if</span> (a[i] === x) {
								<span class="hljs-keyword">return</span> i; <span class="hljs-comment">// Number</span>
							}
						}
						<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// Number</span>
					};
				}
				<span class="hljs-keyword">var</span> array = {
					every: everyOrSome(<span class="hljs-literal">false</span>),
					some: everyOrSome(<span class="hljs-literal">true</span>),
					indexOf: index(<span class="hljs-literal">true</span>),
					lastIndexOf: index(<span class="hljs-literal">false</span>),
					forEach: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr, callback, thisObject)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1012">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1012">&#182;</a>
              </div>
              <p>summary:
    for every item in arr, callback is invoked. Return values are ignored.
    If you want to break out of the loop, consider using array.every() or array.some().
    forEach does not allow breaking out of the loop over the items in arr.
arr:
    the array to iterate over. If a string, operates on individual characters.
callback:
    a function is invoked with three arguments: item, index, and array
thisObject:
    may be used to scope the call to callback
description:
    This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
    run over sparse arrays, this implementation passes the “holes” in the sparse array to
    the callback function with a value of undefined. JavaScript 1.6’s forEach skips the holes in the sparse array.
    For more details, see:
    <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach</a>
example:
| // log out all members of the array:
| array.forEach(
|        [ “thinger”, “blah”, “howdy”, 10 ],
|        function(item){
|            console.log(item);
|        }
| );
example:
| // log out the members and their indexes
| array.forEach(
|        [ “thinger”, “blah”, “howdy”, 10 ],
|        function(item, idx, arr){
|            console.log(item, “at index:”, idx);
|        }
| );
example:
| // use a scoped object member as the callback
|
| var obj = {
|        prefix: “logged via obj.callback:”,
|        callback: function(item){
|            console.log(this.prefix, item);
|        }
| };
|
| // specifying the scope function executes the callback in that scope
| array.forEach(
|        [ “thinger”, “blah”, “howdy”, 10 ],
|        obj.callback,
|        obj
| );
|
| // alternately, we can accomplish the same thing with lang.hitch()
| array.forEach(
|        [ “thinger”, “blah”, “howdy”, 10 ],
|        lang.hitch(obj, “callback”)
| );
arr: Array|String
callback: Function|String
thisObject: Object?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
							l = arr &amp;&amp; arr.length || <span class="hljs-number">0</span>;
						<span class="hljs-keyword">if</span> (l &amp;&amp; <span class="hljs-keyword">typeof</span> arr === <span class="hljs-string">'string'</span>) {
							arr = arr.split(<span class="hljs-string">''</span>);
						}
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'string'</span>) {
							callback = cache[callback] || buildFn(callback);
						}
						<span class="hljs-keyword">if</span> (thisObject) {
							<span class="hljs-keyword">for</span> (; i &lt; l; ++i) {
								callback.call(thisObject, arr[i], i, arr);
							}
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">for</span> (; i &lt; l; ++i) {
								callback(arr[i], i, arr);
							}
						}
					},
					map: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr, callback, thisObject, Ctr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1013">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1013">&#182;</a>
              </div>
              <p>summary:
    applies callback to each element of arr and returns
    an Array with the results
arr: Array|String
    the array to iterate on. If a string, operates on
    individual characters.
callback: Function|String
    a function is invoked with three arguments, (item, index,
    array),     and returns a value
thisObject: Object?
    may be used to scope the call to callback
returns: Array
description:
    This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
    run over sparse arrays, this implementation passes the “holes” in the sparse array to
    the callback function with a value of undefined. JavaScript 1.6’s map skips the holes in the sparse array.
    For more details, see:
    <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map</a>
example:
| // returns [2, 3, 4, 5]
| array.map([1, 2, 3, 4], function(item){ return item+1 });
TODO: why do we have a non-standard signature here? do we need “Ctr”?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
							l = arr &amp;&amp; arr.length || <span class="hljs-number">0</span>,
							out = <span class="hljs-keyword">new</span>(Ctr || <span class="hljs-built_in">Array</span>)(l);
						<span class="hljs-keyword">if</span> (l &amp;&amp; <span class="hljs-keyword">typeof</span> arr === <span class="hljs-string">'string'</span>) {
							arr = arr.split(<span class="hljs-string">''</span>);
						}
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'string'</span>) {
							callback = cache[callback] || buildFn(callback);
						}
						<span class="hljs-keyword">if</span> (thisObject) {
							<span class="hljs-keyword">for</span> (; i &lt; l; ++i) {
								out[i] = callback.call(thisObject, arr[i], i, arr);
							}
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">for</span> (; i &lt; l; ++i) {
								out[i] = callback(arr[i], i, arr);
							}
						}
						<span class="hljs-keyword">return</span> out; <span class="hljs-comment">// Array</span>
					},
					filter: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr, callback, thisObject)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1014">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1014">&#182;</a>
              </div>
              <p>summary:
    Returns a new Array with those items from arr that match the
    condition implemented by callback.
arr: Array
    the array to iterate over.
callback: Function|String
    a function that is invoked with three arguments (item,
    index, array). The return of this function is expected to
    be a boolean which determines whether the passed-in item
    will be included in the returned array.
thisObject: Object?
    may be used to scope the call to callback
returns: Array
description:
    This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
    run over sparse arrays, this implementation passes the “holes” in the sparse array to
    the callback function with a value of undefined. JavaScript 1.6’s filter skips the holes in the sparse array.
    For more details, see:
    <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter</a>
example:
| // returns [2, 3, 4]
| array.filter([1, 2, 3, 4], function(item){ return item&gt;1; });
TODO: do we need “Ctr” here like in map()?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
							l = arr &amp;&amp; arr.length || <span class="hljs-number">0</span>,
							out = [],
							value;
						<span class="hljs-keyword">if</span> (l &amp;&amp; <span class="hljs-keyword">typeof</span> arr === <span class="hljs-string">'string'</span>) {
							arr = arr.split(<span class="hljs-string">''</span>);
						}
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'string'</span>) {
							callback = cache[callback] || buildFn(callback);
						}
						<span class="hljs-keyword">if</span> (thisObject) {
							<span class="hljs-keyword">for</span> (; i &lt; l; ++i) {
								value = arr[i];
								<span class="hljs-keyword">if</span> (callback.call(thisObject, value, i, arr)) {
									out.push(value);
								}
							}
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">for</span> (; i &lt; l; ++i) {
								value = arr[i];
								<span class="hljs-keyword">if</span> (callback(value, i, arr)) {
									out.push(value);
								}
							}
						}
						<span class="hljs-keyword">return</span> out; <span class="hljs-comment">// Array</span>
					},
					clearCache: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						cache = {};
					}
				};
				<span class="hljs-number">1</span> &amp;&amp; lang.mixin(dojo, array);
				<span class="hljs-keyword">return</span> array;
			});
		},
		<span class="hljs-string">'dojo/_base/json'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'../json'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, json)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1015">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1015">&#182;</a>
              </div>
              <p>module:
    dojo/_base/json</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             return {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1016">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1016">&#182;</a>
              </div>
              <p>summary:
    This module defines the dojo JSON API.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				dojo.fromJson = function (js) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1017">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1017">&#182;</a>
              </div>
              <p>summary:
    Parses a JavaScript expression and returns a JavaScript value.
description:
    Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
    always delegates to eval(). The content passed to this method must therefore come
    from a trusted source.
    It is recommend that you use dojo/json’s parse function for an
    implementation uses the (faster) native JSON parse when available.
js:
    a string literal of a JavaScript expression, for instance:
    <code>&#39;{ &quot;foo&quot;: [ &quot;bar&quot;, 1, { &quot;baz&quot;: &quot;thud&quot; } ] }&#39;</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">'('</span> + js + <span class="hljs-string">')'</span>); <span class="hljs-comment">// Object</span>
				};
				<span class="hljs-comment">/*=====
             dojo._escapeString = function(){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1018">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1018">&#182;</a>
              </div>
              <p>summary:
    Adds escape sequences for non-visual characters, double quote and
    backslash and surrounds with double quotes to form a valid string
    literal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				dojo._escapeString = json.stringify;</pre></div></div>
            
        </li>
        
        
        <li id="section-1019">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1019">&#182;</a>
              </div>
              <p>just delegate to json.stringify</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dojo.toJsonIndentStr = <span class="hljs-string">'\t'</span>;
				dojo.toJson = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(it, prettyPrint)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1020">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1020">&#182;</a>
              </div>
              <p>summary:
    Returns a <a href="http://json.org">JSON</a> serialization of an object.
description:
    Returns a <a href="http://json.org">JSON</a> serialization of an object.
    Note that this doesn’t check for infinite recursion, so don’t do that!
    It is recommend that you use dojo/json’s stringify function for an lighter
    and faster implementation that matches the native JSON API and uses the
    native JSON serializer when available.
it:
    an object to be serialized. Objects may define their own
    serialization via a special “<strong>json</strong>“ or “json” function
    property. If a specialized serializer has been defined, it will
    be used as a fallback.
    Note that in 1.6, toJson would serialize undefined, but this no longer supported
    since it is not supported by native JSON serializer.
prettyPrint:
    if true, we indent objects and arrays to make the output prettier.
    The variable <code>dojo.toJsonIndentStr</code> is used as the indent string —
    to use something other than the default (tab), change that variable
    before calling dojo.toJson().
    Note that if native JSON support is available, it will be used for serialization,
    and native implementations vary on the exact spacing used in pretty printing.
returns:
    A JSON string serialization of the passed-in object.
example:
    simple serialization of a trivial object
    |    var jsonStr = dojo.toJson({ howdy: “stranger!”, isStrange: true });
    |    doh.is(‘{“howdy”:”stranger!”,”isStrange”:true}’, jsonStr);
example:
    a custom serializer for an objects of a particular class:
    |    dojo.declare(“Furby”, null, {
    |        furbies: “are strange”,
    |        furbyCount: 10,
    |        <strong>json</strong>: function(){
    |        },
    |    });
use dojo/json</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> json.stringify(it, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, value)</span> {</span>
						<span class="hljs-keyword">if</span> (value) {
							<span class="hljs-keyword">var</span> tf = value.__json__ || value.json;
							<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tf === <span class="hljs-string">'function'</span>) {
								<span class="hljs-keyword">return</span> tf.call(value);
							}
						}
						<span class="hljs-keyword">return</span> value;
					}, prettyPrint &amp;&amp; dojo.toJsonIndentStr); <span class="hljs-comment">// String</span>
				};
				<span class="hljs-keyword">return</span> dojo;
			});
		},
		<span class="hljs-string">'dojo/_base/window'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/_base/window'</span>, [
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'./lang'</span>,
				<span class="hljs-string">'../sniff'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, lang, has)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1021">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1021">&#182;</a>
              </div>
              <p>module:
    dojo/_base/window</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> ret = {
					global: dojo.global,
					doc: <span class="hljs-keyword">this</span>.document || <span class="hljs-literal">null</span>,
					body: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(doc)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1022">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1022">&#182;</a>
              </div>
              <p>summary:
    Return the body element of the specified document or of dojo/_base/window::doc.
example:
|    win.body().appendChild(dojo.doc.createElement(‘div’));
Note: document.body is not defined for a strict xhtml document
Would like to memoize this, but dojo.doc can change vi dojo.withDoc().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						doc = doc || dojo.doc;
						<span class="hljs-keyword">return</span> doc.body || doc.getElementsByTagName(<span class="hljs-string">'body'</span>)[<span class="hljs-number">0</span>]; <span class="hljs-comment">// Node</span>
					},
					setContext: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(globalObject, globalDocument)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1023">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1023">&#182;</a>
              </div>
              <p>summary:
    changes the behavior of many core Dojo functions that deal with
    namespace and DOM lookup, changing them to work in a new global
    context (e.g., an iframe). The varibles dojo.global and dojo.doc
    are modified as a result of calling this function and the result of
    <code>dojo.body()</code> likewise differs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						dojo.global = ret.global = globalObject;
						dojo.doc = ret.doc = globalDocument;
					},
					withGlobal: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(globalObject, callback, thisObject, cbArguments)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1024">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1024">&#182;</a>
              </div>
              <p>summary:
    Invoke callback with globalObject as dojo.global and
    globalObject.document as dojo.doc.
description:
    Invoke callback with globalObject as dojo.global and
    globalObject.document as dojo.doc. If provided, globalObject
    will be executed in the context of object thisObject
    When callback() returns or throws an error, the dojo.global
    and dojo.doc will be restored to its previous state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> oldGlob = dojo.global;
						<span class="hljs-keyword">try</span> {
							dojo.global = ret.global = globalObject;
							<span class="hljs-keyword">return</span> ret.withDoc.call(<span class="hljs-literal">null</span>, globalObject.document, callback, thisObject, cbArguments);
						} <span class="hljs-keyword">finally</span> {
							dojo.global = ret.global = oldGlob;
						}
					},
					withDoc: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(documentObject, callback, thisObject, cbArguments)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1025">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1025">&#182;</a>
              </div>
              <p>summary:
    Invoke callback with documentObject as dojo/_base/window::doc.
description:
    Invoke callback with documentObject as dojo/_base/window::doc. If provided,
    callback will be executed in the context of object thisObject
    When callback() returns or throws an error, the dojo/_base/window::doc will
    be restored to its previous state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> oldDoc = ret.doc,
							oldQ = has(<span class="hljs-string">'quirks'</span>),
							oldIE = has(<span class="hljs-string">'ie'</span>),
							isIE, mode, pwin;
						<span class="hljs-keyword">try</span> {
							dojo.doc = ret.doc = documentObject;</pre></div></div>
            
        </li>
        
        
        <li id="section-1026">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1026">&#182;</a>
              </div>
              <p>update dojo.isQuirks and the value of the has feature “quirks”.
remove setting dojo.isQuirks and dojo.isIE for 2.0</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							dojo.isQuirks = has.add(<span class="hljs-string">'quirks'</span>, dojo.doc.compatMode === <span class="hljs-string">'BackCompat'</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1027">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1027">&#182;</a>
              </div>
              <p>no need to check for QuirksMode which was Opera 7 only</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>)) {
								<span class="hljs-keyword">if</span> ((pwin = documentObject.parentWindow) &amp;&amp; pwin.navigator) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1028">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1028">&#182;</a>
              </div>
              <p>re-run IE detection logic and update dojo.isIE / has(“ie”)
(the only time parentWindow/navigator wouldn’t exist is if we were not
passed an actual legitimate document object)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									isIE = <span class="hljs-built_in">parseFloat</span>(pwin.navigator.appVersion.split(<span class="hljs-string">'MSIE '</span>)[<span class="hljs-number">1</span>]) || <span class="hljs-literal">undefined</span>;
									mode = documentObject.documentMode;
									<span class="hljs-keyword">if</span> (mode &amp;&amp; mode !== <span class="hljs-number">5</span> &amp;&amp; <span class="hljs-built_in">Math</span>.floor(isIE) !== mode) {
										isIE = mode;
									}
									dojo.isIE = has.add(<span class="hljs-string">'ie'</span>, isIE, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
								}
							}
							<span class="hljs-keyword">if</span> (thisObject &amp;&amp; <span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'string'</span>) {
								callback = thisObject[callback];
							}
							<span class="hljs-keyword">return</span> callback.apply(thisObject, cbArguments || []);
						} <span class="hljs-keyword">finally</span> {
							dojo.doc = ret.doc = oldDoc;
							dojo.isQuirks = has.add(<span class="hljs-string">'quirks'</span>, oldQ, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
							dojo.isIE = has.add(<span class="hljs-string">'ie'</span>, oldIE, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
						}
					}
				};
				<span class="hljs-number">1</span> &amp;&amp; lang.mixin(dojo, ret);
				<span class="hljs-keyword">return</span> ret;
			});
		},
		<span class="hljs-string">'dojo/dom-class'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./_base/lang'</span>,
				<span class="hljs-string">'./_base/array'</span>,
				<span class="hljs-string">'./dom'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(lang, array, dom)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1029">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1029">&#182;</a>
              </div>
              <p>module:
    dojo/dom-class</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> className = <span class="hljs-string">'className'</span>;
				<span class="hljs-comment">/* Part I of classList-based implementation is preserved here for posterity
             var classList = "classList";
             has.add("dom-classList", function(){
             return classList in document.createElement("p");
             });
             */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1030">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1030">&#182;</a>
              </div>
              <p>=============================</p>

            </div>
            
        </li>
        
        
        <li id="section-1031">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1031">&#182;</a>
              </div>
              <h1 id="-css-class-functions">(CSS) Class Functions</h1>

            </div>
            
        </li>
        
        
        <li id="section-1032">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1032">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> cls,</pre></div></div>
            
        </li>
        
        
        <li id="section-1033">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1033">&#182;</a>
              </div>
              <p>exports object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					spaces = <span class="hljs-regexp">/\s+/</span>,
					a1 = [<span class="hljs-string">''</span>];

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">str2array</span><span class="hljs-params">(s)</span> {</span>
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> s === <span class="hljs-string">'string'</span> || s <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>) {
						<span class="hljs-keyword">if</span> (s &amp;&amp; !spaces.test(s)) {
							a1[<span class="hljs-number">0</span>] = s;
							<span class="hljs-keyword">return</span> a1;
						}
						<span class="hljs-keyword">var</span> a = s.split(spaces);
						<span class="hljs-keyword">if</span> (a.length &amp;&amp; !a[<span class="hljs-number">0</span>]) {
							a.shift();
						}
						<span class="hljs-keyword">if</span> (a.length &amp;&amp; !a[a.length - <span class="hljs-number">1</span>]) {
							a.pop();
						}
						<span class="hljs-keyword">return</span> a;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-1034">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1034">&#182;</a>
              </div>
              <p>assumed to be an array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!s) {
						<span class="hljs-keyword">return</span> [];
					}
					<span class="hljs-keyword">return</span> array.filter(s, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span> {</span>
						<span class="hljs-keyword">return</span> x;
					});
				}
				<span class="hljs-comment">/* Part II of classList-based implementation is preserved here for posterity
             if(has("dom-classList")){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1035">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1035">&#182;</a>
              </div>
              <p>new classList version</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             cls = {
             contains: function containsClass(node, classStr){
             var clslst = classStr &amp;&amp; dom.byId(node)[classList];
             return clslst &amp;&amp; clslst.contains(classStr); // Boolean
             },

             add: function addClass(node, classStr){
             node = dom.byId(node);
             classStr = str2array(classStr);
             for(var i = 0, len = classStr.length; i &lt; len; ++i){
             node[classList].add(classStr[i]);
             }
             },

             remove: function removeClass(node, classStr){
             node = dom.byId(node);
             if(classStr === undefined){
             node[className] = "";
             }else{
             classStr = str2array(classStr);
             for(var i = 0, len = classStr.length; i &lt; len; ++i){
             node[classList].remove(classStr[i]);
             }
             }
             },

             replace: function replaceClass(node, addClassStr, removeClassStr){
             node = dom.byId(node);
             if(removeClassStr === undefined){
             node[className] = "";
             }else{
             removeClassStr = str2array(removeClassStr);
             for(var i = 0, len = removeClassStr.length; i &lt; len; ++i){
             node[classList].remove(removeClassStr[i]);
             }
             }
             addClassStr = str2array(addClassStr);
             for(i = 0, len = addClassStr.length; i &lt; len; ++i){
             node[classList].add(addClassStr[i]);
             }
             },

             toggle: function toggleClass(node, classStr, condition){
             node = dom.byId(node);
             if(condition === undefined){
             classStr = str2array(classStr);
             for(var i = 0, len = classStr.length; i &lt; len; ++i){
             node[classList].toggle(classStr[i]);
             }
             }else{
             cls[condition ? "add" : "remove"](node, classStr);
             }
             return condition;   // Boolean
             }
             }
             }
             */</pre></div></div>
            
        </li>
        
        
        <li id="section-1036">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1036">&#182;</a>
              </div>
              <p>regular DOM version</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> fakeNode = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-1037">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1037">&#182;</a>
              </div>
              <p>for effective replacement</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				cls = {
					contains: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">containsClass</span><span class="hljs-params">(node, classStr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1038">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1038">&#182;</a>
              </div>
              <p>summary:
    Returns whether or not the specified classes are a portion of the
    class list currently applied to the node.
node: String|DOMNode
    String ID or DomNode reference to check the class for.
classStr: String
    A string class name to look for.
example:
    Do something if a node with id=”someNode” has class=”aSillyClassName” present
|    if(dojo.hasClass(“someNode”,”aSillyClassName”)){ … }</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> (<span class="hljs-string">' '</span> + dom.byId(node)[className] + <span class="hljs-string">' '</span>)
							.indexOf(<span class="hljs-string">' '</span> + classStr + <span class="hljs-string">' '</span>) &gt;= <span class="hljs-number">0</span>; <span class="hljs-comment">// Boolean</span>
					},
					add: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addClass</span><span class="hljs-params">(node, classStr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1039">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1039">&#182;</a>
              </div>
              <p>summary:
    Adds the specified classes to the end of the class list on the
    passed node. Will not re-apply duplicate classes.</p>
<p>node: String|DOMNode
    String ID or DomNode reference to add a class string too</p>
<p>classStr: String|Array
    A String class name to add, or several space-separated class names,
    or an array of class names.</p>
<p>example:
    Add a class to some node:
|    require([“dojo/dom-class”], function(domClass){
|        domClass.add(“someNode”, “anewClass”);
|    });</p>
<p>example:
    Add two classes at once:
|    require([“dojo/dom-class”], function(domClass){
|        domClass.add(“someNode”, “firstClass secondClass”);
|    });</p>
<p>example:
    Add two classes at once (using array):
|    require([“dojo/dom-class”], function(domClass){
|        domClass.add(“someNode”, [“firstClass”, “secondClass”]);
|    });</p>
<p>example:
    Available in <code>dojo/NodeList</code> for multiple additions
|    require([“dojo/query”], function(query){
|        query(“ul &gt; li”).addClass(“firstLevel”);
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						node = dom.byId(node);
						classStr = str2array(classStr);
						<span class="hljs-keyword">var</span> cls = node[className],
							oldLen;
						cls = cls ? <span class="hljs-string">' '</span> + cls + <span class="hljs-string">' '</span> : <span class="hljs-string">' '</span>;
						oldLen = cls.length;
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = classStr.length, c; i &lt; len; ++i) {
							c = classStr[i];
							<span class="hljs-keyword">if</span> (c &amp;&amp; cls.indexOf(<span class="hljs-string">' '</span> + c + <span class="hljs-string">' '</span>) &lt; <span class="hljs-number">0</span>) {
								cls += c + <span class="hljs-string">' '</span>;
							}
						}
						<span class="hljs-keyword">if</span> (oldLen &lt; cls.length) {
							node[className] = cls.substr(<span class="hljs-number">1</span>, cls.length - <span class="hljs-number">2</span>);
						}
					},
					remove: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeClass</span><span class="hljs-params">(node, classStr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1040">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1040">&#182;</a>
              </div>
              <p>summary:
    Removes the specified classes from node. No <code>contains()</code>
    check is required.</p>
<p>node: String|DOMNode
    String ID or DomNode reference to remove the class from.</p>
<p>classStr: String|Array
    An optional String class name to remove, or several space-separated
    class names, or an array of class names. If omitted, all class names
    will be deleted.</p>
<p>example:
    Remove a class from some node:
|    require([“dojo/dom-class”], function(domClass){
|        domClass.remove(“someNode”, “firstClass”);
|    });</p>
<p>example:
    Remove two classes from some node:
|    require([“dojo/dom-class”], function(domClass){
|        domClass.remove(“someNode”, “firstClass secondClass”);
|    });</p>
<p>example:
    Remove two classes from some node (using array):
|    require([“dojo/dom-class”], function(domClass){
|        domClass.remove(“someNode”, [“firstClass”, “secondClass”]);
|    });</p>
<p>example:
    Remove all classes from some node:
|    require([“dojo/dom-class”], function(domClass){
|        domClass.remove(“someNode”);
|    });</p>
<p>example:
    Available in <code>dojo/NodeList</code> for multiple removal
|    require([“dojo/query”], function(query){
|        query(“ul &gt; li”).removeClass(“foo”);
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						node = dom.byId(node);
						<span class="hljs-keyword">var</span> cls;
						<span class="hljs-keyword">if</span> (classStr !== <span class="hljs-literal">undefined</span>) {
							classStr = str2array(classStr);
							cls = <span class="hljs-string">' '</span> + node[className] + <span class="hljs-string">' '</span>;
							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = classStr.length; i &lt; len; ++i) {
								cls = cls.replace(<span class="hljs-string">' '</span> + classStr[i] + <span class="hljs-string">' '</span>, <span class="hljs-string">' '</span>);
							}
							cls = lang.trim(cls);
						} <span class="hljs-keyword">else</span> {
							cls = <span class="hljs-string">''</span>;
						}
						<span class="hljs-keyword">if</span> (node[className] !== cls) {
							node[className] = cls;
						}
					},
					replace: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceClass</span><span class="hljs-params">(node, addClassStr, removeClassStr)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1041">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1041">&#182;</a>
              </div>
              <p>summary:
    Replaces one or more classes on a node if not present.
    Operates more quickly than calling dojo.removeClass and dojo.addClass</p>
<p>node: String|DOMNode
    String ID or DomNode reference to remove the class from.</p>
<p>addClassStr: String|Array
    A String class name to add, or several space-separated class names,
    or an array of class names.</p>
<p>removeClassStr: String|Array?
    A String class name to remove, or several space-separated class names,
    or an array of class names.</p>
<p>example:
|    require([“dojo/dom-class”], function(domClass){
|        domClass.replace(“someNode”, “add1 add2”, “remove1 remove2”);
|    });</p>
<p>example:
Replace all classes with addMe
|    require([“dojo/dom-class”], function(domClass){
|        domClass.replace(“someNode”, “addMe”);
|    });</p>
<p>example:
Available in <code>dojo/NodeList</code> for multiple toggles
|    require([“dojo/query”], function(query){
|        query(“.findMe”).replaceClass(“addMe”, “removeMe”);
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						node = dom.byId(node);
						fakeNode[className] = node[className];
						cls.remove(fakeNode, removeClassStr);
						cls.add(fakeNode, addClassStr);
						<span class="hljs-keyword">if</span> (node[className] !== fakeNode[className]) {
							node[className] = fakeNode[className];
						}
					},
					toggle: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleClass</span><span class="hljs-params">(node, classStr, condition)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1042">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1042">&#182;</a>
              </div>
              <p>summary:
    Adds a class to node if not present, or removes if present.
    Pass a boolean condition if you want to explicitly add or remove.
    Returns the condition that was specified directly or indirectly.</p>
<p>node: String|DOMNode
    String ID or DomNode reference to toggle a class string</p>
<p>classStr: String|Array
    A String class name to toggle, or several space-separated class names,
    or an array of class names.</p>
<p>condition:
    If passed, true means to add the class, false means to remove.
    Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.</p>
<p>example:
|    require([“dojo/dom-class”], function(domClass){
|        domClass.toggle(“someNode”, “hovered”);
|    });</p>
<p>example:
    Forcefully add a class
|    require([“dojo/dom-class”], function(domClass){
|        domClass.toggle(“someNode”, “hovered”, true);
|    });</p>
<p>example:
    Available in <code>dojo/NodeList</code> for multiple toggles
|    require([“dojo/query”], function(query){
|        query(“.toggleMe”).toggleClass(“toggleMe”);
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						node = dom.byId(node);
						<span class="hljs-keyword">if</span> (condition === <span class="hljs-literal">undefined</span>) {
							classStr = str2array(classStr);
							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = classStr.length, c; i &lt; len; ++i) {
								c = classStr[i];
								cls[cls.contains(node, c) ? <span class="hljs-string">'remove'</span> : <span class="hljs-string">'add'</span>](node, c);
							}
						} <span class="hljs-keyword">else</span> {
							cls[condition ? <span class="hljs-string">'add'</span> : <span class="hljs-string">'remove'</span>](node, classStr);
						}
						<span class="hljs-keyword">return</span> condition; <span class="hljs-comment">// Boolean</span>
					}
				};
				<span class="hljs-keyword">return</span> cls;
			});
		},
		<span class="hljs-string">'dojo/_base/config'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'../has'</span>,
				<span class="hljs-string">'require'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(has, require)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1043">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1043">&#182;</a>
              </div>
              <p>module:
    dojo/_base/config</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             return {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1044">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1044">&#182;</a>
              </div>
              <p>summary:
    This module defines the user configuration during bootstrap.
description:
    By defining user configuration as a module value, an entire configuration can be specified in a build,
    thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
    Also, when multiple instances of dojo exist in a single application, each will necessarily be located
    at an unique absolute module identifier as given by the package configuration. Implementing configuration
    as a module allows for specifying unique, per-instance configurations.
example:
    Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
    dojo.js are already loaded).
    |    // specify a configuration that creates a new instance of dojo at the absolute module identifier “myDojo”
    |    require({
    |        packages:[{
    |            name:”myDojo”,
    |            location:”.”, //assume baseUrl points to dojo.js
    |        }]
    |    });
    |
    |    // specify a configuration for the myDojo instance
    |    define(“myDojo/config”, {
    |        // normal configuration variables go here, e.g.,
    |        locale:”fr-ca”
    |    });
    |
    |    // load and use the new instance of dojo
    |    require([“myDojo”], function(dojo){
    |        // dojo is the new instance of dojo
    |        // use as required
    |    });</p>

            </div>
            
        </li>
        
        
        <li id="section-1045">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1045">&#182;</a>
              </div>
              <p>isDebug: Boolean
    Defaults to <code>false</code>. If set to <code>true</code>, ensures that Dojo provides
    extended debugging feedback via Firebug. If Firebug is not available
    on your platform, setting <code>isDebug</code> to <code>true</code> will force Dojo to
    pull in (and display) the version of Firebug Lite which is
    integrated into the Dojo distribution, thereby always providing a
    debugging/logging console when <code>isDebug</code> is enabled. Note that
    Firebug’s <code>console.*</code> methods are ALWAYS defined by Dojo. If
    <code>isDebug</code> is false and you are on a platform without Firebug, these
    methods will be defined as no-ops.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             isDebug: <span class="hljs-literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1046">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1046">&#182;</a>
              </div>
              <p>locale: String
    The locale to assume for loading localized resources in this page,
    specified according to <a href="http://www.ietf.org/rfc/rfc3066.txt">RFC 3066</a>.
    Must be specified entirely in lowercase, e.g. <code>en-us</code> and <code>zh-cn</code>.
    See the documentation for <code>dojo.i18n</code> and <code>dojo.requireLocalization</code>
    for details on loading localized resources. If no locale is specified,
    Dojo assumes the locale of the user agent, according to <code>navigator.userLanguage</code>
    or <code>navigator.language</code> properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             locale: <span class="hljs-literal">undefined</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1047">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1047">&#182;</a>
              </div>
              <p>extraLocale: Array
    No default value. Specifies additional locales whose
    resources should also be loaded alongside the default locale when
    calls to <code>dojo.requireLocalization()</code> are processed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             extraLocale: <span class="hljs-literal">undefined</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1048">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1048">&#182;</a>
              </div>
              <p>baseUrl: String
    The directory in which <code>dojo.js</code> is located. Under normal
    conditions, Dojo auto-detects the correct location from which it
    was loaded. You may need to manually configure <code>baseUrl</code> in cases
    where you have renamed <code>dojo.js</code> or in which <code>&lt;base&gt;</code> tags confuse
    some browsers (e.g. IE 6). The variable <code>dojo.baseUrl</code> is assigned
    either the value of <code>djConfig.baseUrl</code> if one is provided or the
    auto-detected root if not. Other modules are located relative to
    this path. The path should end in a slash.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             baseUrl: <span class="hljs-literal">undefined</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1049">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1049">&#182;</a>
              </div>
              <p>modulePaths: [deprecated] Object
    A map of module names to paths relative to <code>dojo.baseUrl</code>. The
    key/value pairs correspond directly to the arguments which
    <code>dojo.registerModulePath</code> accepts. Specifying
    <code>djConfig.modulePaths = { &quot;foo&quot;: &quot;../../bar&quot; }</code> is the equivalent
    of calling <code>dojo.registerModulePath(&quot;foo&quot;, &quot;../../bar&quot;);</code>. Multiple
    modules may be configured via <code>djConfig.modulePaths</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             modulePaths: {},</pre></div></div>
            
        </li>
        
        
        <li id="section-1050">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1050">&#182;</a>
              </div>
              <p>addOnLoad: Function|Array
    Adds a callback via dojo/ready. Useful when Dojo is added after
    the page loads and djConfig.afterOnLoad is true. Supports the same
    arguments as dojo/ready. When using a function reference, use
    <code>djConfig.addOnLoad = function(){};</code>. For object with function name use
    <code>djConfig.addOnLoad = [myObject, &quot;functionName&quot;];</code> and for object with
    function reference use
    <code>djConfig.addOnLoad = [myObject, function(){}];</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             addOnLoad: <span class="hljs-literal">null</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1051">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1051">&#182;</a>
              </div>
              <p>parseOnLoad: Boolean
    Run the parser after the page is loaded</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             parseOnLoad: <span class="hljs-literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1052">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1052">&#182;</a>
              </div>
              <p>require: String[]
    An array of module names to be loaded immediately after dojo.js has been included
    in a page.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             <span class="hljs-built_in">require</span>: [],</pre></div></div>
            
        </li>
        
        
        <li id="section-1053">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1053">&#182;</a>
              </div>
              <p>defaultDuration: Number
    Default duration, in milliseconds, for wipe and fade animations within dijits.
    Assigned to dijit.defaultDuration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             defaultDuration: <span class="hljs-number">200</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1054">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1054">&#182;</a>
              </div>
              <p>dojoBlankHtmlUrl: String
    Used by some modules to configure an empty iframe. Used by dojo/io/iframe and
    dojo/back, and dijit/popup support in IE where an iframe is needed to make sure native
    controls do not bleed through the popups. Normally this configuration variable
    does not need to be set, except when using cross-domain/CDN Dojo builds.
    Save dojo/resources/blank.html to your domain and set <code>djConfig.dojoBlankHtmlUrl</code>
    to the path on your domain your copy of blank.html.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             dojoBlankHtmlUrl: <span class="hljs-literal">undefined</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1055">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1055">&#182;</a>
              </div>
              <p>ioPublish: Boolean?
    Set this to true to enable publishing of topics for the different phases of
    IO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list
    of topics that are published.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             ioPublish: <span class="hljs-literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1056">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1056">&#182;</a>
              </div>
              <p>useCustomLogger: Anything?
    If set to a value that evaluates to true such as a string or array and
    isDebug is true and Firebug is not available or running, then it bypasses
    the creation of Firebug Lite allowing you to define your own console object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             useCustomLogger: <span class="hljs-literal">undefined</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1057">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1057">&#182;</a>
              </div>
              <p>transparentColor: Array
    Array containing the r, g, b components used as transparent color in dojo.Color;
    if undefined, [255,255,255] (white) will be used.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             transparentColor: <span class="hljs-literal">undefined</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1058">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1058">&#182;</a>
              </div>
              <p>deps: Function|Array
    Defines dependencies to be used before the loader has been loaded.
    When provided, they cause the loader to execute require(deps, callback) 
    once it has finished loading. Should be used with callback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             deps: <span class="hljs-literal">undefined</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1059">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1059">&#182;</a>
              </div>
              <p>callback: Function|Array
    Defines a callback to be used when dependencies are defined before 
    the loader has been loaded. When provided, they cause the loader to 
    execute require(deps, callback) once it has finished loading. 
    Should be used with deps.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             callback: <span class="hljs-literal">undefined</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1060">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1060">&#182;</a>
              </div>
              <p>deferredInstrumentation: Boolean
    Whether deferred instrumentation should be loaded or included
    in builds.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             deferredInstrumentation: <span class="hljs-literal">true</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1061">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1061">&#182;</a>
              </div>
              <p>useDeferredInstrumentation: Boolean|String
    Whether the deferred instrumentation should be used.</p>
<pre><code>* `<span class="hljs-string">"report-rejections"</span>`: report each rejection as it occurs.
* `<span class="hljs-literal">true</span>` or `<span class="hljs-number">1</span>` or `<span class="hljs-string">"report-unhandled-rejections"</span>`: wait <span class="hljs-number">1</span> second
    <span class="hljs-keyword">in</span> an attempt to detect unhandled rejections.
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>             useDeferredInstrumentation: "report-unhandled-rejections"
             };
             =====*/
				var result = {};
				if (1) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1062">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1062">&#182;</a>
              </div>
              <p>must be the dojo loader; take a shallow copy of require.rawConfig</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> src = <span class="hljs-built_in">require</span>.rawConfig,
						p;
					<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> src) {
						result[p] = src[p];
					}
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">var</span> adviseHas = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(featureSet, prefix, booting)</span> {</span>
						<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> featureSet) {
							p !== <span class="hljs-string">'has'</span> &amp;&amp; has.add(prefix + p, featureSet[p], <span class="hljs-number">0</span>, booting);
						}
					};
					result = <span class="hljs-number">1</span> ? <span class="hljs-built_in">require</span>.rawConfig : <span class="hljs-keyword">this</span>.dojoConfig || <span class="hljs-keyword">this</span>.djConfig || {};
					adviseHas(result, <span class="hljs-string">'config'</span>, <span class="hljs-number">1</span>);
					adviseHas(result.has, <span class="hljs-string">''</span>, <span class="hljs-number">1</span>);
				}
				<span class="hljs-keyword">return</span> result;
			});
		},
		<span class="hljs-string">'dojo/main'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./_base/kernel'</span>,
				<span class="hljs-string">'./has'</span>,
				<span class="hljs-string">'require'</span>,
				<span class="hljs-string">'./sniff'</span>,
				<span class="hljs-string">'./_base/lang'</span>,
				<span class="hljs-string">'./_base/array'</span>,
				<span class="hljs-string">'./_base/config'</span>,
				<span class="hljs-string">'./ready'</span>,
				<span class="hljs-string">'./_base/declare'</span>,
				<span class="hljs-string">'./_base/connect'</span>,
				<span class="hljs-string">'./_base/Deferred'</span>,
				<span class="hljs-string">'./_base/json'</span>,
				<span class="hljs-string">'./_base/Color'</span>,
				<span class="hljs-string">'./has!dojo-firebug?./_firebug/firebug'</span>,
				<span class="hljs-string">'./_base/browser'</span>,
				<span class="hljs-string">'./_base/loader'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(kernel, has, require, sniff, lang, array, config, ready)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1063">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1063">&#182;</a>
              </div>
              <p>module:
    dojo/main
summary:
    This is the package main module for the dojo package; it loads dojo base appropriate for the execution environment.
the preferred way to load the dojo firebug console is by setting has(“dojo-firebug”) true in dojoConfig
the isDebug config switch is for backcompat and will work fine in sync loading mode; it works in
async mode too, but there’s no guarantee when the module is loaded; therefore, if you need a firebug
console guaranteed at a particular spot in an app, either set config.has[“dojo-firebug”] true before
loading dojo.js or explicitly include dojo/_firebug/firebug in a dependency list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (config.isDebug) {
					<span class="hljs-built_in">require</span>([<span class="hljs-string">'./_firebug/firebug'</span>]);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-1064">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1064">&#182;</a>
              </div>
              <p>dojoConfig.require is deprecated; use the loader configuration property deps</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-number">1</span> || has.add(<span class="hljs-string">'dojo-config-require'</span>, <span class="hljs-number">1</span>);
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
					<span class="hljs-keyword">var</span> deps = config.require;
					<span class="hljs-keyword">if</span> (deps) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1065">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1065">&#182;</a>
              </div>
              <p>config.require may be dot notation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						deps = array.map(lang.isArray(deps) ? deps : [deps], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(item)</span> {</span>
							<span class="hljs-keyword">return</span> item.replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">'/'</span>);
						});
						<span class="hljs-keyword">if</span> (kernel.isAsync) {
							<span class="hljs-built_in">require</span>(deps);
						} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1066">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1066">&#182;</a>
              </div>
              <p>this is a bit janky; in 1.6- dojo is defined before these requires are applied; but in 1.7+
dojo isn’t defined until returning from this module; this is only a problem in sync mode
since we’re in sync mode, we know we’ve got our loader with its priority ready queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							ready(<span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								<span class="hljs-built_in">require</span>(deps);
							});
						}
					}
				}
				<span class="hljs-keyword">return</span> kernel;
			});
		},
		<span class="hljs-string">'dojo/_base/event'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/_base/event'</span>, [
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'../on'</span>,
				<span class="hljs-string">'../has'</span>,
				<span class="hljs-string">'../dom-geometry'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, on, has, dom)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1067">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1067">&#182;</a>
              </div>
              <p>module:
    dojo/_base/event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (on._fixEvent) {
					<span class="hljs-keyword">var</span> fixEvent = on._fixEvent;
					on._fixEvent = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt, se)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1068">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1068">&#182;</a>
              </div>
              <p>add some additional normalization for back-compat, this isn’t in on.js because it is somewhat more expensive</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						evt = fixEvent(evt, se);
						<span class="hljs-keyword">if</span> (evt) {
							dom.normalizeEvent(evt);
						}
						<span class="hljs-keyword">return</span> evt;
					};
				}
				<span class="hljs-keyword">var</span> ret = {
					fix: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt, sender)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1069">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1069">&#182;</a>
              </div>
              <p>summary:
    normalizes properties on the event object including event
    bubbling methods, keystroke normalization, and x/y positions
evt: Event
    native event object
sender: DOMNode
    node to treat as “currentTarget”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (on._fixEvent) {
							<span class="hljs-keyword">return</span> on._fixEvent(evt, sender);
						}
						<span class="hljs-keyword">return</span> evt; <span class="hljs-comment">// Event</span>
					},
					stop: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1070">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1070">&#182;</a>
              </div>
              <p>summary:
    prevents propagation and clobbers the default action of the
    passed event
evt: Event
    The event object. If omitted, window.event is used on IE.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'dom-addeventlistener'</span>) || evt &amp;&amp; evt.preventDefault) {
							evt.preventDefault();
							evt.stopPropagation();
						} <span class="hljs-keyword">else</span> {
							evt = evt || window.event;
							evt.cancelBubble = <span class="hljs-literal">true</span>;
							on._preventDefault.call(evt);
						}
					}
				};
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
					dojo.fixEvent = ret.fix;
					dojo.stopEvent = ret.stop;
				}
				<span class="hljs-keyword">return</span> ret;
			});
		},
		<span class="hljs-string">'dojo/sniff'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([<span class="hljs-string">'./has'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(has)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1071">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1071">&#182;</a>
              </div>
              <p>module:
    dojo/sniff</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             return function(){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1072">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1072">&#182;</a>
              </div>
              <p>summary:
    This module sets has() flags based on the current browser.
    It returns the has() function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				if (1) {
					var n = navigator,
						dua = n.userAgent,
						dav = n.appVersion,
						tv = parseFloat(dav);
					has.add('air', dua.indexOf('AdobeAIR') &gt;= 0), has.add('khtml', dav.indexOf('Konqueror') &gt;= 0 ? tv : undefined);
					has.add('webkit', parseFloat(dua.split('WebKit/')[1]) || undefined);
					has.add('chrome', parseFloat(dua.split('Chrome/')[1]) || undefined);
					has.add('safari', dav.indexOf('Safari') &gt;= 0 &amp;&amp; !has('chrome') ? parseFloat(dav.split('Version/')[1]) : undefined);
					has.add('mac', dav.indexOf('Macintosh') &gt;= 0);
					has.add('quirks', document.compatMode === 'BackCompat');
					has.add('ios', /iPhone|iPod|iPad/.test(dua));
					has.add('android', parseFloat(dua.split('Android ')[1]) || undefined);
					if (!has('webkit')) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1073">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1073">&#182;</a>
              </div>
              <p>Opera</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (dua.indexOf(<span class="hljs-string">'Opera'</span>) &gt;= <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1074">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1074">&#182;</a>
              </div>
              <p>see <a href="http://dev.opera.com/articles/view/opera-ua-string-changes">http://dev.opera.com/articles/view/opera-ua-string-changes</a> and <a href="http://www.useragentstring.com/pages/Opera/">http://www.useragentstring.com/pages/Opera/</a>
9.8 has both styles; &lt;9.8, 9.9 only old style</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							has.add(<span class="hljs-string">'opera'</span>, tv &gt;= <span class="hljs-number">9.8</span> ? <span class="hljs-built_in">parseFloat</span>(dua.split(<span class="hljs-string">'Version/'</span>)[<span class="hljs-number">1</span>]) || tv : tv);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-1075">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1075">&#182;</a>
              </div>
              <p>Mozilla and firefox</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (dua.indexOf(<span class="hljs-string">'Gecko'</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; !has(<span class="hljs-string">'khtml'</span>) &amp;&amp; !has(<span class="hljs-string">'webkit'</span>)) {
							has.add(<span class="hljs-string">'mozilla'</span>, tv);
						}
						<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'mozilla'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1076">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1076">&#182;</a>
              </div>
              <p>We really need to get away from this. Consider a sane isGecko approach for the future.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							has.add(<span class="hljs-string">'ff'</span>, <span class="hljs-built_in">parseFloat</span>(dua.split(<span class="hljs-string">'Firefox/'</span>)[<span class="hljs-number">1</span>] || dua.split(<span class="hljs-string">'Minefield/'</span>)[<span class="hljs-number">1</span>]) || <span class="hljs-literal">undefined</span>);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-1077">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1077">&#182;</a>
              </div>
              <p>IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (document.all &amp;&amp; !has(<span class="hljs-string">'opera'</span>)) {
							<span class="hljs-keyword">var</span> isIE = <span class="hljs-built_in">parseFloat</span>(dav.split(<span class="hljs-string">'MSIE '</span>)[<span class="hljs-number">1</span>]) || <span class="hljs-literal">undefined</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1078">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1078">&#182;</a>
              </div>
              <p>In cases where the page has an HTTP header or META tag with
X-UA-Compatible, then it is in emulation mode.
Make sure isIE reflects the desired version.
document.documentMode of 5 means quirks mode.
Only switch the value if documentMode’s major version
is different from isIE’s major version.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> mode = document.documentMode;
							<span class="hljs-keyword">if</span> (mode &amp;&amp; mode !== <span class="hljs-number">5</span> &amp;&amp; <span class="hljs-built_in">Math</span>.floor(isIE) !== mode) {
								isIE = mode;
							}
							has.add(<span class="hljs-string">'ie'</span>, isIE);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-1079">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1079">&#182;</a>
              </div>
              <p>Wii</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						has.add(<span class="hljs-string">'wii'</span>, <span class="hljs-keyword">typeof</span> opera !== <span class="hljs-string">'undefined'</span> &amp;&amp; opera.wiiremote);
					}
				}
				<span class="hljs-keyword">return</span> has;
			});
		},
		<span class="hljs-string">'dojo/request/handlers'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'../json'</span>,
				<span class="hljs-string">'../_base/kernel'</span>,
				<span class="hljs-string">'../_base/array'</span>,
				<span class="hljs-string">'../has'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(JSON, kernel, array, has)</span> {</span>
				has.add(<span class="hljs-string">'activex'</span>, <span class="hljs-keyword">typeof</span> ActiveXObject !== <span class="hljs-string">'undefined'</span>);
				<span class="hljs-keyword">var</span> handleXML;
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'activex'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1080">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1080">&#182;</a>
              </div>
              <p>GUIDs obtained from <a href="http://msdn.microsoft.com/en-us/library/ms757837(VS.85).aspx">http://msdn.microsoft.com/en-us/library/ms757837(VS.85).aspx</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> dp = [
						<span class="hljs-string">'Msxml2.DOMDocument.6.0'</span>,
						<span class="hljs-string">'Msxml2.DOMDocument.4.0'</span>,
						<span class="hljs-string">'MSXML2.DOMDocument.3.0'</span>,
						<span class="hljs-string">'MSXML.DOMDocument'</span>
					];
					handleXML = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span>
						<span class="hljs-keyword">var</span> result = response.data;
						<span class="hljs-keyword">if</span> (!result || !result.documentElement) {
							<span class="hljs-keyword">var</span> text = response.text;
							array.some(dp, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p)</span> {</span>
								<span class="hljs-keyword">try</span> {
									<span class="hljs-keyword">var</span> dom = <span class="hljs-keyword">new</span> ActiveXObject(p);
									dom.async = <span class="hljs-literal">false</span>;
									dom.loadXML(text);
									result = dom;
								} <span class="hljs-keyword">catch</span> (e) {
									<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
								}
								<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
							});
						}
						<span class="hljs-keyword">return</span> result;
					};
				}
				<span class="hljs-keyword">var</span> handlers = {
					<span class="hljs-string">'javascript'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span>
						<span class="hljs-keyword">return</span> kernel.eval(response.text || <span class="hljs-string">''</span>);
					},
					<span class="hljs-string">'json'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span>
						<span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(response.text || <span class="hljs-literal">null</span>);
					},
					<span class="hljs-string">'xml'</span>: handleXML
				};

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span><span class="hljs-params">(response)</span> {</span>
					<span class="hljs-keyword">var</span> handler = handlers[response.options.handleAs];
					response.data = handler ? handler(response) : response.data || response.text;
					<span class="hljs-keyword">return</span> response;
				}
				handle.register = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, handler)</span> {</span>
					handlers[name] = handler;
				};
				<span class="hljs-keyword">return</span> handle;
			});
		},
		<span class="hljs-string">'dojo/aspect'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define(<span class="hljs-string">'dojo/aspect'</span>, [], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1081">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1081">&#182;</a>
              </div>
              <p>module:
    dojo/aspect</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">				'use strict'</span>;
				<span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span>, nextId = <span class="hljs-number">0</span>;

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">advise</span><span class="hljs-params">(dispatcher, type, advice, receiveArguments)</span> {</span>
					<span class="hljs-keyword">var</span> previous = dispatcher[type];
					<span class="hljs-keyword">var</span> around = type === <span class="hljs-string">'around'</span>;
					<span class="hljs-keyword">var</span> signal;
					<span class="hljs-keyword">if</span> (around) {
						<span class="hljs-keyword">var</span> advised = advice(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							<span class="hljs-keyword">return</span> previous.advice(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
						});
						signal = {
							remove: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								signal.cancelled = <span class="hljs-literal">true</span>;
							},
							advice: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, args)</span> {</span>
								<span class="hljs-keyword">return</span> signal.cancelled ? previous.advice(target, args) : advised.apply(target, args); <span class="hljs-comment">// called the advised function</span>
							}
						};
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1082">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1082">&#182;</a>
              </div>
              <p>create the remove handler</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						signal = {
							remove: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								<span class="hljs-keyword">var</span> previous = signal.previous;
								<span class="hljs-keyword">var</span> next = signal.next;
								<span class="hljs-keyword">if</span> (!next &amp;&amp; !previous) {
									<span class="hljs-keyword">delete</span> dispatcher[type];
								} <span class="hljs-keyword">else</span> {
									<span class="hljs-keyword">if</span> (previous) {
										previous.next = next;
									} <span class="hljs-keyword">else</span> {
										dispatcher[type] = next;
									}
									<span class="hljs-keyword">if</span> (next) {
										next.previous = previous;
									}
								}
							},
							id: nextId++,
							advice: advice,
							receiveArguments: receiveArguments
						};
					}
					<span class="hljs-keyword">if</span> (previous &amp;&amp; !around) {
						<span class="hljs-keyword">if</span> (type === <span class="hljs-string">'after'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1083">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1083">&#182;</a>
              </div>
              <p>add the listener to the end of the list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> next = previous;
							<span class="hljs-keyword">while</span> (next) {
								previous = next;
								next = next.next;
							}
							previous.next = signal;
							signal.previous = previous;
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'before'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1084">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1084">&#182;</a>
              </div>
              <p>add to beginning</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							dispatcher[type] = signal;
							signal.next = previous;
							previous.previous = signal;
						}
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1085">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1085">&#182;</a>
              </div>
              <p>around or first one just replaces</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						dispatcher[type] = signal;
					}
					<span class="hljs-keyword">return</span> signal;
				}

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aspect</span><span class="hljs-params">(type)</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, methodName, advice, receiveArguments)</span> {</span>
						<span class="hljs-keyword">var</span> existing = target[methodName],
							dispatcher;
						<span class="hljs-keyword">if</span> (!existing || existing.target !== target) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1086">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1086">&#182;</a>
              </div>
              <p>no dispatcher in place</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							target[methodName] = dispatcher = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								<span class="hljs-keyword">var</span> executionId = nextId;</pre></div></div>
            
        </li>
        
        
        <li id="section-1087">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1087">&#182;</a>
              </div>
              <p>before advice</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;
								<span class="hljs-keyword">var</span> before = dispatcher.before;
								<span class="hljs-keyword">while</span> (before) {
									args = before.advice.apply(<span class="hljs-keyword">this</span>, args) || args;
									before = before.next;
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-1088">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1088">&#182;</a>
              </div>
              <p>around advice</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (dispatcher.around) {
									<span class="hljs-keyword">var</span> results = dispatcher.around.advice(<span class="hljs-keyword">this</span>, args);
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-1089">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1089">&#182;</a>
              </div>
              <p>after advice</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">var</span> after = dispatcher.after;
								<span class="hljs-keyword">while</span> (after &amp;&amp; after.id &lt; executionId) {
									<span class="hljs-keyword">if</span> (after.receiveArguments) {
										<span class="hljs-keyword">var</span> newResults = after.advice.apply(<span class="hljs-keyword">this</span>, args);</pre></div></div>
            
        </li>
        
        
        <li id="section-1090">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1090">&#182;</a>
              </div>
              <p>change the return value only if a new value was returned</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										results = newResults === <span class="hljs-literal">undefined</span> ? results : newResults;
									} <span class="hljs-keyword">else</span> {
										results = after.advice.call(<span class="hljs-keyword">this</span>, results, args);
									}
									after = after.next;
								}
								<span class="hljs-keyword">return</span> results;
							};
							<span class="hljs-keyword">if</span> (existing) {
								dispatcher.around = {
									advice: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, args)</span> {</span>
										<span class="hljs-keyword">return</span> existing.apply(target, args);
									}
								};
							}
							dispatcher.target = target;
						}
						<span class="hljs-keyword">var</span> results = advise(dispatcher || existing, type, advice, receiveArguments);
						advice = <span class="hljs-literal">null</span>;
						<span class="hljs-keyword">return</span> results;
					};
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-1091">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1091">&#182;</a>
              </div>
              <p>TODOC: after/before/around return object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> after = aspect(<span class="hljs-string">'after'</span>);
				<span class="hljs-comment">/*=====
             after = function(target, methodName, advice, receiveArguments){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1092">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1092">&#182;</a>
              </div>
              <p>summary:
    The “after” export of the aspect module is a function that can be used to attach
    “after” advice to a method. This function will be executed after the original method
    is executed. By default the function will be called with a single argument, the return
    value of the original method, or the the return value of the last executed advice (if a previous one exists).
    The fourth (optional) argument can be set to true to so the function receives the original
    arguments (from when the original method was called) rather than the return value.
    If there are multiple “after” advisors, they are executed in the order they were registered.
target: Object
    This is the target object
methodName: String
    This is the name of the method to attach to.
advice: Function
    This is function to be called after the original method
receiveArguments: Boolean?
    If this is set to true, the advice function receives the original arguments (from when the original mehtod
    was called) rather than the return value of the original/previous method.
returns:
    A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
    stop the advice function from being executed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				var before = aspect('before');
				/*=====
             before = function(target, methodName, advice){</pre></div></div>
            
        </li>
        
        
        <li id="section-1093">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1093">&#182;</a>
              </div>
              <p>summary:
    The “before” export of the aspect module is a function that can be used to attach
    “before” advice to a method. This function will be executed before the original method
    is executed. This function will be called with the arguments used to call the method.
    This function may optionally return an array as the new arguments to use to call
    the original method (or the previous, next-to-execute before advice, if one exists).
    If the before method doesn’t return anything (returns undefined) the original arguments
    will be preserved.
    If there are multiple “before” advisors, they are executed in the reverse order they were registered.
target: Object
    This is the target object
methodName: String
    This is the name of the method to attach to.
advice: Function
    This is function to be called before the original method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				var around = aspect('around');
				/*=====
             around = function(target, methodName, advice){</pre></div></div>
            
        </li>
        
        
        <li id="section-1094">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1094">&#182;</a>
              </div>
              <p>summary:
    The “around” export of the aspect module is a function that can be used to attach
    “around” advice to a method. The advisor function is immediately executed when
    the around() is called, is passed a single argument that is a function that can be
    called to continue execution of the original method (or the next around advisor).
    The advisor function should return a function, and this function will be called whenever
    the method is called. It will be called with the arguments used to call the method.
    Whatever this function returns will be returned as the result of the method call (unless after advise changes it).
example:
    If there are multiple “around” advisors, the most recent one is executed first,
    which can then delegate to the next one and so on. For example:
    |    around(obj, “foo”, function(originalFoo){
    |        return function(){
    |            var start = new Date().getTime();
    |            var results = originalFoo.apply(this, arguments); // call the original
    |            var end = new Date().getTime();
    |            console.log(“foo execution took “ + (end - start) + “ ms”);
    |            return results;
    |        };
    |    });
target: Object
    This is the target object
methodName: String
    This is the name of the method to attach to.
advice: Function
    This is function to be called around the original method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				return {
					before: before,
					around: around,
					after: after
				};
			});
		},
		'dojo/ready': function () {
			define('dojo/ready', [
				'./_base/kernel',
				'./has',
				'require',
				'./domReady',
				'./_base/lang'
			], function (dojo, has, require, domReady, lang) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1095">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1095">&#182;</a>
              </div>
              <p>module:
    dojo/ready
note:
    This module should be unnecessary in dojo 2.0</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1096">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1096">&#182;</a>
              </div>
              <p>truthy if DOMContentLoaded or better (e.g., window.onload fired) has been achieved</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				isDomReady = <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1097">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1097">&#182;</a>
              </div>
              <p>a function to call to cause onLoad to be called when all requested modules have been loaded</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					requestCompleteSignal,</pre></div></div>
            
        </li>
        
        
        <li id="section-1098">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1098">&#182;</a>
              </div>
              <p>The queue of functions waiting to execute as soon as dojo.ready conditions satisfied</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					loadQ = [],</pre></div></div>
            
        </li>
        
        
        <li id="section-1099">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1099">&#182;</a>
              </div>
              <p>prevent recursion in onLoad</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					onLoadRecursiveGuard = <span class="hljs-number">0</span>,
					handleDomReady = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						isDomReady = <span class="hljs-number">1</span>;
						dojo._postLoad = dojo.config.afterOnLoad = <span class="hljs-literal">true</span>;
						<span class="hljs-keyword">if</span> (loadQ.length) {
							requestCompleteSignal(onLoad);
						}
					},</pre></div></div>
            
        </li>
        
        
        <li id="section-1100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1100">&#182;</a>
              </div>
              <p>run the next function queued with dojo.ready</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					onLoad = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">if</span> (isDomReady &amp;&amp; !onLoadRecursiveGuard &amp;&amp; loadQ.length) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1101">&#182;</a>
              </div>
              <p>guard against recursions into this function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							onLoadRecursiveGuard = <span class="hljs-number">1</span>;
							<span class="hljs-keyword">var</span> f = loadQ.shift();
							<span class="hljs-keyword">try</span> {
								f();
							} <span class="hljs-comment">// FIXME: signal the error via require.on</span>
							<span class="hljs-keyword">finally</span> {
								onLoadRecursiveGuard = <span class="hljs-number">0</span>;
							}
							onLoadRecursiveGuard = <span class="hljs-number">0</span>;
							<span class="hljs-keyword">if</span> (loadQ.length) {
								requestCompleteSignal(onLoad);
							}
						}
					};
				<span class="hljs-built_in">require</span>.on(<span class="hljs-string">'idle'</span>, onLoad);
				requestCompleteSignal = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">if</span> (<span class="hljs-built_in">require</span>.idle()) {
						onLoad();
					} <span class="hljs-comment">// else do nothing, onLoad will be called with the next idle signal</span>
				};
				<span class="hljs-keyword">var</span> ready = dojo.ready = dojo.addOnLoad = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(priority, context, callback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1102">&#182;</a>
              </div>
              <p>summary:
    Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
    In most cases, the <code>domReady</code> plug-in should suffice and this method should not be needed.
priority: Integer?
    The order in which to exec this callback relative to other callbacks, defaults to 1000
context: Object?|Function
    The context in which to run execute callback, or a callback if not using context
callback: Function?
    The function to execute.</p>
<p>example:
Simple DOM and Modules ready syntax
|    require([“dojo/ready”], function(ready){
|        ready(function(){ alert(“Dom ready!”); });
|    });</p>
<p>example:
Using a priority
|    require([“dojo/ready”], function(ready){
|        ready(2, function(){ alert(“low priority ready!”); })
|    });</p>
<p>example:
Using context
|    require([“dojo/ready”], function(ready){
|        ready(foo, function(){
|            // in here, this == foo
|        });
|    });</p>
<p>example:
Using dojo/hitch style args:
|    require([“dojo/ready”], function(ready){
|        var foo = { dojoReady: function(){ console.warn(this, “dojo dom and modules ready.”); } };
|        ready(foo, “dojoReady”);
|    });</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> hitchArgs = lang._toArray(<span class="hljs-built_in">arguments</span>);
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> priority !== <span class="hljs-string">'number'</span>) {
						callback = context;
						context = priority;
						priority = <span class="hljs-number">1000</span>;
					} <span class="hljs-keyword">else</span> {
						hitchArgs.shift();
					}
					callback = callback ? lang.hitch.apply(dojo, hitchArgs) : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						context();
					};
					callback.priority = priority;
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; loadQ.length &amp;&amp; priority &gt;= loadQ[i].priority; i++) {}
					loadQ.splice(i, <span class="hljs-number">0</span>, callback);
					requestCompleteSignal();
				};
				<span class="hljs-number">1</span> || has.add(<span class="hljs-string">'dojo-config-addOnLoad'</span>, <span class="hljs-number">1</span>);
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
					<span class="hljs-keyword">var</span> dca = dojo.config.addOnLoad;
					<span class="hljs-keyword">if</span> (dca) {
						ready[lang.isArray(dca) ? <span class="hljs-string">'apply'</span> : <span class="hljs-string">'call'</span>](dojo, dca);
					}
				}
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp;&amp; dojo.config.parseOnLoad &amp;&amp; !dojo.isAsync) {
					ready(<span class="hljs-number">99</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						<span class="hljs-keyword">if</span> (!dojo.parser) {
							dojo.deprecated(<span class="hljs-string">'Add explicit require([\'dojo/parser\']);'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'2.0'</span>);
							<span class="hljs-built_in">require</span>([<span class="hljs-string">'dojo/parser'</span>]);
						}
					});
				}
				<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {
					domReady(handleDomReady);
				} <span class="hljs-keyword">else</span> {
					handleDomReady();
				}
				<span class="hljs-keyword">return</span> ready;
			});
		},
		<span class="hljs-string">'dojo/_base/connect'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			define([
				<span class="hljs-string">'./kernel'</span>,
				<span class="hljs-string">'../on'</span>,
				<span class="hljs-string">'../topic'</span>,
				<span class="hljs-string">'../aspect'</span>,
				<span class="hljs-string">'./event'</span>,
				<span class="hljs-string">'../mouse'</span>,
				<span class="hljs-string">'./sniff'</span>,
				<span class="hljs-string">'./lang'</span>,
				<span class="hljs-string">'../keys'</span>
			], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dojo, on, hub, aspect, eventModule, mouse, has, lang)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1103">&#182;</a>
              </div>
              <p>module:
    dojo/_base/connect</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				has.add(<span class="hljs-string">'events-keypress-typed'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1104">&#182;</a>
              </div>
              <p>keypresses should only occur a printable character is hit</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> testKeyEvent = {
						charCode: <span class="hljs-number">0</span>
					};
					<span class="hljs-keyword">try</span> {
						testKeyEvent = document.createEvent(<span class="hljs-string">'KeyboardEvent'</span>);
						(testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent)
							.call(testKeyEvent, <span class="hljs-string">'keypress'</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>);
					} <span class="hljs-keyword">catch</span> (e) {}
					<span class="hljs-keyword">return</span> testKeyEvent.charCode === <span class="hljs-number">0</span> &amp;&amp; !has(<span class="hljs-string">'opera'</span>);
				});

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect_</span><span class="hljs-params">(obj, event, context, method, dontFix)</span> {</span>
					method = lang.hitch(context, method);
					<span class="hljs-keyword">if</span> (!obj || !(obj.addEventListener || obj.attachEvent)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1105">&#182;</a>
              </div>
              <p>it is a not a DOM node and we are using the dojo.connect style of treating a
method like an event, must go right to aspect</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> aspect.after(obj || dojo.global, event, method, <span class="hljs-literal">true</span>);
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event === <span class="hljs-string">'string'</span> &amp;&amp; event.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) === <span class="hljs-string">'on'</span>) {
						event = event.substring(<span class="hljs-number">2</span>);
					}
					<span class="hljs-keyword">if</span> (!obj) {
						obj = dojo.global;
					}
					<span class="hljs-keyword">if</span> (!dontFix) {
						<span class="hljs-keyword">switch</span> (event) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1106">&#182;</a>
              </div>
              <p>dojo.connect has special handling for these event types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">case</span> <span class="hljs-string">'keypress'</span>:
							event = keypress;
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'mouseenter'</span>:
							event = mouse.enter;
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'mouseleave'</span>:
							event = mouse.leave;
							<span class="hljs-keyword">break</span>;
						}
					}
					<span class="hljs-keyword">return</span> on(obj, event, method, dontFix);
				}
				<span class="hljs-keyword">var</span> _punctMap = {
					<span class="hljs-number">106</span>: <span class="hljs-number">42</span>,
					<span class="hljs-number">111</span>: <span class="hljs-number">47</span>,
					<span class="hljs-number">186</span>: <span class="hljs-number">59</span>,
					<span class="hljs-number">187</span>: <span class="hljs-number">43</span>,
					<span class="hljs-number">188</span>: <span class="hljs-number">44</span>,
					<span class="hljs-number">189</span>: <span class="hljs-number">45</span>,
					<span class="hljs-number">190</span>: <span class="hljs-number">46</span>,
					<span class="hljs-number">191</span>: <span class="hljs-number">47</span>,
					<span class="hljs-number">192</span>: <span class="hljs-number">96</span>,
					<span class="hljs-number">219</span>: <span class="hljs-number">91</span>,
					<span class="hljs-number">220</span>: <span class="hljs-number">92</span>,
					<span class="hljs-number">221</span>: <span class="hljs-number">93</span>,
					<span class="hljs-number">222</span>: <span class="hljs-number">39</span>,
					<span class="hljs-number">229</span>: <span class="hljs-number">113</span>
				};
				<span class="hljs-keyword">var</span> evtCopyKey = has(<span class="hljs-string">'mac'</span>) ? <span class="hljs-string">'metaKey'</span> : <span class="hljs-string">'ctrlKey'</span>;
				<span class="hljs-keyword">var</span> _synthesizeEvent = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt, props)</span> {</span>
					<span class="hljs-keyword">var</span> faux = lang.mixin({}, evt, props);
					setKeyChar(faux);</pre></div></div>
            
        </li>
        
        
        <li id="section-1107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1107">&#182;</a>
              </div>
              <p>FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);
but it throws an error when preventDefault is invoked on Safari
does Event.preventDefault not support “apply” on Safari?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					faux.preventDefault = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						evt.preventDefault();
					};
					faux.stopPropagation = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
						evt.stopPropagation();
					};
					<span class="hljs-keyword">return</span> faux;
				};

				<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setKeyChar</span><span class="hljs-params">(evt)</span> {</span>
					evt.keyChar = evt.charCode ? <span class="hljs-built_in">String</span>.fromCharCode(evt.charCode) : <span class="hljs-string">''</span>;
					evt.charOrCode = evt.keyChar || evt.keyCode;
				}
				<span class="hljs-keyword">var</span> keypress;
				<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'events-keypress-typed'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1108">&#182;</a>
              </div>
              <p>this emulates Firefox’s keypress behavior where every keydown can correspond to a keypress</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> _trySetKeyCode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e, code)</span> {</span>
						<span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1109">&#182;</a>
              </div>
              <p>squelch errors when keyCode is read-only
(e.g. if keyCode is ctrl or shift)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> e.keyCode = code;
						} <span class="hljs-keyword">catch</span> (e) {
							<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
						}
					};
					keypress = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(object, listener)</span> {</span>
						<span class="hljs-keyword">var</span> keydownSignal = on(object, <span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1110">&#182;</a>
              </div>
              <p>munge key/charCode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> k = evt.keyCode;</pre></div></div>
            
        </li>
        
        
        <li id="section-1111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1111">&#182;</a>
              </div>
              <p>These are Windows Virtual Key Codes
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> unprintable = k !== <span class="hljs-number">13</span> &amp;&amp; k !== <span class="hljs-number">32</span> &amp;&amp; (k !== <span class="hljs-number">27</span> || !has(<span class="hljs-string">'ie'</span>)) &amp;&amp; (k &lt; <span class="hljs-number">48</span> || k &gt; <span class="hljs-number">90</span>) &amp;&amp; (k &lt; <span class="hljs-number">96</span> || k &gt; <span class="hljs-number">111</span>) &amp;&amp; (k &lt; <span class="hljs-number">186</span> || k &gt; <span class="hljs-number">192</span>) &amp;&amp; (k &lt; <span class="hljs-number">219</span> || k &gt; <span class="hljs-number">222</span>) &amp;&amp; k !== <span class="hljs-number">229</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1112">&#182;</a>
              </div>
              <p>synthesize keypress for most unprintables and CTRL-keys</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (unprintable || evt.ctrlKey) {
								<span class="hljs-keyword">var</span> c = unprintable ? <span class="hljs-number">0</span> : k;
								<span class="hljs-keyword">if</span> (evt.ctrlKey) {
									<span class="hljs-keyword">if</span> (k === <span class="hljs-number">3</span> || k === <span class="hljs-number">13</span>) {
										<span class="hljs-keyword">return</span> listener.call(evt.currentTarget, evt); <span class="hljs-comment">// IE will post CTRL-BREAK, CTRL-ENTER as keypress natively</span>
									} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">95</span> &amp;&amp; c &lt; <span class="hljs-number">106</span>) {
										c -= <span class="hljs-number">48</span>; <span class="hljs-comment">// map CTRL-[numpad 0-9] to ASCII</span>
									} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!evt.shiftKey &amp;&amp; (c &gt;= <span class="hljs-number">65</span> &amp;&amp; c &lt;= <span class="hljs-number">90</span>)) {
										c += <span class="hljs-number">32</span>; <span class="hljs-comment">// map CTRL-[A-Z] to lowercase</span>
									} <span class="hljs-keyword">else</span> {
										c = _punctMap[c] || c; <span class="hljs-comment">// map other problematic CTRL combinations to ASCII</span>
									}
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-1113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1113">&#182;</a>
              </div>
              <p>simulate a keypress event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">var</span> faux = _synthesizeEvent(evt, {
									type: <span class="hljs-string">'keypress'</span>,
									faux: <span class="hljs-literal">true</span>,
									charCode: c
								});
								listener.call(evt.currentTarget, faux);
								<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'ie'</span>)) {
									_trySetKeyCode(evt, faux.keyCode);
								}
							}
						});
						<span class="hljs-keyword">var</span> keypressSignal = on(object, <span class="hljs-string">'keypress'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> {</span>
							<span class="hljs-keyword">var</span> c = evt.charCode;
							c = c &gt;= <span class="hljs-number">32</span> ? c : <span class="hljs-number">0</span>;
							evt = _synthesizeEvent(evt, {
								charCode: c,
								faux: <span class="hljs-literal">true</span>
							});
							<span class="hljs-keyword">return</span> listener.call(<span class="hljs-keyword">this</span>, evt);
						});
						<span class="hljs-keyword">return</span> {
							remove: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
								keydownSignal.remove();
								keypressSignal.remove();
							}
						};
					};
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">if</span> (has(<span class="hljs-string">'opera'</span>)) {
						keypress = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(object, listener)</span> {</span>
							<span class="hljs-keyword">return</span> on(object, <span class="hljs-string">'keypress'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> {</span>
								<span class="hljs-keyword">var</span> c = evt.which;
								<span class="hljs-keyword">if</span> (c === <span class="hljs-number">3</span>) {
									c = <span class="hljs-number">99</span>; <span class="hljs-comment">// Mozilla maps CTRL-BREAK to CTRL-c</span>
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-1114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1114">&#182;</a>
              </div>
              <p>can’t trap some keys at all, like INSERT and DELETE
there is no differentiating info between DELETE and “.”, or INSERT and “-“</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								c = c &lt; <span class="hljs-number">32</span> &amp;&amp; !evt.shiftKey ? <span class="hljs-number">0</span> : c;
								<span class="hljs-keyword">if</span> (evt.ctrlKey &amp;&amp; !evt.shiftKey &amp;&amp; c &gt;= <span class="hljs-number">65</span> &amp;&amp; c &lt;= <span class="hljs-number">90</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1115">&#182;</a>
              </div>
              <p>lowercase CTRL-[A-Z] keys</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									c += <span class="hljs-number">32</span>;
								}
								<span class="hljs-keyword">return</span> listener.call(<span class="hljs-keyword">this</span>, _synthesizeEvent(evt, {
									charCode: c
								}));
							});
						};
					} <span class="hljs-keyword">else</span> {
						keypress = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(object, listener)</span> {</span>
							<span class="hljs-keyword">return</span> on(object, <span class="hljs-string">'keypress'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> {</span>
								setKeyChar(evt);
								<span class="hljs-keyword">return</span> listener.call(<span class="hljs-keyword">this</span>, evt);
							});
						};
					}
				}
				<span class="hljs-keyword">var</span> connect = {
					_keypress: keypress,
					connect: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj, event, context, method, dontFix)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1116">&#182;</a>
              </div>
              <p>summary:
    <code>dojo.connect</code> is a deprecated event handling and delegation method in
    Dojo. It allows one function to “listen in” on the execution of
    any other, triggering the second whenever the first is called. Many
    listeners may be attached to a function, and source functions may
    be either regular function calls or DOM events.</p>
<p>description:
    Connects listeners to actions, so that after event fires, a
    listener is called with the same arguments passed to the original
    function.</p>
<pre><code>Since `dojo.connect` allows the source of events to be either a
<span class="hljs-string">"regular"</span> JavaScript <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">or</span> <span class="hljs-title">a</span> <span class="hljs-title">DOM</span> <span class="hljs-title">event</span>, <span class="hljs-title">it</span> <span class="hljs-title">provides</span> <span class="hljs-title">a</span> <span class="hljs-title">uniform</span>
<span class="hljs-title">interface</span> <span class="hljs-title">for</span> <span class="hljs-title">listening</span> <span class="hljs-title">to</span> <span class="hljs-title">all</span> <span class="hljs-title">the</span> <span class="hljs-title">types</span> <span class="hljs-title">of</span> <span class="hljs-title">events</span> <span class="hljs-title">that</span> <span class="hljs-title">an</span>
<span class="hljs-title">application</span> <span class="hljs-title">is</span> <span class="hljs-title">likely</span> <span class="hljs-title">to</span> <span class="hljs-title">deal</span> <span class="hljs-title">with</span> <span class="hljs-title">though</span> <span class="hljs-title">a</span> <span class="hljs-title">single</span>, <span class="hljs-title">unified</span>
<span class="hljs-title">interface</span>. <span class="hljs-title">DOM</span> <span class="hljs-title">programmers</span> <span class="hljs-title">may</span> <span class="hljs-title">want</span> <span class="hljs-title">to</span> <span class="hljs-title">think</span> <span class="hljs-title">of</span> <span class="hljs-title">it</span> <span class="hljs-title">as</span>
"<span class="hljs-title">addEventListener</span> <span class="hljs-title">for</span> <span class="hljs-title">everything</span> <span class="hljs-title">and</span> <span class="hljs-title">anything</span>".

<span class="hljs-title">When</span> <span class="hljs-title">setting</span> <span class="hljs-title">up</span> <span class="hljs-title">a</span> <span class="hljs-title">connection</span>, <span class="hljs-title">the</span> `<span class="hljs-title">event</span>` <span class="hljs-title">parameter</span> <span class="hljs-title">must</span> <span class="hljs-title">be</span> <span class="hljs-title">a</span>
<span class="hljs-title">string</span> <span class="hljs-title">that</span> <span class="hljs-title">is</span> <span class="hljs-title">the</span> <span class="hljs-title">name</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">method</span>/<span class="hljs-title">event</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">listened</span> <span class="hljs-title">for</span>. <span class="hljs-title">If</span>
`<span class="hljs-title">obj</span>` <span class="hljs-title">is</span> <span class="hljs-title">null</span>, `<span class="hljs-title">kernel</span>.<span class="hljs-title">global</span>` <span class="hljs-title">is</span> <span class="hljs-title">assumed</span>, <span class="hljs-title">meaning</span> <span class="hljs-title">that</span> <span class="hljs-title">connections</span>
<span class="hljs-title">to</span> <span class="hljs-title">global</span> <span class="hljs-title">methods</span> <span class="hljs-title">are</span> <span class="hljs-title">supported</span> <span class="hljs-title">but</span> <span class="hljs-title">also</span> <span class="hljs-title">that</span> <span class="hljs-title">you</span> <span class="hljs-title">may</span> <span class="hljs-title">inadvertently</span>
<span class="hljs-title">connect</span> <span class="hljs-title">to</span> <span class="hljs-title">a</span> <span class="hljs-title">global</span> <span class="hljs-title">by</span> <span class="hljs-title">passing</span> <span class="hljs-title">an</span> <span class="hljs-title">incorrect</span> <span class="hljs-title">object</span> <span class="hljs-title">name</span> <span class="hljs-title">or</span> <span class="hljs-title">invalid</span>
<span class="hljs-title">reference</span>.

`<span class="hljs-title">dojo</span>.<span class="hljs-title">connect</span>` <span class="hljs-title">generally</span> <span class="hljs-title">is</span> <span class="hljs-title">forgiving</span>. <span class="hljs-title">If</span> <span class="hljs-title">you</span> <span class="hljs-title">pass</span> <span class="hljs-title">the</span> <span class="hljs-title">name</span> <span class="hljs-title">of</span> <span class="hljs-title">a</span>
<span class="hljs-title">function</span> <span class="hljs-title">or</span> <span class="hljs-title">method</span> <span class="hljs-title">that</span> <span class="hljs-title">does</span> <span class="hljs-title">not</span> <span class="hljs-title">yet</span> <span class="hljs-title">exist</span> <span class="hljs-title">on</span> `<span class="hljs-title">obj</span>`, <span class="hljs-title">connect</span> <span class="hljs-title">will</span>
<span class="hljs-title">not</span> <span class="hljs-title">fail</span>, <span class="hljs-title">but</span> <span class="hljs-title">will</span> <span class="hljs-title">instead</span> <span class="hljs-title">set</span> <span class="hljs-title">up</span> <span class="hljs-title">a</span> <span class="hljs-title">stub</span> <span class="hljs-title">method</span>. <span class="hljs-title">Similarly</span>, <span class="hljs-title">null</span>
<span class="hljs-title">arguments</span> <span class="hljs-title">may</span> <span class="hljs-title">simply</span> <span class="hljs-title">be</span> <span class="hljs-title">omitted</span> <span class="hljs-title">such</span> <span class="hljs-title">that</span> <span class="hljs-title">fewer</span> <span class="hljs-title">than</span> 4 <span class="hljs-title">arguments</span>
<span class="hljs-title">may</span> <span class="hljs-title">be</span> <span class="hljs-title">required</span> <span class="hljs-title">to</span> <span class="hljs-title">set</span> <span class="hljs-title">up</span> <span class="hljs-title">a</span> <span class="hljs-title">connection</span> <span class="hljs-title">See</span> <span class="hljs-title">the</span> <span class="hljs-title">examples</span> <span class="hljs-title">for</span> <span class="hljs-title">details</span>.

<span class="hljs-title">The</span> <span class="hljs-title">return</span> <span class="hljs-title">value</span> <span class="hljs-title">is</span> <span class="hljs-title">a</span> <span class="hljs-title">handle</span> <span class="hljs-title">that</span> <span class="hljs-title">is</span> <span class="hljs-title">needed</span> <span class="hljs-title">to</span>
<span class="hljs-title">remove</span> <span class="hljs-title">this</span> <span class="hljs-title">connection</span> <span class="hljs-title">with</span> `<span class="hljs-title">dojo</span>.<span class="hljs-title">disconnect</span>`.</span>
</code></pre><p>obj: Object?
    The source object for the event function.
    Defaults to <code>kernel.global</code> if null.
    If obj is a DOM node, the connection is delegated
    to the DOM event manager (unless dontFix is true).</p>
<p>event: String
    String name of the event function in obj.
    I.e. identifies a property <code>obj[event]</code>.</p>
<p>context: Object|null
    The object that method will receive as “this”.</p>
<pre><code>If context is <span class="hljs-literal">null</span> and method is a <span class="hljs-function"><span class="hljs-keyword">function</span>, <span class="hljs-title">then</span> <span class="hljs-title">method</span>
<span class="hljs-title">inherits</span> <span class="hljs-title">the</span> <span class="hljs-title">context</span> <span class="hljs-title">of</span> <span class="hljs-title">event</span>.

<span class="hljs-title">If</span> <span class="hljs-title">method</span> <span class="hljs-title">is</span> <span class="hljs-title">a</span> <span class="hljs-title">string</span> <span class="hljs-title">then</span> <span class="hljs-title">context</span> <span class="hljs-title">must</span> <span class="hljs-title">be</span> <span class="hljs-title">the</span> <span class="hljs-title">source</span>
<span class="hljs-title">object</span> <span class="hljs-title">object</span> <span class="hljs-title">for</span> <span class="hljs-title">method</span> <span class="hljs-params">(context[method])</span>. <span class="hljs-title">If</span> <span class="hljs-title">context</span> <span class="hljs-title">is</span> <span class="hljs-title">null</span>,
<span class="hljs-title">kernel</span>.<span class="hljs-title">global</span> <span class="hljs-title">is</span> <span class="hljs-title">used</span>.</span>
</code></pre><p>method: String|Function
    A function reference, or name of a function in context.
    The function identified by method fires after event does.
    method receives the same arguments as the event.
    See context argument comments for information on method’s scope.</p>
<p>dontFix: Boolean?
    If obj is a DOM node, set dontFix to true to prevent delegation
    of this connection to the DOM event manager.</p>
<p>example:
    When obj.onchange(), do ui.update():
|    dojo.connect(obj, “onchange”, ui, “update”);
|    dojo.connect(obj, “onchange”, ui, ui.update); // same</p>
<p>example:
    Using return value for disconnect:
|    var link = dojo.connect(obj, “onchange”, ui, “update”);
|    …
|    dojo.disconnect(link);</p>
<p>example:
    When onglobalevent executes, watcher.handler is invoked:
|    dojo.connect(null, “onglobalevent”, watcher, “handler”);</p>
<p>example:
    When ob.onCustomEvent executes, customEventHandler is invoked:
|    dojo.connect(ob, “onCustomEvent”, null, “customEventHandler”);
|    dojo.connect(ob, “onCustomEvent”, “customEventHandler”); // same</p>
<p>example:
    When ob.onCustomEvent executes, customEventHandler is invoked
    with the same scope (this):
|    dojo.connect(ob, “onCustomEvent”, null, customEventHandler);
|    dojo.connect(ob, “onCustomEvent”, customEventHandler); // same</p>
<p>example:
    When globalEvent executes, globalHandler is invoked
    with the same scope (this):
|    dojo.connect(null, “globalEvent”, null, globalHandler);
|    dojo.connect(“globalEvent”, globalHandler); // same
normalize arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">arguments</span>,
							args = [],
							i = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1117">&#182;</a>
              </div>
              <p>if a[0] is a String, obj was omitted</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						args.push(<span class="hljs-keyword">typeof</span> a[<span class="hljs-number">0</span>] === <span class="hljs-string">'string'</span> ? <span class="hljs-literal">null</span> : a[i++], a[i++]);</pre></div></div>
            
        </li>
        
        
        <li id="section-1118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1118">&#182;</a>
              </div>
              <p>if the arg-after-next is a String or Function, context was NOT omitted</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> a1 = a[i + <span class="hljs-number">1</span>];
						args.push(<span class="hljs-keyword">typeof</span> a1 === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> a1 === <span class="hljs-string">'function'</span> ? a[i++] : <span class="hljs-literal">null</span>, a[i++]);</pre></div></div>
            
        </li>
        
        
        <li id="section-1119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1119">&#182;</a>
              </div>
              <p>absorb any additional arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> l = a.length; i &lt; l; i++) {
							args.push(a[i]);
						}
						<span class="hljs-keyword">return</span> connect_.apply(<span class="hljs-keyword">this</span>, args);
					},
					disconnect: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(handle)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1120">&#182;</a>
              </div>
              <p>summary:
    Remove a link created by dojo.connect.
description:
    Removes the connection between event and the method referenced by handle.
handle: Handle
    the return value of the dojo.connect call that created the connection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (handle) {
							handle.remove();
						}
					},
					subscribe: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(topic, context, method)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1121">&#182;</a>
              </div>
              <p>summary:
    Attach a listener to a named topic. The listener function is invoked whenever the
    named topic is published (see: dojo.publish).
    Returns a handle which is needed to unsubscribe this listener.
topic: String
    The topic to which to subscribe.
context: Object?
    Scope in which method will be invoked, or null for default scope.
method: String|Function
    The name of a function in context, or a function reference. This is the function that
    is invoked when topic is published.
example:
|    dojo.subscribe(“alerts”, null, function(caption, message){ alert(caption + “\n” + message); });
|    dojo.publish(“alerts”, [ “read this”, “hello world” ]);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> hub.subscribe(topic, lang.hitch(context, method));
					},
					publish: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(topic, args)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1122">&#182;</a>
              </div>
              <p>summary:
    Invoke all listener method subscribed to topic.
topic: String
    The name of the topic to publish.
args: Array?
    An array of arguments. The arguments will be applied
    to each topic subscriber (as first class parameters, via apply).
example:
|    dojo.subscribe(“alerts”, null, function(caption, message){ alert(caption + “\n” + message); };
|    dojo.publish(“alerts”, [ “read this”, “hello world” ]);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> hub.publish.apply(hub, [topic].concat(args));
					},
					connectPublisher: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(topic, obj, event)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1123">&#182;</a>
              </div>
              <p>summary:
    Ensure that every time obj.event() is called, a message is published
    on the topic. Returns a handle which can be passed to
    dojo.disconnect() to disable subsequent automatic publication on
    the topic.
topic: String
    The name of the topic to publish.
obj: Object?
    The source object for the event function. Defaults to kernel.global
    if null.
event: String
    The name of the event function in obj.
    I.e. identifies a property obj[event].
example:
|    dojo.connectPublisher(“/ajax/start”, dojo, “xhrGet”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> pf = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							connect.publish(topic, <span class="hljs-built_in">arguments</span>);
						};
						<span class="hljs-keyword">return</span> event ? connect.connect(obj, event, pf) : connect.connect(obj, pf); <span class="hljs-comment">//Handle</span>
					},
					isCopyKey: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1124">&#182;</a>
              </div>
              <p>summary:
    Checks an event for the copy key (meta on Mac, and ctrl anywhere else)
e: Event
    Event object to examine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> e[evtCopyKey]; <span class="hljs-comment">// Boolean</span>
					}
				};
				connect.unsubscribe = connect.disconnect;
				<span class="hljs-comment">/*=====
             connect.unsubscribe = function(handle){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1125">&#182;</a>
              </div>
              <p>summary:
    Remove a topic listener.
handle: Handle
    The handle returned from a call to subscribe.
example:
|    var alerter = dojo.subscribe(“alerts”, null, function(caption, message){ alert(caption + “\n” + message); };
|    …
|    dojo.unsubscribe(alerter);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				1 &amp;&amp; lang.mixin(dojo, connect);
				return connect;
			});
		},
		'dojo/errors/CancelError': function () {
			define(['./create'], function (create) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1126">&#182;</a>
              </div>
              <p>module:
    dojo/errors/CancelError</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/*=====
             return function(){
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1127">&#182;</a>
              </div>
              <p>summary:
    Default error if a promise is canceled without a reason.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>             };
             =====*/
				return create('CancelError', null, null, {
					dojoType: 'cancel'
				});
			});
		}
	}
});
(function () {</pre></div></div>
            
        </li>
        
        
        <li id="section-1128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1128">&#182;</a>
              </div>
              <p>must use this.require to make this work in node.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> <span class="hljs-built_in">require</span> = <span class="hljs-keyword">this</span>.require;</pre></div></div>
            
        </li>
        
        
        <li id="section-1129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1129">&#182;</a>
              </div>
              <p>consume the cached dojo layer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-built_in">require</span>({
		cache: {}
	});
	!<span class="hljs-built_in">require</span>.async &amp;&amp; <span class="hljs-built_in">require</span>([<span class="hljs-string">'dojo'</span>]);
	<span class="hljs-built_in">require</span>.boot &amp;&amp; <span class="hljs-built_in">require</span>.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">require</span>.boot);
}());</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>

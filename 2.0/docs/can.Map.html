<!DOCTYPE html>

<!--[if lt IE 7]>
<html class="no-js ie lt-ie9 lt-ie8 lt-ie7" lang="en">
<![endif]-->
<!--[if IE 7]>
<html class="no-js ie lt-ie9 lt-ie8" lang="en">
<![endif]-->
<!--[if IE 8]>
<html class="no-js ie lt-ie9" lang="en">
<![endif]-->
<!--[if IE 9]>
<html class="no-js ie ie9" lang="en">
<![endif]-->
<!--[if gt IE 9]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->
<head>
	<meta charset="utf-8">
	<title>CanJS  - can.Map</title>
	<meta name="description" content="">
	<meta name="author" content="">

	
	<link rel="stylesheet" type="text/css" href="./static/bundles/static.css">
	
	<!--[if lt IE 9]>
   <script type="text/javascript" src="static/html5shiv.js"></script>
    <!--<![endif]-->
</head>

<body class="docs ">
	<header>
		<nav class="container">

			<div class="logo-menu">
				<a class="brand" href="../../index.html">CanJS</a>
				<ul class="dropdown-menu">
		          <li><a href="http://javascriptmvc.com">JavaScriptMVC</a></li>
		          <li><a href="http://canjs.com" class="active">CanJS</a></li>
		          <li><a href="http://jquerypp.com">jQuery++</a></li>
		          <li><a href="http://stealjs.com">StealJS</a></li>
		          <li><a href="http://funcunit.com">FuncUnit</a></li>
		          <li><a href="http://documentjs.com">DocumentJS</a></li>
		        </ul>
			</div>
			
			<ul class="nav">
		        <li >
	              <a href="../../index.html">Home</a>
                </li>
		       <li><a href='../guides/index.html'>guides</a></li>
		       <li class='active'><a href='index.html'>api</a></li>
		        <li class=" community-menu">
		          <a href="../../community.html#!forums">Community</a>
		          <ul class="dropdown-menu">
		            <li><a href="https://forum.javascriptmvc.com/canjs">Forums</a></li>
		            <li><a href="http://webchat.freenode.net/?channels=canjs">IRC</a></li>
		            <li><a href="http://bithub.com/canjs/app/">Apps</a></li>
		            <li><a href="http://bithub.com/canjs/plugin/">Plugins</a></li>
		            <li><a href="http://bithub.com/canjs/article/">Articles</a></li>
		            <li><a href="http://github.com/bitovi/canjs">Github</a></li>
		            <li><a href="http://twitter.com/canjs">Twitter</a></li>
		            <li><a href="http://bitovi.github.io/canjsmeetup/">Meetups</a></li>
		          </ul>
		        </li>
		        <li >
	              <a href="../../blog/index.html">Blog</a>
                </li>
		        <li >
	              <a href="../../download.html">Download</a>
                </li>
	      	</ul>
			
			<div class="pull-right">
				<div class="bitovi-menu">
					<a href="http://bitovi.com" class="bitovi icon-bits">Bitovi</a>
					<ul class="dropdown-menu">
						<li><a href="http://bitovi.com">Bitovi.com</a></li>
						<li><a href="http://bitovi.com/blog/">Blog</a></li>
						<li><a href="http://bitovi.com/consulting/">Consulting</a></li>
						<li><a href="http://bitovi.com/training/">Training</a></li>
						<li><a href="http://bitovi.com/open-source/">Open Source</a></li>
						<li><a href="http://bitovi.com/people/">People</a></li>
						<li><a href="http://bitovi.com/contact/">Contact Us</a></li>
					</ul>
				</div>
			</div>
			
		</nav>
	</header>

	
<div class="container api">

	
	<nav class="sidebar">
		
		<h2 id="version">
	<select id='versions'></select>
</h2>
<ul class="api">
	<!-- First Level -->
	
	   <li class="search-container">
	   		<a href="can.Component.html" data-search="can.Component">
				can.Component
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Construct.html" data-search="can.Construct">
				can.Construct
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Control.html" data-search="can.Control">
				can.Control
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.List.html" data-search="can.List">
				can.List
			</a>
			
	   </li>
	
	   <li class="search-container active">
	   		<a href="can.Map.html" data-search="can.Map">
				can.Map
			</a>
			
				
	<ul class="primary-grouping">
		
			
				
					
					<li class="heading search-container">
						<span>prototype</span>
						
	<ul >
		
			
				
				
					<li class="search-container  ">
						<a 	class="property" 
							href="can.Map.prototype.COMPUTE-ATTR.html" 
							data-search="can.Map.prototype.COMPUTE-ATTR">
							COMPUTE-ATTR
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="property" 
							href="can.Map.prototype.DEFAULT-ATTR.html" 
							data-search="can.Map.prototype.DEFAULT-ATTR">
							DEFAULT-ATTR
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.attr.html" 
							data-search="attr">
							attr
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.bind.html" 
							data-search="bind">
							bind
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.compute.html" 
							data-search="compute">
							compute
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.each.html" 
							data-search="each">
							each
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.removeAttr.html" 
							data-search="removeAttr">
							removeAttr
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.serialize.html" 
							data-search="serialize">
							serialize
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.prototype.unbind.html" 
							data-search="unbind">
							unbind
						</a>
						
					</li>
				
			
			
		
			
		
	</ul>

					</li>
					
				
				
			
			
		
			
				
					
					<li class="heading search-container">
						<span>static</span>
						
	<ul >
		
			
				
				
					<li class="search-container  ">
						<a 	class="function" 
							href="can.Map.keys.html" 
							data-search="keys">
							keys
						</a>
						
					</li>
				
			
			
		
			
		
	</ul>

					</li>
					
				
				
			
			
		
			
				
					
					<li class="heading search-container">
						<span>Plugins</span>
						
	<ul >
		
			
				
				
					<li class="search-container  ">
						<a 	class="constructor" 
							href="can.LazyMap.html" 
							data-search="can.LazyMap">
							can.LazyMap
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container parent ">
						<a 	class="page" 
							href="can.Map.attributes.html" 
							data-search="attributes">
							attributes
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container parent ">
						<a 	class="page" 
							href="can.Map.backup.html" 
							data-search="backup">
							backup
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container parent ">
						<a 	class="page" 
							href="can.Map.delegate.html" 
							data-search="delegate">
							delegate
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container parent ">
						<a 	class="property" 
							href="can.Map.prototype.define.html" 
							data-search="define">
							define
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container parent ">
						<a 	class="function" 
							href="can.Map.setter.html" 
							data-search="setter">
							setter
						</a>
						
					</li>
				
			
			
		
			
				
				
					<li class="search-container parent ">
						<a 	class="page" 
							href="can.Map.validations.html" 
							data-search="validations">
							validations
						</a>
						
					</li>
				
			
			
		
	</ul>

					</li>
					
				
				
			
			
		
	</ul>

			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Model.html" data-search="can.Model">
				can.Model
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Model.List.html" data-search="can.Model.List">
				can.Model.List
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.compute.html" data-search="can.compute">
				can.compute
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.ejs.html" data-search="can.ejs">
				can.ejs
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.event.html" data-search="can.event">
				can.event
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.fixture.html" data-search="can.fixture">
				can.fixture
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.mustache.html" data-search="can.mustache">
				can.mustache
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.route.html" data-search="can.route">
				can.route
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.stache.html" data-search="can.stache">
				can.stache
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.util.html" data-search="can.util">
				can.util
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.view.html" data-search="can.view">
				can.view
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.view.bindings.html" data-search="can.view.bindings">
				can.view.bindings
			</a>
			
	   </li>
	
</ul>
	</nav>
	
	
	
	<article class="content docs">
	
	
		
		<section class="title">
			<div class="heading">
<h1>can.Map</h1>
	<ul class="tags">
		<li>constructor</li>
	</ul>
	<span class="module">can/map</span>
	<span class="release">2.0</span>
</div>

<div class="sub-heading">
	
	
	<span class="inherits">inherits: <a href="can.Construct.html">can.Construct</a></span>
</div>

<ul class="links">
    
        <li><a href="../docco/map/map.html">docco</a></li>
    
	
		<li><a href="">source</a></li>
	
	
	
		<li><a href="../can/map/test.html">tests</a></li>
	
</ul>
<br />
		</section>
		
		
		
		<section class="contents">
		</section>
		
		
		

		
		<section class="description">
			<p>Create observable objects.</p>

		</section>
		

		
			
				<section class="signature">
					<h2 id="sig_newcan_Map__props__">new can.Map([props])
</h2>
<div class="signature-wrapper">
<p>Creates a new instance of can.Map.</p>


	<h3>Parameters</h3>

	<ol class="parameters">
		
		<li class="parameter">
			<h4>props
				<code>{Object}</code><span class="pull-right optional">Optional</span></h4>
			<div class="description">
				<p>Properties and values to seed the Observe with.</p>

			</div>
			
			
			
		</li>
		
	</ol>


	<h3>Returns</h3>
	<div class="returns">
		<h4><code>{<a href="can.Map.html" >can.Map</a>}</code></h4>
		<div class="description">
			<p>An instance of <code>can.Map</code> with the properties from <em>props</em>.</p>

		</div>
		
		
	</div>
	





</div>

				</section>
			
				<section class="signature">
					<h2 id="sig_can_Map__name___staticProperties__instanceProperties_">can.Map([name,] [staticProperties,] instanceProperties)
</h2>
<div class="signature-wrapper">
<p>Creates a new extended constructor function.</p>
<p>This is deprecated. In CanJS 1.2, by default, calling the constructor function
without <code>new</code> will create a <code>new</code> instance. Use <a href="can.Construct.extend.html">can.Map.extend</a>
instead of calling the constructor to extend.</p>







</div>

				</section>
			
		
		
		
		

		
		<section class="comment">
			<p><code>can.Map</code> provides a way for you to listen for and keep track of changes
to objects. When you use the getters and setters provided by <code>can.Map</code>,
events are fired that you can react to. <code>can.Map</code> also has support for
working with deep properties. Observable arrays are also available with
<code><a href="can.List.html">can.List</a></code>, which is based on <code>can.Map</code>.</p>
<h2>Working with Observes</h2>
<p>To create an Observe, use <code>new can.Map([props])</code>. This will return a
copy of <code>props</code> that emits events when its properties are changed with
<code><a href="can.Map.prototype.attr.html">attr</a></code>.</p>
<p>You can read the values of properties on Observes directly, but you should
never set them directly. You can also read property values using <code>attr</code>.
Usually, you will want to do this when creating a <code><a href="can.compute.html">can.compute</a></code> or when
live-binding properties in an <a href="can.ejs.html">EJS</a> template. (If you are using
<a href="can.mustache.html">Mustache</a>, you don't need to use <code>attr</code>.)</p>
<pre><code class="lang-javascript">var aName = {a: 'Alexis'},
    map = new can.Map(aName);
<p>// Observes are copies of data:
aName === map; // false</p>
<p>// reading from an Observe:
map.attr();    // {a: 'Alexis'}
map.a;         // 'Alexis'
map.attr('a'); // 'Alexis'</p>
<p>// setting an Observe's property:
map.attr('a', 'Alice');
map.a; // Alice</p>
<p>// removing an Observe's property;
map.removeAttr('a');
map.attr(); // {}</p>
<p>// Don't do this!
map.a = 'Adam'; // wrong!</code></pre>
Find out more about manipulating properties of Observes under
<a href="can.Map.prototype.attr.html">attr</a> and <a href="can.Map.prototype.removeAttr.html">removeAttr</a>.</p>
<h2>Listening to changes</h2>
<p>The real power of observable objects comes from being able to react to
properties being added, set, and removed. Observes emit events when
properties are changed that you can bind to.</p>
<p><code>can.Map</code> has two types of events that fire due to changes on an Observe:</p>
<ul>
<li>the <em>change</em> event fires on every change to an Observe.</li>
<li>an event named after the property name fires on every change to that property.</li>
</ul>
<pre><code class="lang-javascript">var o = new can.Map({});
o.bind('change', function(ev, attr, how, newVal, oldVal) {
    console.log('Something on o changed.');
});
o.bind('a', function(ev, newVal, oldVal) {
    console.log('a was changed.');
});
<p>o.attr('a', 'Alexis'); // 'Something on o changed.'
// 'a was changed.'
o.attr({
'a': 'Alice',      // 'Something on o changed.' (for a's change)
'b': 'Bob'         // 'Something on o changed.' (for b's change)
});                    // 'a was changed.'</p>
<p>o.removeAttr('a');     // 'Something on o changed.'
// 'a was changed.'</code></pre>
For more detail on how to use these events, see <a href="can.Map.prototype.bind.html">bind</a> and
<a href="can.Map.prototype.unbind.html">unbind</a>. There is also a plugin called <a href="can.Map.delegate.html">delegate</a>
that makes binding to specific types of events easier:</p>
<pre><code class="lang-javascript">var o = new can.Map({});
o.delegate('a', 'add', function(ev, newVal, oldVal) {
    console.log('a was added.');
});
o.delegate('a', 'set', function(ev, newVal, oldVal) {
    console.log('a was set.');
});
o.delegate('a', 'remove', function(ev, newVal, oldVal) {
    console.log('a was removed.');
});
o.delegate('a', 'change', function(ev, newVal, oldVal) {
    console.log('a was changed.');
});
<p>o.attr('a', 'Alexis'); // 'a was added.'
// 'a was changed.'</p>
<p>o.attr('a', 'Alice'); // 'a was set.'
// 'a was changed.'</p>
<p>o.removeAttr('a'); // 'a was removed.'
// 'a was changed.'</code></pre></p>

		</section>
		
		

		
	
	
	</article>
	
	

</div>





	
	
	<footer>
		<nav class="container">
			<a class="brand" href="index.html"></a>
			<ul class='nav'>
				<li >
	              <a href="../../index.html">Home</a>
	            </li>
		        <li><a href='../guides/index.html'>guides</a></li>
		        <li class='active'><a href='index.html'>api</a></li>
		        <li class="">
		          <a href="../../community.html#!forums">Community</a>
		        </li>
		        <li >
	              <a href="../../blog/index.html">Blog</a>
	            </li>
		        <li >
	              <a href="../../download.html">Download</a>
	            </li>
            </ul>
		</nav>
	</footer>
	

    
    <!--<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-2302003-11']);
	  _gaq.push(['_setDomainName', 'canjs.com']);
	  _gaq.push(['_setAllowLinker', true]);
	  _gaq.push(['_trackPageview']);
	
	  (function() {
	  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();
	
	</script>-->
	
	<script type="text/javascript">
		var docObject = {"parent":"canjs","templates":"/Users/justin/dev/canjs.com/theme/templates","static":"/Users/justin/dev/canjs.com/theme/static","versionsSelectText":"CanJS v<%= version %>","glob":{"ignore":"guides/*.md","pattern":"**/*.{md,js}","cwd":"/Users/justin/dev/canjs.com/2.0/can"},"dest":"/Users/justin/dev/canjs.com/2.0/docs","generators":["html"],"urls":{"builderData":"http://bitbuilder.herokuapp.com/canjs","builder":"http://bitbuilder.herokuapp.com/can.custom.js","bithub":"http://api.bithub.com/api/v1/events/","cdn":"//canjs.com/release/"},"versions":[{"branch":"master","number":"2.1"},{"number":"2.0"},{"number":"1.1"}],"docConfigDest":"../../documentjs.json","project":{"version":"2.0","name":"v2.0.7"},"name":"can.Map","type":"constructor","description":"<p>Create observable objects.</p>\n","src":"map/map.js","inherits":"can.Construct","test":"can/map/test.html","plugin":"can/map","release":"2.0","links":[{"href":"../docco/map/map.html","title":"docco"}],"signatures":[{"code":"new can.Map([props])","description":"<p>Creates a new instance of can.Map.</p>\n","params":[{"types":[{"type":"Object","options":[]}],"optional":true,"name":"props","description":"<p>Properties and values to seed the Observe with.</p>\n"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>An instance of <code>can.Map</code> with the properties from <em>props</em>.</p>\n"}},{"code":"can.Map([name,] [staticProperties,] instanceProperties)","description":"<p>Creates a new extended constructor function.</p>\n<p>This is deprecated. In CanJS 1.2, by default, calling the constructor function\nwithout <code>new</code> will create a <code>new</code> instance. Use [can.Construct.extend can.Map.extend]\ninstead of calling the constructor to extend.</p>\n","params":[]}],"comment":" ","children":[{"type":"prototype","description":"","name":"can.Map.prototype","parent":"can.Map","src":"map/map.js","children":[{"type":"property","name":"can.Map.prototype.COMPUTE-ATTR","description":"<p>Specify an attribute that is computed from other attributes.</p>\n","types":[{"type":"can.compute","description":"<p>A compute that reads values on instances of the\nmap and returns a derived value.  The compute may also be a getter-setter\ncompute and able to be passed a value.</p>\n"}],"title":"","parent":"can.Map.prototype","order":0,"comment":" ","src":"map/doc/prototype.compute-attr.md"},{"type":"property","name":"can.Map.prototype.DEFAULT-ATTR","description":"<p>Specify a default property and value.</p>\n","types":[{"type":"*","description":"<p>A value of any type other than a function that will\nbe set as the <code>DEFAULT-ATTR</code> attribute's value.</p>\n"}],"title":"","parent":"can.Map.prototype","order":1,"comment":" ","src":"map/doc/prototype.default-attr.md"},{"type":"function","name":"can.Map.prototype.attr","description":"<p>Get or set properties on an Map.</p>\n","title":"attr","parent":"can.Map.prototype","order":2,"signatures":[{"code":"map.attr()","description":"<p>Gets a collection of all the properties in this <code>can.Map</code>.</p>\n","params":[],"returns":{"types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"}"},{"type":"an"},{"type":"object"},{"type":"with"},{"type":"all"},{"type":"the"},{"type":"properties"},{"type":"in"},{"type":"this"}]}]}],"description":"<p>@return {Object&lt;String, } an object with all the properties in this <code>can.Map</code>.</p>\n"}},{"code":"map.attr(key)","description":"<p>Reads a property from this <code>can.Map</code>.</p>\n","params":[{"types":[{"type":"String"}],"name":"key","description":"<p>the property to read</p>\n"}],"returns":{"types":[{"type":"the"},{"type":"value"},{"type":"assigned"},{"type":"to"}],"description":"<p>@return { the value assigned to <em>key</em>.</p>\n"}},{"code":"map.attr(key, value)","description":"<p>Assigns <em>value</em> to a property on this <code>can.Map</code> called <em>key</em>.</p>\n","params":[{"types":[{"type":"String"}],"name":"key","description":"<p>the property to set</p>\n"},{"types":[{"type":"the"},{"type":"value"},{"type":"to"},{"type":"assign"},{"type":"to"}],"name":"_key_.","description":""}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>this Map, for chaining</p>\n"}},{"code":"map.attr(obj[, removeOthers])","description":"<p>Assigns each value in <em>obj</em> to a property on this <code>can.Map</code> named after the\ncorresponding key in <em>obj</em>, effectively merging <em>obj</em> into the Map.</p>\n","params":[{"types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"}"},{"type":"obj"},{"type":"a"},{"type":"collection"},{"type":"of"},{"type":"key-value"},{"type":"pairs"},{"type":"to"}]}]}],"name":"set.","description":"<p>If any properties already exist on the <code>can.Map</code>, they will be overwritten.</p>\n"},{"types":[{"type":"bool"}],"optional":true,"name":"removeOthers","defaultValue":"false","description":"<p>whether to remove keys not present in <em>obj</em>.\nTo remove keys without setting other keys, use <code>[can.Map::removeAttr removeAttr]</code>.</p>\n"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>this Map, for chaining</p>\n"}}],"comment":" ","src":"map/doc/prototype.attr.md"},{"type":"function","name":"can.Map.prototype.bind","description":"<p>Bind event handlers to an Map.</p>\n","title":"bind","parent":"can.Map.prototype","order":3,"signatures":[{"code":"map.bind(eventType, handler)","description":"","params":[{"types":[{"type":"String"}],"name":"eventType","description":"<p>the type of event to bind this handler to</p>\n"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details.</p>\n"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>this Map, for chaining</p>\n"}}],"comment":" ","src":"map/doc/prototype.bind.md"},{"type":"function","name":"can.Map.prototype.compute","description":"<p>Make a can.compute from an observable property.</p>\n","title":"compute","parent":"can.Map.prototype","order":4,"signatures":[{"code":"map.compute(attrName)","description":"","params":[{"types":[{"type":"String"}],"name":"attrName","description":"<p>the property to bind to</p>\n"}],"returns":{"types":[{"type":"can.compute"}],"description":"<p>a [can.compute] bound to <em>attrName</em></p>\n"}}],"comment":" ","src":"map/doc/prototype.compute.md"},{"type":"function","name":"can.Map.prototype.each","description":"<p>Call a function on each property of an Map.</p>\n","title":"each","parent":"can.Map.prototype","order":5,"signatures":[{"code":"map.each( callback(item, propName ) )","description":"<p><code>each</code> iterates through the Map, calling a function\nfor each property value and key.</p>\n","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*"}],"name":"item"},{"types":[{"type":"String"}],"name":"propName"}]}],"name":"callback","description":"<p>the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.</p>\n"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>this Map, for chaining</p>\n"}}],"comment":" ","src":"map/doc/prototype.each.md"},{"type":"function","name":"can.Map.prototype.removeAttr","description":"<p>Remove a property from an Map.</p>\n","title":"removeAttr","parent":"can.Map.prototype","order":6,"signatures":[{"code":"map.removeAttr(attrName)","description":"","params":[{"types":[{"type":"String"}],"name":"attrName","description":"<p>the name of the property to remove</p>\n"}],"returns":{"types":[{"type":"*"}],"description":"<p>the value of the property that was removed</p>\n"}}],"comment":" ","src":"map/doc/prototype.removeAttr.md"},{"type":"function","name":"can.Map.prototype.serialize","description":"<p>Serialize this object to something that can be passed to <code>JSON.stringify</code>.</p>\n","title":"serialize","parent":"can.Map.prototype","order":7,"signatures":[{"code":"map.serialize()","description":"<p>Get the serialized Object form of the map.  Serialized\ndata is typically used to send back to a server.</p>\n<p>o.serialize() //-&gt; { name: 'Justin' }</p>\n<p>Serialize currently returns the same data\nas [can.Map.prototype.attrs].  However, in future\nversions, serialize will be able to return serialized\ndata similar to [can.Model].  The following will work:</p>\n<p>new Map({time: new Date()})\n.serialize() //-&gt; { time: 1319666613663 }</p>\n","params":[],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>a JavaScript Object that can be\nserialized with <code>JSON.stringify</code> or other methods.</p>\n"}}],"src":"map/doc/prototype.serialize.md"},{"type":"function","name":"can.Map.prototype.unbind","description":"<p>Unbind event handlers from an Map.</p>\n","title":"unbind","parent":"can.Map.prototype","order":8,"signatures":[{"code":"map.unbind(eventType[, handler])","description":"","params":[{"types":[{"type":"String"}],"name":"eventType","description":"<p>the type of event to unbind, exactly as passed to <code>bind</code></p>\n"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"handler","description":"<p>the handler to unbind</p>\n"}]}],"comment":" ","src":"map/doc/prototype.unbind.md"},{"type":"function","name":"can.Map.prototype._attrs","params":[{"types":[{"type":"Object","options":[]}],"name":"props","description":""},{"types":[{"type":"Boolean"}],"name":"remove","description":"<p>true if you should remove properties that are not in props</p>\n"}],"parent":"can.Map.prototype","description":"<p>Set multiple properties on the observable</p>\n","hide":true,"src":"map/map.js"}]},{"type":"static","name":"can.Map.static","params":[],"parent":"can.Map","description":"","src":"map/map.js","children":[{"type":"function","name":"can.Map.keys","description":"<p>Iterate over the keys of an Map.</p>\n","title":"keys","parent":"can.Map.static","order":0,"signatures":[{"code":"can.Map.keys(map)","description":"","params":[{"types":[{"type":"can.Map"}],"name":"map","description":"<p>the <code>can.Map</code> to get the keys from</p>\n"}],"returns":{"types":[{"type":"Array","options":[]}],"description":"<p>array An array containing the keys from <em>map</em>.</p>\n"}}],"comment":" ","src":"map/doc/static.keys.md"},{"type":"function","name":"can.Map.static.keys","params":[{"types":[{"type":"can.Map"}],"name":"map","description":""}],"parent":"can.Map.static","description":"<p>Returns list of keys in a Map</p>\n","hide":true,"comment":"undefined@returns {Array}\n","src":"map/map.js"}]},{"name":"can.Map.plugins","title":"Plugins","type":"group","parent":"can.Map","description":"","order":2,"children":[{"type":"constructor","name":"can.LazyMap","description":"<p>Create observable objects that initialize on demand.</p>\n","title":"","inherits":"can.Map","parent":"can.Map.plugins","plugin":"can/map/lazy","release":"2.1","test":"can/LazyMap/lazy/test.html","signatures":[{"code":"new can.LazyLazyMap([props])","description":"<p>Creates a new instance of can.LazyMap.</p>\n","params":[{"types":[{"type":"Object","options":[]}],"optional":true,"name":"props","description":"<p>Properties and values to initialize the Map with.</p>\n"}],"returns":{"types":[{"type":"can.LazyMap"}],"description":"<p>An instance of <code>can.LazyMap</code> with the properties from <em>props</em>.</p>\n"}}],"comment":" ","src":"map/lazy/lazy.md"},{"type":"page","name":"can.Map.attributes","description":"","title":"attributes","parent":"can.Map.plugins","plugin":"can/map/attributes","test":"can/map/attributes/test.html","download":"http://donejs.com/can/dist/can.map.attributes.js","deprecated":[{"version":"2.1","description":"<p>The attributes plugin (and the setter plugin) have been deprecated in\nfavor of the new [can.Map.prototype.define define] plugin, which provides the same\nfunctionality. It will still be maintained up to 3.0 and potentially after.\nProjects using converters or serializers should consider switching to [can.Map.prototype.define.type define's type]\nand [can.Map.prototype.define.serialize define's serialize].</p>\n"}],"comment":" ","src":"map/attributes/doc/attributes.md","children":[{"name":"can.Map.attributes.prototype","title":"prototype","type":"group","parent":"can.Map.attributes","description":"","order":0,"children":[{"type":"function","name":"can.Map.prototype.attributes.serialize","description":"<p>Serializes the observe's properties using the [can.Map.attributes attribute plugin].</p>\n","title":"serialize","parent":"can.Map.attributes.prototype","order":0,"signatures":[{"code":"observe.serialize([attrName])","description":"","params":[{"types":[{"type":"String"}],"optional":true,"name":"attrName","description":"<p>If passed, returns only a serialization of the named attribute.</p>\n"}],"returns":{"types":[{"type":"String"}],"description":"<p>A serialization of this Observe.</p>\n"}}],"comment":" ","src":"map/attributes/doc/prototype.serialize.md"}]},{"name":"can.Map.attributes.static","title":"static","type":"group","parent":"can.Map.attributes","description":"","order":0,"children":[{"type":"property","name":"can.Map.attributes.static.attributes","description":"<p><code>can.Map.attributes</code> is a property that contains key/value pair(s) of an attribute's name and its\nrespective type for using in [can.Map.attributes.static.convert convert] and [can.Map.prototype.serialize serialize].</p>\n","title":"attributes","parent":"can.Map.attributes.static","order":0,"src":"map/attributes/doc/static.attributes.md"},{"type":"property","name":"can.Map.attributes.static.convert","description":"<p>You often want to convert from what the observe sends you to a form more useful to JavaScript.\nFor example, contacts might be returned from the server with dates that look like: &quot;1982-10-20&quot;.\nWe can observe to convert it to something closer to <code>new Date(1982,10,20)</code>.</p>\n","title":"convert","parent":"can.Map.attributes.static","order":1,"src":"map/attributes/doc/static.convert.md"},{"type":"property","name":"can.Map.attributes.static.serialize","description":"<p><code>can.Map.serialize</code> is an object of name-function pairs that are used to\nserialize attributes.</p>\n","title":"serialize","parent":"can.Map.attributes.static","order":2,"src":"map/attributes/doc/static.serialize.md"}]},{"name":"can.Map.prototype.convert","type":"function","description":"","hide":true,"title":"","parent":"can.Map.attributes","src":"map/attributes/attributes.js"},{"name":"can.Map.setup","type":"function","description":"<p><code>can.Map.static.setup</code> overrides default <code>can.Map</code> setup to provide\nfunctionality for attributes.</p>\n","hide":true,"title":"","parent":"can.Map.attributes","src":"map/attributes/attributes.js"}]},{"type":"page","name":"can.Map.backup","description":"<p>can.Map.backup is a plugin that provides a dirty bit for properties on an Map,\nand lets you restore the original values of an Map's properties after they are changed.</p>\n","title":"backup","parent":"can.Map.plugins","plugin":"can/map/backup","test":"can/map/backup/test.html","src":"map/backup/doc/backup.md","children":[{"type":"function","name":"can.Map.backup.prototype.backup","description":"<p>Save the values of the properties of an Map.</p>\n","title":"backup","plugin":"can/map/backup","parent":"can.Map.backup","order":0,"signatures":[{"code":"map.backup()","description":"<p><code>backup</code> backs up the current state of the properties of an Observe and marks\nthe Observe as clean. If any of the properties change value, the original\nvalues can be restored with [can.Map.backup.prototype.restore restore].</p>\n","params":[],"returns":{"types":[{"type":"can.Map"}],"description":"<p>The map, for chaining.</p>\n"}}],"comment":" ","src":"map/backup/doc/prototype.backup.md"},{"type":"function","name":"can.Map.backup.prototype.isDirty","description":"<p>Check whether an Observe has changed since the last time it was backed up.</p>\n","title":"isDirty","plugin":"can/map/backup","parent":"can.Map.backup","order":1,"signatures":[{"code":"map.isDirty([deep])","description":"<p><code>isDirty</code> checks whether any properties have changed value or whether any properties have\nbeen added or removed since the last time the Observe was backed up. If <em>deep</em> is <code>true</code>,\nIf the Observe has never been backed up, <code>isDirty</code> returns <code>undefined</code>.\n<code>isDirty</code> will include nested Observes in its checks.</p>\n","params":[{"types":[{"type":"bool"}],"optional":true,"name":"deep","defaultValue":"false","description":"<p>whether to check nested Observes</p>\n"}],"returns":{"types":[{"type":"bool"}],"description":"<p>Whether the Observe has changed since the last time it was [can.Map.backup.prototype.backup backed up].</p>\n<pre><code class=\"lang-javascript\">var recipe = new can.Map({\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\n<p>recipe.isDirty();     // false\nrecipe.backup();</p>\n<p>recipe.attr('title', 'Flapjack Mix');\nrecipe.isDirty();     // true\nrecipe.restore();\nrecipe.isDirty();   // false</p>\n<p>recipe.attr('ingredients.0.quantity', '7 cups');\nrecipe.isDirty();     // false\nrecipe.isDirty(true); // true</p>\n<p>recipe.backup();\nrecipe.isDirty();     // false\nrecipe.isDirty(true); // false</code></pre></p>\n"}}],"src":"map/backup/doc/prototype.isDirty.md"},{"type":"function","name":"can.Map.backup.prototype.restore","description":"<p>Restore saved values of an Observe's properties.</p>\n","title":"restore","plugin":"can/map/backup","parent":"can.Map.backup","order":2,"signatures":[{"code":"map.restore( [deep] )","description":"<p><code>restore</code> sets the properties of an Observe back to what they were the last time\n[can.Map.backup.prototype.backup backup] was called. If <em>deep</em> is <code>true</code>,\n<code>restore</code> will also restore the properties of nested Observes.</p>\n<p><code>restore</code> will not remove properties that were added since the last backup, but it\nwill re-add properties that have been removed.</p>\n","params":[{"types":[{"type":"bool"}],"optional":true,"name":"deep","defaultValue":"false","description":"<p>whether to restore properties in nested Observes</p>\n"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>The Observe, for chaining.</p>\n<pre><code class=\"lang-javascript\">var recipe = new can.Map({\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\n<p>recipe.backup();</p>\n<p>recipe.attr('title', 'Flapjack Mix');\nrecipe.restore();\nrecipe.attr('title'); // 'Pancake Mix'</p>\n<p>recipe.attr('ingredients.0.quantity', '7 cups');\nrecipe.restore();\nrecipe.attr('ingredients.0.quantity'); // '7 cups'\nrecipe.restore(true);\nrecipe.attr('ingredients.0.quantity'); // '6 cups'</code></pre></p>\n<h2>Events</h2>\n<p>When <code>restore</code> sets values or re-adds properties, the same events will be fired (including\n<em>change</em>, <em>add</em>, and <em>set</em>) as if the values of the properties had been set using <code>[can.Map.prototype.attr attr]</code>.</p>\n"}}],"src":"map/backup/doc/prototype.restore.md"}]},{"type":"page","name":"can.Map.delegate","description":"<p>The <strong>delegate</strong> plugin allows you to listen to more specific event changes on\n[can.Map Maps].  It allows you to specify:</p>\n","title":"delegate","parent":"can.Map.plugins","plugin":"can/map/delegate","test":"can/map/delegate/test.html","src":"map/delegate/doc/delegate.md","children":[{"type":"function","name":"can.Map.prototype.delegate","description":"","title":"delegate","parent":"can.Map.delegate","order":0,"plugin":"can/map/delegate","signatures":[{"code":"observe.delegate( selector, event, handler )","description":"<p><code>delegate( selector, event, handler(ev,newVal,oldVal,from) )</code> listen for changes\nin a child attribute from the parent. The child attribute\ndoes not have to exist.</p>\n<p>// create an observable\nvar observe = new can.Map({\nfoo : {\nbar : &quot;Hello World&quot;\n}\n})</p>\n<p>//listen to changes on a property\nobserve.delegate(&quot;foo.bar&quot;,&quot;change&quot;, function(ev, prop, how, newVal, oldVal){\n// foo.bar has been added, set, or removed\nthis //-&gt;\n});</p>\n<p>// change the property\nobserve.attr('foo.bar',&quot;Goodbye Cruel World&quot;)</p>\n<h2>Types of events</h2>\n<p>Delegate lets you listen to add, set, remove, and change events on property.</p>\n<p><strong>add</strong></p>\n<p>An add event is fired when a new property has been added.</p>\n<p>var o = new can.Control({});\no.delegate(&quot;name&quot;,&quot;add&quot;, function(ev, value){\n// called once\ncan.$('#name').show()\n})\no.attr('name',&quot;Justin&quot;)\no.attr('name',&quot;Brian&quot;);</p>\n<p>Listening to add events is useful for 'setup' functionality (in this case\nshowing the <code>#name</code> element.</p>\n<p><strong>set</strong></p>\n<p>Set events are fired when a property takes on a new value.  set events are\nalways fired after an add.</p>\n<p>o.delegate(&quot;name&quot;,&quot;set&quot;, function(ev, value){\n// called twice\ncan.$('#name').text(value)\n})\no.attr('name',&quot;Justin&quot;)\no.attr('name',&quot;Brian&quot;);</p>\n<p><strong>remove</strong></p>\n<p>Remove events are fired after a property is removed.</p>\n<p>o.delegate(&quot;name&quot;,&quot;remove&quot;, function(ev){\n// called once\n$('#name').text(value)\n})\no.attr('name',&quot;Justin&quot;);\no.removeAttr('name');</p>\n<h2>Wildcards - matching multiple properties</h2>\n<p>Sometimes, you want to know when any property within some part\nof an observe has changed. Delegate lets you use wildcards to\nmatch any property name.  The following listens for any change\non an attribute of the params attribute:</p>\n<p>var o = can.Control({\noptions : {\nlimit : 100,\noffset: 0,\nparams : {\nparentId: 5\n}\n}\n})\no.delegate('options.<em>','change', function(){\nalert('1');\n})\no.delegate('options.</em>*','change', function(){\nalert('2');\n})</p>\n<p>// alerts 1\n// alerts 2\no.attr('options.offset',100)</p>\n<p>// alerts 2\no.attr('options.params.parentId',6);</p>\n<p>Using a single wildcard (<code><em></code>) matches single level\nproperties.  Using a double wildcard (<code></em>*</code>) matches\nany deep property.</p>\n<h2>Listening on multiple properties and values</h2>\n<p>Delegate lets you listen on multiple values at once.  The following listens\nfor first and last name changes:</p>\n<p>var o = new can.Map({\nname : {first: &quot;Justin&quot;, last: &quot;Meyer&quot;}\n})</p>\n<p>o.bind(&quot;name.first,name.last&quot;,\n&quot;set&quot;,\nfunction(ev,newVal,oldVal,from){</p>\n<p>})</p>\n<h2>Listening when properties are a particular value</h2>\n<p>Delegate lets you listen when a property is <strong>set</strong> to a specific value:</p>\n<p>var o = new can.Map({\nname : &quot;Justin&quot;\n})</p>\n<p>o.bind(&quot;name=Brian&quot;,\n&quot;set&quot;,\nfunction(ev,newVal,oldVal,from){</p>\n<p>})</p>\n","params":[{"types":[{"type":"String"}],"name":"selector","description":"<p>The attributes you want to listen for changes in.</p>\n<p>Selector should be the property or\nproperty names of the element you are searching.  Examples:</p>\n<p>&quot;name&quot; - listens to the &quot;name&quot; property changing\n&quot;name, address&quot; - listens to &quot;name&quot; or &quot;address&quot; changing\n&quot;name address&quot; - listens to &quot;name&quot; or &quot;address&quot; changing\n&quot;address.<em>&quot; - listens to property directly in address\n&quot;address.</em>*&quot; - listens to any property change in address\n&quot;foo=bar&quot; - listens when foo is &quot;bar&quot;</p>\n"},{"types":[{"type":"String"}],"name":"event","description":"<p>The event name.  One of (&quot;set&quot;,&quot;add&quot;,&quot;remove&quot;,&quot;change&quot;)</p>\n"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"name":"ev"},{"name":"newVal"},{"name":"oldVal"},{"name":"prop"}]}],"name":"handler","description":"<p>The callback handler\ncalled with:</p>\n<ul>\n<li>newVal - the new value set on the observe</li>\n<li>oldVal - the old value set on the observe</li>\n<li>prop - the prop name that was changed</li>\n</ul>\n"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>the observe for chaining</p>\n"}}],"src":"map/delegate/doc/prototype.delegate.md"},{"type":"function","name":"can.Map.prototype.undelegate","description":"","title":"undelegate","parent":"can.Map.delegate","order":1,"plugin":"can/map/delegate","signatures":[{"code":"observe.undelegate( selector, event, handler )","description":"<p><code>undelegate( selector, event, handler )</code> removes a delegated event handler from an observe.</p>\n<p>observe.undelegate(&quot;name&quot;,&quot;set&quot;, handler )</p>\n","params":[{"types":[{"type":"String"}],"name":"selector","description":"<p>the attribute name of the object you want to undelegate from.</p>\n"},{"types":[{"type":"String"}],"name":"event","description":"<p>the event name</p>\n"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>the callback handler</p>\n"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>the observe for chaining</p>\n"}}],"src":"map/delegate/doc/prototype.undelegate.md"}]},{"type":"property","name":"can.Map.prototype.define","description":"<p>Defines the\ntype, initial value, get, set, remove, and serialize behavior for attributes\nof a [can.Map].</p>\n","types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"can.Map.prototype.define.attrDefinition"}]}],"description":"<p>A map of\nattribute names to [can.Map::define.attrDefinition attribute definition]\nobjects.</p>\n"}],"title":"define","parent":"can.Map.plugins","comment":" ","src":"map/define/doc/define.md","children":[{"type":"function","name":"can.Map.prototype.define.TypeConstructor","description":"<p>Provides a constructor function to be used to convert any value passed into [can.Map::attr attr] into an appropriate value</p>\n","title":"Type","parent":"can.Map.prototype.define","signatures":[{"code":"constructorFunc","description":"<p>A constructor function can be provided that is called to convert incoming values set on this property, like:</p>\n<pre><code>define: {\n  prop: {\n    Type: Person\n  }\n}\n</code></pre>\n","params":[]}],"comment":" ","src":"map/define/doc/TypeConstructor.md"},{"type":"function","name":"can.Map.prototype.define.ValueConstructor","description":"<p>Provides a constructor function to be used to provide a default value for a certain property of a can.Map.  This constructor will be invoked with <code>new</code> each time a new instance of the map is created.</p>\n","title":"Value","parent":"can.Map.prototype.define","signatures":[{"code":"constructorFunc","description":"<p>A constructor function can be provided that is called to create a default value used for this property, like:</p>\n<pre><code>define: {\n  prop: {\n    Value: Array\n  },\n  person: {\n    Value: Person\n  }\n}\n</code></pre>\n","params":[]}],"comment":" ","src":"map/define/doc/ValueConstructor.md"},{"type":"typedef","name":"can.Map.prototype.define.attrDefinition","description":"<p>Defines the type, initial value, and get, set, and remove behavior for an attribute of a [can.Map].</p>\n","title":"attrDefinition","types":[{"type":"Object","options":[{"name":"value","description":"<p>Specifies the initial value of the attribute or\na function that returns the initial value. For example, a default value of <code>0</code> can be\nspecified like:</p>\n<pre><code>define: {\n  prop: {\n    value: 0\n  }\n}\n</code></pre>\n<p><code>Object</code> types should not be specified directly on <code>value</code> because that same object will\nbe shared on every instance of the Map.  Instead, a [can.Map::define.value value function] that\nreturns a fresh copy can be provided:</p>\n<pre><code>define: {\n  prop: {\n    value: function(){\n      return {foo: &quot;bar&quot;}\n    }\n  }\n}\n</code></pre>\n","types":[{"type":"can.Map.prototype.define.value"},{"type":"*"}]},{"name":"Value","description":"<p>Specifies a function that will be called with <code>new</code> whose result is\nset as the initial value of the attribute. For example, if the default value should be a can.List:</p>\n<pre><code>define: {\n  prop: {\n    Value: can.List\n  }\n}\n</code></pre>\n","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]},{"name":"type","description":"<p>Specifies the type of the\nattribute.  The type can be specified as either a [can.Map.prototype.define.type type function]\nthat returns the type coerced value or one of the following strings:</p>\n<ul>\n<li><code>&quot;string&quot;</code> - Converts the value to a string.</li>\n<li><code>&quot;date&quot;</code> - Converts the value to a date or `null if the date can not be converted.</li>\n<li><code>&quot;number&quot;</code> - Passes the value through <code>parseFloat</code>.</li>\n<li><code>&quot;boolean&quot;</code> - Converts falsey, <code>&quot;false&quot;</code> or <code>&quot;0&quot;</code> to <code>false</code> and everything else to true.</li>\n<li><code>&quot;*&quot;</code> - Prevents the default type coersion of converting Objects to [can.Map]s and Arrays to [can.List]s.</li>\n</ul>\n<p>The following example converts the <code>count</code> property to a number and the <code>items</code> property to an array:</p>\n<pre><code> define: {\n   count: {type: &quot;number&quot;},\n   items: {\n     type: function(newValue){\n       if(typeof newValue === &quot;string&quot;) {\n         return newValue.split(&quot;,&quot;)\n       } else if( can.isArray(newValue) ) {\n         return newValue;\n       }\n     }\n   }\n }\n</code></pre>\n","types":[{"type":"can.Map.prototype.define.type"},{"type":"String"}]},{"name":"Type","description":"<p>A constructor function that takes\nthe value passed to [can.Map::attr attr] as the first argument and called with\nnew. For example, if you want whatever\ngets passed to go through <code>new Array(newValue)</code> you can do that like:</p>\n<pre><code>define: {\n  items: {\n    Type: Array\n  }\n}\n</code></pre>\n<p>If the value passed to [can.Map::attr attr] is already an Array, it will be left as is.</p>\n","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]},{"name":"set","description":"<p>A set function that specifies what should happen when an attribute\nis set on a [can.Map]. <code>set</code> is called with the result of <code>type</code> or <code>Type</code>. The following\ndefines a <code>page</code> setter that updates the map's offset:</p>\n<pre><code>define: {\n  page: {\n    set: function(newVal){\n      this.attr('offset', (parseInt(newVal) - 1) * \n                           this.attr('limit'));\n    }\n  }\n}\n</code></pre>\n","types":[{"type":"can.Map.prototype.define.set"}]},{"name":"get","description":"<p>A function that specifies how the value is retrieved.  The get function is\nconverted to an [can.compute.async async compute].  It should derive its value from other values\non the map. The following\ndefines a <code>page</code> getter that reads from a map's offset and limit:</p>\n<pre><code>define: {\n  page: {\n    get: function (newVal) {\n      return Math.floor(this.attr('offset') / \n                        this.attr('limit')) + 1;\n    }\n  }\n}\n</code></pre>\n<p>A <code>get</code> definition makes the property <strong>computed</strong> which means it will not be serialized by default.</p>\n","types":[{"type":"can.Map.prototype.define.get"}]},{"name":"remove","description":"<p>A function that specifies what should happen when an attribute is removed\nwith [can.Map::removeAttr removeAttr]. The following removes a <code>modelId</code> when <code>makeId</code> is removed:</p>\n<pre><code>define: {\n  makeId: {\n    remove: function(){\n      this.removeAttr(&quot;modelId&quot;);\n    }\n  }\n}\n</code></pre>\n","types":[{"type":"can.Map.prototype.define.remove"}]},{"name":"serialize","description":"<p>Specifies the behavior of the\nproperty when [can.Map::serialize serialize] is called.</p>\n<p>By default, serialize does not include computed values. Properties with a <code>get</code> definition\nare computed and therefore are not added to the result.  Non-computed properties values are\nserialized if possible and added to the result.</p>\n<pre><code>Paginate = can.Map.extend({\n  define: {\n    pageNum: {\n      get: function(){ return this.offset() / 20 }\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-&gt; {offset: 40}\n</code></pre>\n<p>If <code>true</code> is specified, computed properties will be serialized and added to the result.</p>\n<pre><code>Paginate = can.Map.extend({\n  define: {\n    pageNum: { \n      get: function(){ return this.offset() / 20 },\n      serialize: true\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-&gt; {offset: 40, pageNum: 2}\n</code></pre>\n<p>If <code>false</code> is specified, non-computed properties will not be added to the result.</p>\n<pre><code>Paginate = can.Map.extend({\n  define: {\n    offset: {\n      serialize: false\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-&gt; {}\n</code></pre>\n<p>If a [can.Map.prototype.define.serialize serialize function] is specified, the result\nof the function is added to the result.</p>\n<pre><code>Paginate = can.Map.extend({\n  define: {\n    offset: {\n      serialize: function(offset){\n        return (offset / 20)+1\n      }\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-&gt; {offset: 3}\n</code></pre>\n","types":[{"type":"can.Map.prototype.define.serialize"},{"type":"Boolean"}]}]}],"parent":"can.Map.prototype.define","src":"map/define/doc/attrDefinition.md"},{"type":"function","name":"can.Map.prototype.define.get","description":"<p>Specify what happens when a certain property is read on a map.</p>\n","title":"get","parent":"can.Map.prototype.define","signatures":[{"code":"get( )","description":"<p>A get function defines the behavior of what happens when a value is read on a\n[can.Map]. It is typically used to provide properties that derive their value from other properties of the map.</p>\n","params":[],"returns":{"types":[{"type":"*"}],"description":"<p>Anything can be returned from a getter.</p>\n"}}],"comment":" ","src":"map/define/doc/get.md"},{"type":"function","name":"can.Map.prototype.define.remove","description":"<p>Called when an attribute is removed.</p>\n","title":"remove","parent":"can.Map.prototype.define","signatures":[{"code":"remover( currentValue )","description":"","params":[],"returns":{"types":[{"type":"*"},{"type":"false"}],"description":"<p>If <code>false</code> is returned, the value is not removed.</p>\n"}}],"comment":" ","src":"map/define/doc/remove.md"},{"type":"function","name":"can.Map.prototype.define.serialize","description":"<p>Called when an attribute is removed.</p>\n","title":"serialize","parent":"can.Map.prototype.define","signatures":[{"code":"serializer( currentValue )","description":"","params":[{"types":[{"type":"*"}],"name":"value","description":"<p>The current value of the attribute.</p>\n"},{"types":[{"type":"String"}],"name":"attr","description":"<p>The name of the attribute being serialized.</p>\n"}],"returns":{"types":[{"type":"*"},{"type":"undefined"}],"description":"<p>If <code>undefined</code> is returned, the value is not serialized.</p>\n"},"context":{"types":[{"type":"can.Map"}],"description":"<p>The map instance being serialized.</p>\n"}}],"comment":" ","src":"map/define/doc/serialize.md"},{"type":"function","name":"can.Map.prototype.define.set","description":"<p>Specify what happens when a value is set on a map attribute.</p>\n","title":"set","parent":"can.Map.prototype.define","signatures":[{"code":"set( [newVal,] [setValue] )","description":"<p>A set function defines the behavior of what happens when a value is set on a\n[can.Map]. It is typically used to:</p>\n<ul>\n<li>Add or remove other attributes as side effects</li>\n<li>Coerce the set value into an appropriate action</li>\n</ul>\n<p>The behavior of the setter depends on the number of arguments specified. This means that a\nsetter like:</p>\n<pre><code>define: {\n  prop: {\n    set: function(){}\n  }\n}\n</code></pre>\n<p>behaves differently than:</p>\n<pre><code>define: {\n  prop: {\n    set: function(newVal){}\n  }\n}\n</code></pre>\n","params":[{"types":[{"type":"*"}],"optional":true,"name":"newVal","description":"<p>The [can.Map::define.type type function] coerced value the user intends to set on the\ncan.Map.</p>\n"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*"}],"name":"newValue"}]}],"optional":true,"name":"setValue","description":"<p>A callback that can set the value of the property\nasyncronously.</p>\n"}],"returns":{"types":[{"type":"*"},{"type":"undefined"}],"description":"<p>If a non-undefined value is returned, that value is set as\nthe attribute value.</p>\n<p>If an <code>undefined</code> value is returned, the behavior depends on the number of\narguments the setter declares:</p>\n<ul>\n<li>If the setter <em>does not</em> specify the <code>newValue</code> argument, the attribute value is set\nto whatever was passed to [can.Map::attr attr].</li>\n<li>If the setter specifies the <code>newValue</code> argument only, the attribute value will be removed.</li>\n<li>If the setter specifies both <code>newValue</code> and <code>setValue</code>, the value of the property will not be\nupdated until <code>setValue</code> is called.</li>\n</ul>\n"}}],"comment":" ","src":"map/define/doc/set.md"},{"type":"function","name":"can.Map.prototype.define.type","description":"<p>Converts a value passed to [can.Map::attr attr] into an appropriate value.</p>\n","title":"type","parent":"can.Map.prototype.define","params":[{"types":[{"type":"*"}],"name":"newValue","description":"<p>The value passed to <code>attr</code>.</p>\n"},{"types":[{"type":"String"}],"name":"attrName","description":"<p>The attribute name being set.</p>\n"}],"context":{"types":[{"type":"can.Map"}],"description":"<p>the instance of the can.Map.</p>\n"},"returns":{"types":[{"type":"*"}],"description":"<p>The value that should be passed to <code>set</code> or (if there is no <code>set</code> property) the value to set on the map instance.</p>\n"},"comment":" ","src":"map/define/doc/type.md"},{"type":"function","name":"can.Map.prototype.define.value","description":"<p>Returns the default value for instances of this can.Map.  This is called before <code>init</code>.</p>\n","title":"value","parent":"can.Map.prototype.define","signatures":[{"code":"defaulter()","description":"<p>A function can be provided that returns the default value used for this property, like:</p>\n<pre><code>define: {\n  prop: {\n    value: function(){ return []; }\n  }\n}\n</code></pre>\n<p>If the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object.  For example, if the property <code>value</code> above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).</p>\n","params":[],"context":{"types":[{"type":"can.Map"}],"description":"<p>the instance of the can.Map.</p>\n"},"returns":{"types":[{"type":"*"}],"description":"<p>The default value.  This will be passed through setter and type.</p>\n"}},{"code":"defaulVal","description":"<p>Any value can be provided as the default value used for this property, like:</p>\n<pre><code>define: {\n  prop: {\n    value: 'foo'\n  }\n}\n</code></pre>\n","params":[{"types":[{"type":"*"}],"name":"defaultVal","description":"<p>The default value, which will be passed through setter and type.</p>\n"}]}],"comment":" ","src":"map/define/doc/value.md"}]},{"type":"function","name":"can.Map.setter","description":"<p>Specify setter methods on [can.Map can.Maps].</p>\n","title":"setter","parent":"can.Map.plugins","plugin":"can/map/setter","test":"can/map/setter/test.html","deprecated":[{"version":"2.1","description":"<p>The setter plugin (and the attributes plugin) have been deprecated in\nfavor of the new [can.Map.prototype.define define] plugin, which provides the same\nfunctionality. It will still be maintained up to 3.0 and potentially after.\nProjects using setters should consider switching to [can.Map.prototype.define.set define setters].</p>\n"}],"signatures":[{"code":"setATTR: function(newValue,setValue,setErrors)","description":"<p>Specifies a setter method for the <code>ATTR</code> attribute.</p>\n","params":[{"types":[{"type":"String"}],"name":"ATTR","description":"<p>The capitalized attribute name this setter will set.</p>\n"},{"types":[{"type":"*"}],"name":"newValue","description":"<p>The propsed value of the attribute specified by [can.Map::attr].</p>\n"},{"types":[{"type":"can.Map.setter.setValue"}],"name":"setValue","description":"<p>A callback function that can specify <code>undefined</code> values\nor the value at a later time.</p>\n"},{"types":[{"type":"can.Map.setter.setErrors"}],"name":"setErrors","description":"<p>A callback function that can specify error data if\nthe proposed value is in error.</p>\n"}],"returns":{"types":[{"type":"*"}],"description":"<p>If a non-undefined value is returned, that value is set as the attribute's value. If\nundefined is returned, it's assumed that the <code>setValue</code> callback will be called.  Use <code>setValue</code> to\nset undefined values.</p>\n<div class='demo_wrapper' data-demo-src='can/map/setter/setter-paginate.html'></div>\n"}}],"comment":" ","src":"map/setter/doc/setter.md","children":[{"type":"function","name":"can.classize","description":"<p>Make a string into a class name.</p>\n","title":"can.classize","parent":"can.Map.setter","order":0,"plugin":"can/map/setter","signatures":[{"code":"can.classize(str)","description":"<p><code>can.classize</code> splits a string by underscores or\ndashes and capitalizes each part before joining\nthem back together. This method is useful for\ntaking HTML class names and getting the original\nControl name from them.</p>\n<pre><code class=\"lang-javascript\">can.classize('my_control_name'); // 'MyControlName'</code></pre>\n","params":[{"types":[{"type":"String"}],"name":"str","description":"<p>The string to transform.</p>\n"}],"returns":{"types":[{"type":"String"}],"description":"<p>The string as a class name.</p>\n"}}],"src":"map/setter/doc/can.classize.md"}]},{"type":"page","name":"can.Map.validations","description":"<p>The <code>can/map/validations</code> plugin provides validations on maps. Validations\nare set on [can.Map]'s <strong>static</strong> <code>init</code> function.</p>\n","title":"validations","parent":"can.Map.plugins","plugin":"can/map/validations","test":"can/map/validations/test.html","src":"map/validations/doc/validations.md","children":[{"type":"function","name":"can.Map.validations.prototype.errors","description":"","title":"errors","parent":"can.Map.validations","order":0,"signatures":[{"code":"observe.errors(attrs, newVal)","description":"","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"optional":true,"name":"attrs","description":"<p>An optional list of attributes to get errors for:</p>\n<pre><code>task.errors(['dueDate','name']);\n</code></pre>\n<p>Or it can take a single attr name like:</p>\n<pre><code>task.errors('dueDate')\n</code></pre>\n"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"newVal","description":"<p>An optional new value to test setting\non the observe.  If <code>newVal</code> is provided,\nit returns the errors on the observe if <code>newVal</code> was set.</p>\n"}],"returns":{"types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}]}]}],"description":"<p>an object of attributeName : [errors] like:</p>\n<pre><code>task.errors() // -&gt; {dueDate: [&quot;can't be empty&quot;]}\n</code></pre>\n<p>or <code>null</code> if there are no errors.</p>\n"}}],"comment":" ","src":"map/validations/doc/prototype.errors.md"},{"type":"function","name":"can.Map.validations.static.validate","description":"","title":"validate","parent":"can.Map.validations","order":1,"comment":" ","signatures":[{"code":"observe.validate(attrNames, [options,] validateProc)","description":"","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>\n"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options for the\nvalidations.  Valid options include 'message' and 'testIf'.</p>\n"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*"}],"name":"value"},{"types":[{"type":"String"}],"name":"attrName"}]}],"name":"validateProc","description":"<p>Function used to validate each\ngiven attribute. Returns nothing if valid and an error message\notherwise. Function is called in the instance context and takes the\n<code>value</code> and <code>attrName</code> to validate.</p>\n<p><code>validate(attrNames, [options,] validateProc(value, attrName) )</code> validates each of the\nspecified attributes with the given <code>validateProc</code> function.  The function\nshould return a value if there is an error.  By default, the return value is\nthe error message.  Validations should be set in the Constructor's static init method.</p>\n"}]}],"src":"map/validations/doc/static.validate.md"},{"type":"function","name":"can.Map.validations.static.validateFormatOf","description":"","title":"validateFormatOf","parent":"can.Map.validations","order":2,"signatures":[{"code":"observe.validateFormatOf(attrNames, regexp, options)","description":"","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>\n"},{"types":[{"type":"RegExp"}],"name":"regexp","description":"<p>Regular expression used to match for validation</p>\n"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>\n"}]}],"comment":" ","src":"map/validations/doc/static.validateFormatOf.md"},{"type":"function","name":"can.Map.validations.static.validateInclusionOf","description":"","title":"validateInclusionOf","parent":"can.Map.validations","order":3,"signatures":[{"code":"observe.validateInclusionOf(attrNames, inArray, options)","description":"<p>Validates whether the values of the specified attributes are available in a particular\narray.</p>\n<pre><code>init : function(){\n    this.validateInclusionOf([&quot;salutation&quot;],[&quot;Mr.&quot;,&quot;Mrs.&quot;,&quot;Dr.&quot;])\n}\n</code></pre>\n","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>\n"},{"types":[{"type":"Array","options":[]}],"name":"inArray","description":"<p>Array of options to test for inclusion</p>\n"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>\n"}]}],"src":"map/validations/doc/static.validateInclusionOf.md"},{"type":"function","name":"can.Map.validations.static.validateLengthOf","description":"","title":"validateLengthOf","parent":"can.Map.validations","order":4,"signatures":[{"code":"observe.validateLengthOf(attrNames, min, max, options)","description":"<p>Validates that the specified attributes' lengths are in the given range.</p>\n<pre><code>init : function(){\n    this.validateInclusionOf([&quot;suffix&quot;],3,5)\n}\n</code></pre>\n","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>\n"},{"types":[{"type":"Number"}],"name":"min","description":"<p>Minimum length (inclusive)</p>\n"},{"types":[{"type":"Number"}],"name":"max","description":"<p>Maximum length (inclusive)</p>\n"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>\n"}]}],"src":"map/validations/doc/static.validateLengthOf.md"},{"type":"function","name":"can.Map.validations.static.validatePresenceOf","description":"","title":"validatePresenceOf","parent":"can.Map.validations","order":5,"signatures":[{"code":"observe.validatePresenceOf(attrNames, options)","description":"<p>Validates that the specified attributes are not blank.</p>\n<pre><code>init : function(){\n    this.validatePresenceOf([&quot;name&quot;])\n}\n</code></pre>\n","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>\n"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>\n"}]}],"src":"map/validations/doc/static.validatePresenceOf.md"},{"type":"function","name":"can.Map.validations.static.validateRangeOf","description":"","title":"validateRangeOf","parent":"can.Map.validations","order":6,"signatures":[{"code":"observe.validateRangeOf(attrNames, low, hi, options)","description":"<p>Validates that the specified attributes are in the given numeric range.</p>\n<pre><code>init : function(){\n    this.validateRangeOf([&quot;age&quot;],21, 130);\n}\n</code></pre>\n","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>\n"},{"types":[{"type":"Number"}],"name":"low","description":"<p>Minimum value (inclusive)</p>\n"},{"types":[{"type":"Number"}],"name":"hi","description":"<p>Maximum value (inclusive)</p>\n"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>\n"}]}],"src":"map/validations/doc/static.validateRangeOf.md"},{"type":"function","name":"can.Map.validations.static.validatesNumericalityOf","description":"","title":"validatesNumericalityOf","parent":"can.Map.validations","order":7,"signatures":[{"code":"observe.validatesNumericalityOf(attrNames)","description":"<p>Validates that the specified attributes is a valid Number.</p>\n<pre><code>init : function(){\n    this.validatesNumericalityOf([&quot;age&quot;]);\n}\n</code></pre>\n","params":[{"types":[{"type":"Array"},{"type":"String"}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>\n"}]}],"src":"map/validations/doc/static.validatesNumericalityOf.md"},{"type":"property","name":"can.Map.validations.static.validationMessages","description":"<p><code>validationMessages</code> has the default validation error messages that will be returned by the builtin\nvalidation methods. These can be overwritten by assigning new messages\nto <code>can.Map.validationMessages</code> in your application setup.</p>\n","title":"validationMessages","parent":"can.Map.validations","order":8,"src":"map/validations/doc/static.validationMessages.md"}]}]}]};
	</script>
	
	
		<script type='text/javascript' 
				data-main="static"
				src="./static/steal.production.js"
		    		bundles-path="bundles"></script>
	
	
</body>

</html>
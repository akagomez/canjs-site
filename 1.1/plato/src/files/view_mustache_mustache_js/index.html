<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>view/mustache/mustache.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">59.21</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">1949</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">75.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">5.88</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">steal(&#039;can/util&#039;,
	  &#039;can/view&#039;,
	  &#039;can/view/scanner.js&#039;,
	  &#039;can/observe/compute&#039;,
	  &#039;can/view/render.js&#039;,
function( can ){
	
	// # mustache.js
	// `can.Mustache`: The Mustache templating engine.
	// 
	// See the [Transformation](#section-29) section within *Scanning Helpers* for a detailed explanation 
	// of the runtime render code design. The majority of the Mustache engine implementation 
	// occurs within the *Transformation* scanning helper.

	// ## Initialization
	//
	// Define the view extension.
	can.view.ext = &quot;.mustache&quot;;

	// ### Setup internal helper variables and functions.
	//
	// An alias for the context variable used for tracking a stack of contexts.
	// This is also used for passing to helper functions to maintain proper context.
	var CONTEXT = &#039;___c0nt3xt&#039;,
		// An alias for the variable used for the hash object that can be passed
		// to helpers via `options.hash`.
		HASH = &#039;___h4sh&#039;,
		// An alias for the function that adds a new context to the context stack.
		STACK = &#039;___st4ck&#039;,
		STACKED = &#039;___st4ck3d&#039;,
		// An alias for the most used context stacking call.
		CONTEXT_STACK = STACK + &#039;(&#039; + CONTEXT + &#039;,this)&#039;,
		CONTEXT_OBJ = &#039;{context:&#039; + CONTEXT_STACK + &#039;,options:options}&#039;,
		
		/**
		 * Checks whether an object is a can.Observe.
		 * @param  {[can.Observe]}  observable
		 * @return {Boolean} returns if the object is an observable.
		 */
		isObserve = function(obj) {
			return obj !== null &amp;&amp; can.isFunction(obj.attr) &amp;&amp; obj.constructor &amp;&amp; !!obj.constructor.canMakeObserve;
		},
		
		/**
		 * Tries to determine if the object passed is an array.
		 * @param  {Array}  obj The object to check.
		 * @return {Boolean} returns if the object is an array.
		 */
		isArrayLike = function(obj) {
			return obj &amp;&amp; obj.splice &amp;&amp; typeof obj.length == &#039;number&#039;;
		},
		
		// ## Mustache
		/**
		 * @hide
		 * The Mustache templating engine.
		 * @param {Object} options	Configuration options
		 */
		Mustache = function(options, helpers) {
			// Support calling Mustache without the constructor.
			// This returns a function that renders the template.
			if ( this.constructor != Mustache ) {
				var mustache = new Mustache(options);
				return function(data,options) {
					 return mustache.render(data,options);
				};
			}

			// If we get a `function` directly, it probably is coming from
			// a `steal`-packaged view.
			if ( typeof options == &quot;function&quot; ) {
				this.template = {
					fn: options
				};
				return;
			}

			// Set options on self.
			can.extend(this, options);
			this.template = this.scanner.scan(this.text, this.name);
		};

	/**
	 * @add can.Mustache
	 */
	// Put Mustache on the `can` object.
	can.Mustache = window.Mustache = Mustache;

	/** 
	 * @prototype
	 */
	Mustache.prototype.
	/**
	 * @function can.Mustache.prototype.render render
	 * @parent can.Mustache.prototype
	 * @signature `mustache.render( data [, helpers] )`
	 * @param {Object} data Data to interpolate into the template.
	 * @return {String} The template with interpolated data, in string form.
	 * @hide
	 * 
	 * @body
	 * Renders an object with view helpers attached to the view.
	 * 
	 *		 new Mustache({text: &quot;&lt;%= message %&gt;&quot;}).render({
	 *			 message: &quot;foo&quot;
	 *		 })
	 */
	render = function( object, options ) {
		object = object || {};
		options = options || {};
		if(!options.helpers &amp;&amp; !options.partials){
			options.helpers = options;
		}
		return this.template.fn.call(object, object, {
			_data: object,
			options: options
		});
	};

	can.extend(Mustache.prototype, {
		// Share a singleton scanner for parsing templates.
		scanner: new can.view.Scanner({
			// A hash of strings for the scanner to inject at certain points.
			text: {
				// This is the logic to inject at the beginning of a rendered template. 
				// This includes initializing the `context` stack.
				start: &#039;var &#039; + CONTEXT + &#039; = this &amp;&amp; this.&#039; + STACKED + &#039; ? this : [];&#039; + CONTEXT + &#039;.&#039; + STACKED + &#039; = true;&#039; +
					&#039;var &#039; + STACK + &#039; = function(context, self) {&#039; +
						&#039;var s;&#039; +
						&#039;if (arguments.length == 1 &amp;&amp; context) {&#039; +
							&#039;s = !context.&#039; + STACKED + &#039; ? [context] : context;&#039; +
						// Handle helpers with custom contexts (#228)
						&#039;} else if (!context.&#039; + STACKED + &#039;) {&#039; +
							&#039;s = [self, context];&#039; +
						&#039;} else if (context &amp;&amp; context === self &amp;&amp; context.&#039; + STACKED + &#039;) {&#039; +
							&#039;s = context.slice(0);&#039; +
						&#039;} else {&#039; +
							&#039;s = context &amp;&amp; context.&#039; + STACKED + &#039; ? context.concat([self]) : &#039; + STACK + &#039;(context).concat([self]);&#039; +
						&#039;}&#039; +
						&#039;return (s.&#039; + STACKED + &#039; = true) &amp;&amp; s;&#039; +
					&#039;};&#039;
			},
			
			// An ordered token registry for the scanner.
			// This needs to be ordered by priority to prevent token parsing errors.
			// Each token follows the following structure:
			//
			//		[
			//			// Which key in the token map to match.
			//			&quot;tokenMapName&quot;,
			//
			//			// A simple token to match, like &quot;{{&quot;.
			//			&quot;token&quot;,
			//
			//			// Optional. A complex (regexp) token to match that 
			//			// overrides the simple token.
			//			&quot;[\\s\\t]*{{&quot;,
			//
			//			// Optional. A function that executes advanced 
			//			// manipulation of the matched content. This is 
			//			// rarely used.
			//			function(content){   
			//				return content;
			//			}
			//		]
			tokens: [
				/**
				 * @function can.Mustache.tags.escaped {{key}}
				 * 
				 * @description Insert the value of the [can.Mustache.key key] into the 
				 * output of the template.
				 * 
				 * @parent can.Mustache.tags 0
				 * 
				 * @signature `{{key}}`
				 * 
				 * @param {can.Mustache.key} key A key that references one of the following:
				 * 
				 *  - A [can.Mustache.registerHelper registered helper].
				 *  - A value within the current or parent 
				 *    [can.Mustache.context context]. If the value is a function or [can.compute], the 
				 *    function&#039;s return value is used.
				 * 
				 * @return {String|Function|*} 
				 * 
				 * After the key&#039;s value is found (and set to any function&#039;s return value), 
				 * it is passed to [can.view.txt] as the result of a call to its `func` 
				 * argument. There, if the value is a:
				 * 
				 *  - `null` or `undefined` - an empty string is inserted into the rendered template result.
				 *  - `String` or `Number` - the value is inserted into the rendered template result.
				 *  - `Function` - A [can.view.hook hookup] attribute or element is inserted so this function
				 *    will be called back with the DOM element after it is created.
				 * 
				 * @body
				 * 
				 * ## Use
				 * 
				 * `{{key}}` insert data into the template. It most commonly references 
				 * values within the current [can.Mustache.context context]. For example:
				 * 
				 * Rendering:
				 * 
				 *     &lt;h1&gt;{{name}}&lt;/h1&gt;
				 * 
				 * With:
				 * 
				 *     {name: &quot;Austin&quot;}
				 * 
				 * Results in:
				 * 
				 *     &lt;h1&gt;Austin&lt;/h1&gt;
				 * 
				 * If the key value is a String or Number, it is inserted into the template.  
				 * If it is `null` or `undefined`, nothing is added to the template.
				 * 
				 * 
				 * ## Nested Properties
				 * 
				 * Mustache supports nested paths, making it possible to 
				 * look up properties nested deep inside the current context. For example:
				 * 
				 * Rendering:
				 * 
				 *     &lt;h1&gt;{{book.author}}&lt;/h1&gt;
				 * 
				 * With:
				 * 
				 *     {
				 *       book: {
				 *         author: &quot;Ernest Hemingway&quot;
				 *       }
				 *     }
				 * 
				 * Results in:
				 * 
				 *     &lt;h1&gt;Ernest Hemingway&lt;/h1&gt;
				 * 
				 * ## Looking up values in parent contexts
				 * 
				 * Sections and block helpers can create their own contexts. If a key&#039;s value
				 * is not found in the current context, it will look up the key&#039;s value
				 * in parent contexts. For example:
				 * 
				 * Rendering:
				 * 
				 *     {{#chapters}}
				 *        &lt;li&gt;{{title}} - {{name}}&lt;/li&gt;
				 *     {{chapters}}
				 * 
				 * With:
				 * 
				 *     {
				 *       title: &quot;The Book of Bitovi&quot;	
				 *       chapters: [{name: &quot;Breakdown&quot;}]
				 *     }
				 *   
				 * Results in:
				 * 
				 *     &lt;li&gt;The Book of Bitovi - Breakdown&lt;/li&gt;
				 * 
				 * 
				 */
				// Return unescaped
				[&quot;returnLeft&quot;, &quot;{{{&quot;, &quot;{{[{&amp;]&quot;],
				// Full line comments
				[&quot;commentFull&quot;, &quot;{{!}}&quot;, &quot;^[\\s\\t]*{{!.+?}}\\n&quot;],
				/**
				 * @function can.Mustache.tags.comment {{!key}}
				 * 
				 * @parent can.Mustache.tags 7
				 * 
				 * @description A comment that doesn&#039;t get inserted into the rendered result.
				 * 
				 * @signature `{{!key}}`
				 * 
				 * The comment tag operates similarly to a `&lt;!-- --&gt;` tag in HTML. It exists in your template but never shows up.
				 * 
				 * @param {can.Mustache.key} key Everything within this tag is completely ignored.
				 * @return {String} 
				 * 
				 */
				// Inline comments
				[&quot;commentLeft&quot;, &quot;{{!&quot;, &quot;(\\n[\\s\\t]*{{!|{{!)&quot;],
				/**
				 * @function can.Mustache.tags.unescaped {{{key}}}
				 * 
				 * @parent can.Mustache.tags 1
				 * 
				 * @description Insert the unescaped value of the [can.Mustache.key key] into the 
				 * output of the template.
				 * 
				 * @signature `{{{key}}}`
				 * 
				 * Behaves just like [can.Mustache.tags.escaped {{key}}] and [can.Mustache.helpers.helper {{helper}}] but does not
				 * escape the result. 
				 * 
				 * @param {can.Mustache.key} key A key that references a value within the current or parent 
				 * context. If the value is a function or can.compute, the function&#039;s return value is used.
				 * @return {String|Function|*} 
				 * 
				 * 
				 */
				//
				/**
				 * @function can.Mustache.tags.unescaped2 {{&amp;key}}
				 * 
				 * @parent can.Mustache.tags 2
				 * 
				 * @description Insert the unescaped value of the [can.Mustache.key key] into the 
				 * output of the template.
				 * 
				 * @signature `{{&amp;key}}`
				 * 
				 * The `{{&amp;key}}` tag is an alias for [can.Mustache.tags.unescaped {{{key}}}], behaving just 
				 * like [can.Mustache.tags.escaped {{key}}] and [can.Mustache.helpers.helper {{helper}}] but does not
				 * escape the result. 
				 * 
				 * @param {can.Mustache.key} key A key that references a value within the current or parent 
				 * context. If the value is a function or can.compute, the function&#039;s return value is used.
				 * @return {String|Function|*} 
				 * 
				 */
				// Full line escapes
				// This is used for detecting lines with only whitespace and an escaped tag
				[&quot;escapeFull&quot;, &quot;{{}}&quot;, &quot;(^[\\s\\t]*{{[#/^][^}]+?}}\\n|\\n[\\s\\t]*{{[#/^][^}]+?}}\\n|\\n[\\s\\t]*{{[#/^][^}]+?}}$)&quot;, function(content) {
					return {
						before: /^\n.+?\n$/.test(content) ? &#039;\n&#039; : &#039;&#039;,
						content: content.match(/\{\{(.+?)\}\}/)[1] || &#039;&#039;
					};
				}],
				// Return escaped
				[&quot;escapeLeft&quot;, &quot;{{&quot;],
				// Close return unescaped
				[&quot;returnRight&quot;, &quot;}}}&quot;],
				// Close tag
				[&quot;right&quot;, &quot;}}&quot;]
			],
			
			// ## Scanning Helpers
			//
			// This is an array of helpers that transform content that is within escaped tags like `{{token}}`. These helpers are solely for the scanning phase; they are unrelated to Mustache/Handlebars helpers which execute at render time. Each helper has a definition like the following:
			//
			//		{
			//			// The content pattern to match in order to execute.
			//			// Only the first matching helper is executed.
			//			name: /pattern to match/,
			//
			//			// The function to transform the content with.
			//			// @param {String} content   The content to transform.
			//			// @param {Object} cmd       Scanner helper data.
			//			//                           {
			//			//                             insert: &quot;insert command&quot;,
			//			//                             tagName: &quot;div&quot;,
			//			//                             status: 0
			//			//                           }
			//			fn: function(content, cmd) {
			//				return &#039;for text injection&#039; || 
			//					{ raw: &#039;to bypass text injection&#039; };
			//			}
			//		}
			helpers: [
				// ### Partials
				//
				// Partials begin with a greater than sign, like {{&gt; box}}.
				// 
				// Partials are rendered at runtime (as opposed to compile time), 
				// so recursive partials are possible. Just avoid infinite loops.
				// 
				// For example, this template and partial:
				// 
				// 		base.mustache:
				// 			&lt;h2&gt;Names&lt;/h2&gt;
				// 			{{#names}}
				// 				{{&gt; user}}
				// 			{{/names}}
				// 			
				// 		user.mustache:
				// 			&lt;strong&gt;{{name}}&lt;/strong&gt;
				{
					name: /^&gt;[\s]*\w*/,
					fn:function(content, cmd){
						// Get the template name and call back into the render method,
						// passing the name and the current context.
						var templateName = can.trim(content.replace(/^&gt;\s?/, &#039;&#039;)).replace(/[&quot;|&#039;]/g, &quot;&quot;);
						return &quot;options.partials &amp;&amp; options.partials[&#039;&quot;+templateName+&quot;&#039;] ? can.Mustache.renderPartial(options.partials[&#039;&quot;+templateName+&quot;&#039;],&quot; + 
							CONTEXT_STACK + &quot;,options) : can.Mustache.render(&#039;&quot; + templateName + &quot;&#039;, &quot; + CONTEXT_STACK + &quot;)&quot;;
					}
				},

				// ### Data Hookup
				// 
				// This will attach the data property of `this` to the element
				// its found on using the first argument as the data attribute
				// key.
				// 
				// For example:
				// 	
				//		&lt;li id=&quot;nameli&quot; {{ data &#039;name&#039; }}&gt;&lt;/li&gt;
				// 
				// then later you can access it like:
				// 
				//		can.$(&#039;#nameli&#039;).data(&#039;name&#039;);
				/**
				 * @function can.Mustache.helpers.data {{data name}}
				 * @parent can.Mustache.htags 7
				 * @signature `{{data name}}`
				 * 
				 * Adds the current [can.Mustache.context context] to the
				 * element&#039;s [can.data].
				 * 
				 * @param {String} name The name of the data attribute to use for the
				 * context.
				 * 
				 * @body
				 * 
				 * ## Use 
				 * 
				 * It is common for you to want some data in the template to be available
				 * on an element.  `{{data name}}` allows you to save the 
				 * context so it can later be retrieved by [can.data] or 
				 * `$.fn.data`. For example,
				 * 
				 * The template:
				 * 
				 *     &lt;ul&gt;
				 *       &lt;li id=&quot;person&quot; {{data &#039;person&#039;}}&gt;{{name}}&lt;/li&gt;
				 *     &lt;/ul&gt;
				 * 
				 * Rendered with:
				 * 
				 *     document.body.appendChild(
				 *       can.view.mustache(template,{ person: { name: &#039;Austin&#039; } });
				 * 
				 * Retrieve the person data back with:
				 * 
				 *     $(&quot;#person&quot;).data(&quot;person&quot;)
				 * 
				 */
				{
					name: /^\s*data\s/,
					fn: function(content, cmd){
						var attr = content.match(/[&quot;|&#039;](.*)[&quot;|&#039;]/)[1];
						// return a function which calls `can.data` on the element
						// with the attribute name with the current context.
						return &quot;can.proxy(function(__){&quot; +
							// &quot;var context = this[this.length-1];&quot; +
							// &quot;context = context.&quot; + STACKED + &quot; ? context[context.length-2] : context;&quot; +
							&quot;can.data(can.$(__),&#039;&quot; + attr + &quot;&#039;, this.pop()); }, &quot; + CONTEXT_STACK + &quot;)&quot;;
					}
				},
				
				// ### Transformation (default)
				//
				// This transforms all content to its interpolated equivalent,
				// including calls to the corresponding helpers as applicable. 
				// This outputs the render code for almost all cases.
				//
				// #### Definitions
				// 
				// * `context` - This is the object that the current rendering context operates within. 
				//		Each nested template adds a new `context` to the context stack.
				// * `stack` - Mustache supports nested sections, 
				//		each of which add their own context to a stack of contexts.
				//		Whenever a token gets interpolated, it will check for a match against the 
				//		last context in the stack, then iterate through the rest of the stack checking for matches.
				//		The first match is the one that gets returned.
				// * `Mustache.txt` - This serializes a collection of logic, optionally contained within a section.
				//		If this is a simple interpolation, only the interpolation lookup will be passed.
				//		If this is a section, then an `options` object populated by the truthy (`options.fn`) and 
				//		falsey (`options.inverse`) encapsulated functions will also be passed. This section handling 
				//		exists to support the runtime context nesting that Mustache supports.
				// * `Mustache.get` - This resolves an interpolation reference given a stack of contexts.
				// * `options` - An object containing methods for executing the inner contents of sections or helpers.  
				//		`options.fn` - Contains the inner template logic for a truthy section.  
				//		`options.inverse` - Contains the inner template logic for a falsey section.  
				//		`options.hash` - Contains the merged hash object argument for custom helpers.
				//
				// #### Design
				//
				// This covers the design of the render code that the transformation helper generates.
				//
				// ##### Pseudocode
				// 
				// A detailed explanation is provided in the following sections, but here is some brief pseudocode
				// that gives a high level overview of what the generated render code does (with a template similar to  
				// `&quot;{{#a}}{{b.c.d.e.name}}{{/a}}&quot; == &quot;Phil&quot;`).
				//
				// *Initialize the render code.*
				// 
				// 		view = []
				// 		context = []
				// 		stack = fn { context.concat([this]) }
				// 		
				// *Render the root section.*
				//
				// 		view.push( &quot;string&quot; )
				// 		view.push( can.view.txt(
				//
				// *Render the nested section with `can.Mustache.txt`.*
				//
				// 			txt( 
				//
				// *Add the current context to the stack.*
				//
				// 				stack(), 
				//
				// *Flag this for truthy section mode.*
				//
				// 				&quot;#&quot;,
				//
				// *Interpolate and check the `a` variable for truthyness using the stack with `can.Mustache.get`.*
				// 
				// 				get( &quot;a&quot;, stack() ),
				//
				// *Include the nested section&#039;s inner logic.
				// The stack argument is usually the parent section&#039;s copy of the stack, 
				// but it can be an override context that was passed by a custom helper.
				// Sections can nest `0..n` times -- **NESTCEPTION**.*
				//
				// 				{ fn: fn(stack) {
				//
				// *Render the nested section (everything between the `{{#a}}` and `{{/a}}` tokens).*
				//
				// 					view = []
				// 					view.push( &quot;string&quot; )
				// 					view.push(
				//
				// *Add the current context to the stack.*
				//
				// 						stack(),
				//
				// *Flag this as interpolation-only mode.*
				//
				// 						null,
				//
				// *Interpolate the `b.c.d.e.name` variable using the stack.*
				//
				// 						get( &quot;b.c.d.e.name&quot;, stack() ),
				// 					)
				// 					view.push( &quot;string&quot; )
				//
				// *Return the result for the nested section.*
				//
				// 					return view.join()
				// 				}}
				// 			)
				// 		))
				// 		view.push( &quot;string&quot; )
				//
				// *Return the result for the root section, which includes all nested sections.*
				//
				// 		return view.join()
				//
				// ##### Initialization
				//
				// Each rendered template is started with the following initialization code:
				//
				// 		var ___v1ew = [];
				// 		var ___c0nt3xt = [];
				// 		___c0nt3xt.___st4ck = true;
				// 		var ___st4ck = function(context, self) {
				// 			var s;
				// 			if (arguments.length == 1 &amp;&amp; context) {
				// 				s = !context.___st4ck ? [context] : context;
				// 			} else {
				// 				s = context &amp;&amp; context.___st4ck 
				//					? context.concat([self]) 
				//					: ___st4ck(context).concat([self]);
				// 			}
				// 			return (s.___st4ck = true) &amp;&amp; s;
				// 		};
				//
				// The `___v1ew` is the the array used to serialize the view.
				// The `___c0nt3xt` is a stacking array of contexts that slices and expands with each nested section.
				// The `___st4ck` function is used to more easily update the context stack in certain situations.
				// Usually, the stack function simply adds a new context (`self`/`this`) to a context stack. 
				// However, custom helpers will occasionally pass override contexts that need their own context stack.
				//
				// ##### Sections
				//
				// Each section, `{{#section}} content {{/section}}`, within a Mustache template generates a section 
				// context in the resulting render code. The template itself is treated like a root section, with the 
				// same execution logic as any others. Each section can have `0..n` nested sections within it.
				//
				// Here&#039;s an example of a template without any descendent sections.  
				// Given the template: `&quot;{{a.b.c.d.e.name}}&quot; == &quot;Phil&quot;`  
				// Would output the following render code:
				//
				//		___v1ew.push(&quot;\&quot;&quot;);
				//		___v1ew.push(can.view.txt(1, &#039;&#039;, 0, this, function() {
				// 			return can.Mustache.txt(___st4ck(___c0nt3xt, this), null, 
				//				can.Mustache.get(&quot;a.b.c.d.e.name&quot;, 
				//					___st4ck(___c0nt3xt, this))
				//			);
				//		}));
				//		___v1ew.push(&quot;\&quot; == \&quot;Phil\&quot;&quot;);
				//
				// The simple strings will get appended to the view. Any interpolated references (like `{{a.b.c.d.e.name}}`) 
				// will be pushed onto the view via `can.view.txt` in order to support live binding.
				// The function passed to `can.view.txt` will call `can.Mustache.txt`, which serializes the object data by doing 
				// a context lookup with `can.Mustache.get`.
				//
				// `can.Mustache.txt`&#039;s first argument is a copy of the context stack with the local context `this` added to it.
				// This stack will grow larger as sections nest.
				//
				// The second argument is for the section type. This will be `&quot;#&quot;` for truthy sections, `&quot;^&quot;` for falsey, 
				// or `null` if it is an interpolation instead of a section.
				//
				// The third argument is the interpolated value retrieved with `can.Mustache.get`, which will perform the 
				// context lookup and return the approriate string or object.
				//
				// Any additional arguments, if they exist, are used for passing arguments to custom helpers.
				//
				// For nested sections, the last argument is an `options` object that contains the nested section&#039;s logic.
				//
				// Here&#039;s an example of a template with a single nested section.  
				// Given the template: `&quot;{{#a}}{{b.c.d.e.name}}{{/a}}&quot; == &quot;Phil&quot;`  
				// Would output the following render code:
				//
				//		___v1ew.push(&quot;\&quot;&quot;);
				// 		___v1ew.push(can.view.txt(0, &#039;&#039;, 0, this, function() {
				// 			return can.Mustache.txt(___st4ck(___c0nt3xt, this), &quot;#&quot;, 
				//				can.Mustache.get(&quot;a&quot;, ___st4ck(___c0nt3xt, this)), 
				//					[{
				// 					_: function() {
				// 						return ___v1ew.join(&quot;&quot;);
				// 					}
				// 				}, {
				// 					fn: function(___c0nt3xt) {
				// 						var ___v1ew = [];
				// 						___v1ew.push(can.view.txt(1, &#039;&#039;, 0, this, 
				//								function() {
				//  								return can.Mustache.txt(
				// 									___st4ck(___c0nt3xt, this), 
				// 									null, 
				// 									can.Mustache.get(&quot;b.c.d.e.name&quot;, 
				// 										___st4ck(___c0nt3xt, this))
				// 								);
				// 							}
				// 						));
				// 						return ___v1ew.join(&quot;&quot;);
				// 					}
				// 				}]
				//			)
				// 		}));
				//		___v1ew.push(&quot;\&quot; == \&quot;Phil\&quot;&quot;);
				//
				// This is specified as a truthy section via the `&quot;#&quot;` argument. The last argument includes an array of helper methods used with `options`.
				// These act similarly to custom helpers: `options.fn` will be called for truthy sections, `options.inverse` will be called for falsey sections.
				// The `options._` function only exists as a dummy function to make generating the section nesting easier (a section may have a `fn`, `inverse`,
				// or both, but there isn&#039;t any way to determine that at compilation time).
				// 
				// Within the `fn` function is the section&#039;s render context, which in this case will render anything between the `{{#a}}` and `{{/a}}` tokens.
				// This function has `___c0nt3xt` as an argument because custom helpers can pass their own override contexts. For any case where custom helpers
				// aren&#039;t used, `___c0nt3xt` will be equivalent to the `___st4ck(___c0nt3xt, this)` stack created by its parent section. The `inverse` function
				// works similarly, except that it is added when `{{^a}}` and `{{else}}` are used. `var ___v1ew = []` is specified in `fn` and `inverse` to 
				// ensure that live binding in nested sections works properly.
				//
				// All of these nested sections will combine to return a compiled string that functions similar to EJS in its uses of `can.view.txt`.
				//
				// #### Implementation
				{
					name: /^.*$/,
					fn: function(content, cmd) {
						var mode = false,
							result = [];

						// Trim the content so we don&#039;t have any trailing whitespace.
						content = can.trim(content);

						// Determine what the active mode is.
						// 
						// * `#` - Truthy section
						// * `^` - Falsey section
						// * `/` - Close the prior section
						// * `else` - Inverted section (only exists within a truthy/falsey section)
						if (content.length &amp;&amp; (mode = content.match(/^([#^/]|else$)/))) {
							mode = mode[0];
							switch (mode) {
								/**
								 * @function can.Mustache.helpers.section {{#key}}
								 * @parent can.Mustache.tags 3
								 * 
								 * @signature `{{#key}}BLOCK{{/key}}`
								 * 
								 * Render blocks of text one or more times, depending 
								 * on the value of the key in the current context.
								 * 
								 * @param {can.Mustache.key} key A key that references a value within the current or parent 
								 * [can.Mustache.context context]. If the value is a function or [can.compute], the 
								 * function&#039;s return value is used.
								 * 
								 * 
								 * @return {String} 
								 * 
								 * Depending on the value&#039;s type, the following actions happen:
								 * 
								 * - `Array` or [can.Observe.List] - the block is rendered for 
								 *   each item in the array. The [can.Mustache.context context] is set to 
								 *   the item within each block rendering.
								 * - A `truthy` value - the block is rendered with the [can.Mustache.context context]
								 *   set to the value.
								 * - A `falsey` value - the block is not rendered.
								 * 
								 * The rendered result of the blocks, block or an empty string is returned.
								 * 
								 * @body
								 * 
								 * Sections contain text blocks and evaluate whether to render it or not.  If
								 * the object evaluates to an array it will iterate over it and render the block
								 * for each item in the array.  There are four different types of sections.
								 * 
								 * ## Falseys or Empty Arrays
								 * 
								 * If the value returns a `false`, `undefined`, `null`, `&quot;&quot;` or `[]` we consider
								 * that a *falsey* value.
								 * 
								 * If the value is falsey, the section will **NOT** render the block.
								 * 
								 * 	{ 
								 * 		friends: false
								 * 	}
								 * 
								 * 	{{#friends}}
								 * 		Never shown!
								 * 	{{/friends}}
								 * 
								 * 
								 * ## Arrays
								 * 
								 * If the value is a non-empty array, sections will iterate over the 
								 * array of items, rendering the items in the block.
								 * 
								 * For example, a list of friends will iterate
								 * over each of those items within a section.
								 * 
								 *     { 
								 *         friends: [ 
								 *             { name: &quot;Austin&quot; }, 
								 *             { name: &quot;Justin&quot; } 
								 *         ] 
								 *     }
								 * 
								 *     &lt;ul&gt;
								 *         {{#friends}}
								 *             &lt;li&gt;{{name}}&lt;/li&gt;
								 *         {{/friends}}
								 *     &lt;/ul&gt;
								 * 
								 * would render:
								 * 
								 *     &lt;ul&gt;
								 *         &lt;li&gt;Austin&lt;/li&gt;
								 *         &lt;li&gt;Justin&lt;/li&gt;
								 *     &lt;/ul&gt;
								 * 
								 * Reminder: Sections will reset the current context to the value for which it is iterating.
								 * See the [basics of contexts](#Basics) for more information.
								 * 
								 * ## Truthys
								 * 
								 * When the value is a non-falsey object but not a list, it is considered truthy and will be used 
								 * as the context for a single rendering of the block.
								 * 
								 *     {
								 *         friends: { name: &quot;Jon&quot; }
								 *     }
								 * 
								 *     {{#friends}}
								 *         Hi {{name}}
								 *     {{/friends}}
								 * 
								 * would render:
								 * 
								 *     Hi Jon!
								 */
								// 
								/**
								 * @function can.Mustache.helpers.helper {{helper args hashes}}
								 * @parent can.Mustache.htags 0
								 * 
								 * @description Calls a mustache helper function and inserts its return value into
								 * the rendered template.
								 * 
								 * @signature `{{helper [args...] [hashProperty=hashValue...]}}`
								 * 
								 * Calls a mustache helper function or a function. For example:
								 * 
								 * The template:
								 * 
								 *     &lt;p&gt;{{madLib &quot;Lebron James&quot; verb 4 foo=&quot;bar&quot;}}&lt;/p&gt;
								 * 
								 * Rendered with:
								 * 
								 *     {verb: &quot;swept&quot;}
								 * 
								 * Will call a `madLib` helper with the following arguements:
								 * 
								 *     can.Mustache.registerHelper(&#039;madLib&#039;, 
								 *       function(subject, verb, number, options){
								 *         // subject -&gt; &quot;Lebron James&quot;
								 *         // verb -&gt; &quot;swept&quot;
								 *         // number -&gt; 4
								 *         // options.hash.foo -&gt; &quot;bar&quot;
								 *     });
								 * 
								 * @param {can.Mustache.key} helper A key that finds a [can.Mustache.helper helper function]
								 * that is either [can.Mustache.registerHelper registered] or found within the
								 * current or parent [can.Mustache.context context].
								 * 
								 * @param {...can.Mustache.key|String|Number} [args] Space seperated arguments
								 * that get passed to the helper function as arguments. If the key&#039;s value is a:
								 * 
								 *  - [can.Observe] - A getter/setter [can.compute] is passed.
								 *  - [can.compute] - The can.compute is passed.
								 *  - `function` - The function&#039;s return value is passed.
								 * 
								 * @param {String} hashProperty
								 * 
								 * A property name that gets added to a [can.Mustache.helperOptions helper options]&#039;s 
								 * hash object.
								 * 
								 * @param {...can.Mustache.key|String|Number} hashValue A value that gets 
								 * set as a property value of the [can.Mustache.helperOptions helper option argument]&#039;s 
								 * hash object.
								 * 
								 * @body
								 * 
								 * ## Use
								 * 
								 * The `{{helper}}` syntax is used to call out to Mustache [can.Mustache.helper helper functions] functions 
								 * that may contain more complex functionality. `helper` is a [can.Mustache.key key] that must match either:
								 * 
								 *  - a [can.Mustache.registerHelper registered helper function], or
								 *  - a function in the current or parent [can.Mustache.context contexts]
								 * 
								 * The following example shows both cases.
								 * 
								 * The Template:
								 * 
								 *     &lt;p&gt;{{greeting}} {{user}}&lt;/p&gt;
								 * 
								 * Rendered with data:
								 * 
								 *     {
								 *       user: function(){ return &quot;Justin&quot; }
								 *     }
								 * 
								 * And a with a registered helper like:
								 * 
								 *     can.Mustache.registerHelper(&#039;greeting&#039;, function(){
								 *       return &quot;Hello&quot;
								 *     });
								 * 
								 * Results in:
								 * 
								 *     &lt;p&gt;Hello Justin&lt;/p&gt;
								 * 
								 * ## Arguments
								 * 
								 * Arguments can be passed from the template to helper function by
								 * listing space seperated strings, numbers or other [can.Mustache.key keys] after the
								 * `helper` name.  For example:
								 * 
								 * The template:
								 * 
								 *     &lt;p&gt;{{madLib &quot;Lebron James&quot; verb 4}}&lt;/p&gt;
								 * 
								 * Rendered with:
								 * 
								 *     {verb: &quot;swept&quot;}
								 * 
								 * Will call a `madLib` helper with the following arguements:
								 * 
								 *     can.Mustache.registerHelper(&#039;madLib&#039;, 
								 *       function(subject, verb, number, options){
								 *         // subject -&gt; &quot;Lebron James&quot;
								 *         // verb -&gt; &quot;swept&quot;
								 *         // number -&gt; 4
								 *     });
								 * 
								 * If an argument `key` value is a [can.Observe] property, the Observe&#039;s 
								 * property is converted to a getter/setter [can.compute]. For example:
								 * 
								 * The template:
								 * 
								 *     &lt;p&gt;What! My name is: {{mr user.name}}&lt;/p&gt;
								 * 
								 * Rendered with:
								 * 
								 *     {user: new can.Observe({name: &quot;Slim Shady&quot;})}
								 * 
								 * Needs the helper to check if name is a function or not:
								 * 
								 *     can.Mustache.registerHelper(&#039;mr&#039;,function(name){
								 *       return &quot;Mr. &quot;+ (typeof name === &quot;function&quot; ?
								 *                       name():
								 *                       name)
								 *     })
								 * 
								 * This behavior enables two way binding helpers and is explained in more detail 
								 * on the [can.Mustache.helper helper functions] docs.
								 * 
								 * ## Hash
								 * 
								 * If enumerated arguments isn&#039;t an appropriate way to configure the behavior
								 * of a helper, it&#039;s possible to pass a hash of key-value pairs to the
								 * [can.Mustache.helperOptions helper option argument]&#039;s 
								 * hash object.  Properties and values are specified 
								 * as `hashProperty=hashValue`.  For example:
								 * 
								 * The template:
								 * 
								 *     &lt;p&gt;My {{excuse who=pet how=&quot;shreded&quot;}}&lt;/p&gt;
								 * `
								 * And the helper:
								 * 
								 *     can.Mustache.registerHelper(&quot;excuse&quot;,function(options){
								 *       return [&quot;My&quot;,
								 *         options.hash.who || &quot;dog&quot;.
								 *         options.hash.how || &quot;ate&quot;,
								 *         &quot;my&quot;,
								 *         options.hash.what || &quot;homework&quot;].join(&quot; &quot;)
								 *     })
								 * 
								 * Render with:
								 * 
								 *     {pet: &quot;cat&quot;}
								 * 
								 * Results in:
								 * 
								 *     &lt;p&gt;My cat shareded my homework&lt;/p&gt;
								 * 
								 * ## Returning an element callback function
								 * 
								 * If a helper returns a function, that function is called back after
								 * the template has been rendered into DOM elements. This can 
								 * be used to create mustache tags that have rich behavior. Read about it
								 * on the [can.Mustache.helper helper function] page.
								 * 
								 */
								// 
								/**
								 * @function can.Mustache.helpers.sectionHelper {{#helper args hashes}}
								 * @parent can.Mustache.htags 1
								 * 
								 * Calls a mustache helper function with a block, and optional inverse 
								 * block.
								 * 
								 * @signature `{{#helper [args...] [hashName=hashValue...]}}BLOCK{{/helper}}`
								 * 
								 * Calls a mustache helper function or a function with a block to 
								 * render.
								 * 
								 * The template:
								 * 
								 *     &lt;p&gt;{{countTo number}}{{num}}{{/countTo}}&lt;/p&gt;
								 * 
								 * Rendered with:
								 * 
								 *     {number: 5}
								 * 
								 * Will call the `countTo` helper:
								 * 
								 *     can.Mustache.registerHelper(&#039;madLib&#039;, 
								 *       function(number, options){
								 * 	       var out = []
								 *         for(var i =0; i &lt; number; i++){
								 *           out.push( options.fn({num: i+1}) )
								 *         }
								 *         return out.join(&quot; &quot;)
								 *     });
								 * 
								 * Results in:
								 * 
								 *     &lt;p&gt;1 2 3 4 5&lt;/p&gt;
								 * 
								 * @param {can.Mustache.key} helper A key that finds a [can.Mustache.helper helper function]
								 * that is either [can.Mustache.registerHelper registered] or found within the
								 * current or parent [can.Mustache.context context].
								 * 
								 * @param {...can.Mustache.key|String|Number} [args] Space seperated arguments
								 * that get passed to the helper function as arguments. If the key&#039;s value is a:
								 * 
								 *  - [can.Observe] - A getter/setter [can.compute] is passed.
								 *  - [can.compute] - The can.compute is passed.
								 *  - `function` - The function&#039;s return value is passed.
								 * 
								 * @param {String} hashProperty
								 * 
								 * A property name that gets added to a [can.Mustache.helperOptions helper options]&#039;s 
								 * hash object.
								 * 
								 * @param {...can.Mustache.key|String|Number} hashValue A value that gets 
								 * set as a property value of the [can.Mustache.helperOptions helper option argument]&#039;s 
								 * hash object.
								 * 
								 * @param {mustache} BLOCK A mustache template that gets compiled and
								 * passed to the helper function as the [can.Mustache.helperOptions options argument&#039;s] `fn`
								 * property.
								 * 
								 * 
								 * @signature `{{#helper [args...] [hashName=hashValue...]}}BLOCK{{else}}INVERSE{{/helper}}`
								 * 
								 * Calls a mustache helper function or a function with a `fn` and `inverse` block to
								 * render.
								 * 
								 * The template:
								 * 
								 *     &lt;p&gt;The bed is 
								 *        {{isJustRight firmness}}
								 *           pefect!
								 *        {{else}}
								 *           uncomfortable.
								 *        {{/justRight}}&lt;/p&gt;
								 * 
								 * Rendered with:
								 * 
								 *     {firmness: 45}
								 * 
								 * Will call the `isJustRight` helper:
								 * 
								 *     can.Mustache.registerHelper(&#039;isJustRight&#039;, 
								 *       function(number, options){
								 * 	       if(number &gt; 50){
								 *           return options.fn(this)  
								 *         } else {
								 *           return options.inverse(this)  
								 *         }
								 *         return out.join(&quot; &quot;)
								 *     });
								 * 
								 * Results in:
								 * 
								 *     &lt;p&gt;The bed is uncomfortable.&lt;/p&gt;
								 * 
								 * @param {can.Mustache.key} helper A key that finds a [can.Mustache.helper helper function]
								 * that is either [can.Mustache.registerHelper registered] or found within the
								 * current or parent [can.Mustache.context context].
								 * 
								 * @param {...can.Mustache.key|String|Number} [args] Space seperated arguments
								 * that get passed to the helper function as arguments. If the key&#039;s value is a:
								 * 
								 *  - [can.Observe] - A getter/setter [can.compute] is passed.
								 *  - [can.compute] - The can.compute is passed.
								 *  - `function` - The function&#039;s return value is passed.
								 * 
								 * @param {String} hashProperty
								 * 
								 * A property name that gets added to a [can.Mustache.helperOptions helper options]&#039;s 
								 * hash object.
								 * 
								 * @param {...can.Mustache.key|String|Number} hashValue A value that gets 
								 * set as a property value of the [can.Mustache.helperOptions helper option argument]&#039;s 
								 * hash object.
								 * 
								 * @param {mustache} BLOCK A mustache template that gets compiled and
								 * passed to the helper function as the [can.Mustache.helperOptions options argument&#039;s] `fn`
								 * property.
								 * 
								 * @param {mustache} INVERSE A mustache template that gets compiled and
								 * passed to the helper function as the [can.Mustache.helperOptions options argument&#039;s] `inverse`
								 * property.
								 * 
								 * 
								 * @body
								 * 
								 * ## Use
								 * 
								 * Read the [use section of {{helper}}](can.Mustache.helpers.helper.html#section_Use) to better understand how:
								 * 
								 *  - [Helper functions are found](can.Mustache.helpers.helper.html#section_Arguments)
								 *  - [Arguments are passed to the helper](can.Mustache.helpers.helper.html#section_Arguments)
								 *  - [Hash values are passed to the helper](can.Mustache.helpers.helper.html#section_Hash)
								 * 
								 * Read how [helpers that return functions](can.Mustache.helper.html#section_Returninganelementcallbackfunction) can
								 * be used for rich behavior like 2-way binding.
								 * 
								 */
								// Open a new section.
								case &#039;#&#039;:
								/**
								 * @function can.Mustache.helpers.inverse {{^key}}
								 * @parent can.Mustache.tags 5
								 * 
								 * @signature `{{^key}}BLOCK{{/key}}`
								 * 
								 * Render blocks of text if the value of the key
								 * is falsey.  An inverted section syntax is similar to regular 
								 * sections except it begins with a caret rather than a 
								 * pound. If the value referenced is falsey, the section will render.
								 * 
								 * @param {can.Mustache.key} key A key that references a value within the current or parent 
								 * [can.Mustache.context context]. If the value is a function or [can.compute], the 
								 * function&#039;s return value is used.
								 * 
								 * @return {String} 
								 * 
								 * Depending on the value&#039;s type, the following actions happen:
								 * 
								 * - A `truthy` value - the block is not rendered.
								 * - A `falsey` value - the block is rendered.
								 * 
								 * The rendered result of the block or an empty string is returned.
								 * 
								 * @body
								 * 
								 * ## Use
								 * 
								 * Inverted sections match falsey values. An inverted section 
								 * syntax is similar to regular sections except it begins with a caret 
								 * rather than a pound. If the value referenced is falsey, the section 
								 * will render. For example:
								 * 
								 * 
								 * The template:
								 * 
								 *     &lt;ul&gt;
								 *         {{#friends}}
								 *             &lt;/li&gt;{{name}}&lt;/li&gt;
								 *         {{/friends}}
								 *         {{^friends}}
								 *             &lt;li&gt;No friends.&lt;/li&gt;
								 *         {{/friends}}
								 *     &lt;/ul&gt;
								 * 
								 * And data:
								 * 
								 *     {
								 *         friends: []
								 *     }
								 * 
								 * Results in:
								 * 
								 * 
								 *     &lt;ul&gt;
								 *         &lt;li&gt;No friends.&lt;/li&gt;
								 *     &lt;/ul&gt;
								 */
								case &#039;^&#039;:
									result.push(cmd.insert + &#039;can.view.txt(0,\&#039;&#039; + cmd.tagName + &#039;\&#039;,&#039; + cmd.status + &#039;,this,function(){ return &#039;);
									break;
								// Close the prior section.
								/**
								 * @function can.Mustache.helpers.close {{/key}}
								 * @parent can.Mustache.tags 4
								 * 
								 * @signature `{{/key}}`
								 * 
								 * Ends a [can.Mustache.helpers.section {{#key}}] or [can.Mustache.helpers.sectionHelper {{#helper}}]
								 * block.
								 * 
								 * @param {can.Mustache.key} [key] A key that matches the opening key or helper name. It&#039;s also
								 * possible to simply write `{{/}}` to end a block.
								 */
								case &#039;/&#039;:
									return { raw: &#039;return ___v1ew.join(&quot;&quot;);}}])}));&#039; };
									break;
							}
							
							// Trim the mode off of the content.
							content = content.substring(1);
						}
						
						// `else` helpers are special and should be skipped since they don&#039;t 
						// have any logic aside from kicking off an `inverse` function.
						if (mode != &#039;else&#039;) {
							var args = [],
								i = 0,
								hashing = false,
								arg, split, m;
							
							// Parse the helper arguments.
							// This needs uses this method instead of a split(/\s/) so that 
							// strings with spaces can be correctly parsed.
							(can.trim(content)+&#039; &#039;).replace(/((([^\s]+?=)?(&#039;.*?&#039;|&quot;.*?&quot;))|.*?)\s/g, function(whole, part) {
								args.push(part);
							});

							// Start the content render block.
							result.push(&#039;can.Mustache.txt(&#039;+CONTEXT_OBJ+&#039;,&#039; + (mode ? &#039;&quot;&#039;+mode+&#039;&quot;&#039; : &#039;null&#039;) + &#039;,&#039;);
						
							// Iterate through the helper arguments, if there are any.
							for (; arg = args[i]; i++) {
								i &amp;&amp; result.push(&#039;,&#039;);
								
								// Check for special helper arguments (string/number/boolean/hashes).
								if (i &amp;&amp; (m = arg.match(/^((&#039;.*?&#039;|&quot;.*?&quot;|[0-9]+\.?[0-9]*|true|false)|((.+?)=((&#039;.*?&#039;|&quot;.*?&quot;|[0-9]+\.?[0-9]*|true|false)|(.+))))$/))) {
									// Found a native type like string/number/boolean.
									if (m[2]) {
										result.push(m[0]);
									}
									// Found a hash object.
									else {
										// Open the hash object.
										if (!hashing) {
											hashing = true;
											result.push(&#039;{&#039; + HASH + &#039;:{&#039;);
										}
										
										// Add the key/value.
										result.push(m[4], &#039;:&#039;, m[6] ? m[6] : &#039;can.Mustache.get(&quot;&#039; + m[5].replace(/&quot;/g,&#039;\\&quot;&#039;) + &#039;&quot;,&#039; + CONTEXT_OBJ + &#039;)&#039;);
										
										// Close the hash if this was the last argument.
										if (i == args.length - 1) {
											result.push(&#039;}}&#039;);
										}
									}
								}
								// Otherwise output a normal interpolation reference.
								else {
									result.push(&#039;can.Mustache.get(&quot;&#039; + 
										// Include the reference name.
										arg.replace(/&quot;/g,&#039;\\&quot;&#039;) + &#039;&quot;,&#039; +
										// Then the stack of context.
										CONTEXT_OBJ +
										// Flag as a helper method to aid performance, 
										// if it is a known helper (anything with &gt; 0 arguments).
										(i == 0 &amp;&amp; args.length &gt; 1 ? &#039;,true&#039; : &#039;,false&#039;) +
										(i &gt; 0 ? &#039;,true&#039; : &#039;,false&#039;) +
										&#039;)&#039;);
								}
							}
						}
						
						// Create an option object for sections of code.
						mode &amp;&amp; mode != &#039;else&#039; &amp;&amp; result.push(&#039;,[{_:function(){&#039;);
						switch (mode) {
							// Truthy section
							case &#039;#&#039;:
								result.push(&#039;return ___v1ew.join(&quot;&quot;);}},{fn:function(&#039; + CONTEXT + &#039;){var ___v1ew = [];&#039;);
								break;
							// If/else section
							// Falsey section
							/**
							 * @function can.Mustache.helpers.else {{else}}
							 * @parent can.Mustache.htags 3
							 *
							 * @signature `{{#helper}}BLOCK{{else}}INVERSE{{/helper}}`
							 * 
							 * Creates an `inverse` block for a [can.Mustache.helper helper function]&#039;s 
							 * [can.Mustache.helperOptions options argument]&#039;s `inverse` property.
							 * 
							 * @param {can.Mustache} INVERSE a mustache template coverted to a
							 * function and set as the [can.Mustache.helper helper function]&#039;s 
							 * [can.Mustache.helperOptions options argument]&#039;s `inverse` property.
							 * 
							 * @body
							 * 
							 * ## Use
							 * 
							 * For more information on how `{{else}}` is used checkout:
							 * 
							 *  - [can.Mustache.helpers.if {{if key}}]
							 *  - [can.Mustache.helpers.sectionHelper {{#helper}}]
							 * 
							 */
							case &#039;else&#039;:
							case &#039;^&#039;:
								result.push(&#039;return ___v1ew.join(&quot;&quot;);}},{inverse:function(&#039; + CONTEXT + &#039;){var ___v1ew = [];&#039;);
								break;
							// Not a section
							default:
								result.push(&#039;);&#039;);
								break;
						}
						
						// Return a raw result if there was a section, otherwise return the default string.
						result = result.join(&#039;&#039;);
						return mode ? { raw: result } : result;
					}
				}
			]
		})
	});

	// Add in default scanner helpers first.
	// We could probably do this differently if we didn&#039;t &#039;break&#039; on every match.
	var helpers = can.view.Scanner.prototype.helpers;
	for (var i = 0; i &lt; helpers.length; i++) {
		Mustache.prototype.scanner.helpers.unshift(helpers[i]);
	};

	/**
	 * @function can.Mustache.txt
	 * @hide
	 * 
	 * Evaluates the resulting string based on the context/name.
	 *
	 * @param {Object|Array} context	The context stack to be used with evaluation.
	 * @param {String} mode		The mode to evaluate the section with: # for truthy, ^ for falsey
	 * @param {String|Object} name	The string (or sometimes object) to pass to the given helper method.
	 */
	Mustache.txt = function(context, mode, name) {
		// Grab the extra arguments to pass to helpers.
		var args = Array.prototype.slice.call(arguments, 3),
			// Create a default `options` object to pass to the helper.
			options = can.extend.apply(can, [{
					fn: function() {},
					inverse: function() {}
			}].concat(mode ? args.pop() : []));
			
			
		var extra = {};
		if(context.context) {
			extra = context.options;
			context = context.context;
		}

		// Check for a registered helper or a helper-like function.
		if (helper = (Mustache.getHelper(name,extra) || (can.isFunction(name) &amp;&amp; !name.isComputed &amp;&amp; { fn: name }))) {
			// Use the most recent context as `this` for the helper.
			var stack = context[STACKED] &amp;&amp; context,
				context = (stack &amp;&amp; context[context.length - 1]) || context,
				// Update the options with a function/inverse (the inner templates of a section).
				opts = {
					fn: can.proxy(options.fn, context),
					inverse: can.proxy(options.inverse, context)
				}, 
				lastArg = args[args.length-1];
			
			// Store the context stack in the options if one exists
			if (stack) {
				opts.contexts = stack;
			}
			// Add the hash to `options` if one exists
			if (lastArg &amp;&amp; lastArg[HASH]) {
				opts.hash = args.pop()[HASH];
			}
			args.push(opts);

			// Call the helper.
			return helper.fn.apply(context, args) || &#039;&#039;;
		}

		// if a compute, get the value
		if( can.isFunction(name) &amp;&amp; name.isComputed ){
			name = name();
		}

		// An array of arguments to check for truthyness when evaluating sections.
		var validArgs = args.length ? args : [name],
			// Whether the arguments meet the condition of the section.
			valid = true,
			result = [],
			i, helper, argIsObserve, arg;
		// Validate the arguments based on the section mode.
		if (mode) {
			for (i = 0; i &lt; validArgs.length; i++) {
				arg          = validArgs[i];
				argIsObserve = typeof arg !== &#039;undefined&#039; &amp;&amp; isObserve(arg);
				// Array-like objects are falsey if their length = 0.
				if (isArrayLike(arg)) {
					// Use .attr to trigger binding on empty lists returned from function
					if(mode == &#039;#&#039;){
						valid = valid &amp;&amp; !!(argIsObserve ? arg.attr(&#039;length&#039;) : arg.length);
					} else if(mode == &#039;^&#039;){
						valid = valid &amp;&amp; !(argIsObserve ? arg.attr(&#039;length&#039;) : arg.length);
					}
				}
				// Otherwise just check if it is truthy or not.
				else {
					valid = mode == &#039;#&#039; ? valid &amp;&amp; !!arg
						: mode == &#039;^&#039; ? valid &amp;&amp; !arg
						: valid;
				}
			}
		}
		
		// Otherwise interpolate like normal.
		if (valid) {
			switch (mode) {
				// Truthy section.
				case &#039;#&#039;:
					// Iterate over arrays
					if (isArrayLike(name)) {
						var isObserveList = isObserve(name);
						
						// Add the reference to the list in the contexts.
						for (i = 0; i &lt; name.length; i++) {
							result.push(options.fn.call(name[i], context) || &#039;&#039;);
							
							// Ensure that live update works on observable lists
							isObserveList &amp;&amp; name.attr(&#039;&#039;+i);
						}
						return result.join(&#039;&#039;);
					}
					// Normal case.
					else {
						return options.fn.call(name || {}, context) || &#039;&#039;;
					}
					break;
				// Falsey section.
				case &#039;^&#039;:
					return options.inverse.call(name || {}, context) || &#039;&#039;;
					break;
				default:
					// Add + &#039;&#039; to convert things like numbers to strings.
					// This can cause issues if you are trying to
					// eval on the length but this is the more
					// common case.
					return &#039;&#039; + (name !== undefined ? name : &#039;&#039;);
					break;
			}
		}
		
		return &#039;&#039;;
	};
	
	/**
	 * @function can.Mustache.get
	 * @hide
	 *
	 * Resolves a reference for a given object (and then a context if that fails).
	 *	obj = this
	 *	context = { a: true }
	 *	ref = &#039;a.b.c&#039;
	 *		=&gt; obj.a.b.c || context.a.b.c || &#039;&#039;
	 *
	 * This implements the following Mustache specs:
	 * 	Deeply Nested Contexts
	 *	All elements on the context stack should be accessible.
	 *		{{#bool}}B {{#bool}}C{{/bool}} D{{/bool}}
	 *		{ bool: true }
	 *		=&gt; &quot;B C D&quot;
	 * 	Basic Context Miss Interpolation
	 * 	Failed context lookups should default to empty strings.
	 *  	{{cannot}}
	 *		=&gt; &quot;&quot;
	 * 	Dotted Names - Broken Chains
	 * 	Any falsey value prior to the last part of the name should yield &#039;&#039;.
	 *		{{a.b.c}}
	 *		{ a: { d: 1 } }
	 *		=&gt; &quot;&quot;
	 *
	 * @param {String} ref      The reference to check for on the obj/context.
	 * @param {Object} obj  		The object to use for checking for a reference.
	 * @param {Object} context  The context to use for checking for a reference if it doesn&#039;t exist in the object.
	 * @param {Boolean} [isHelper]  Whether the reference is a helper.
	 */
	Mustache.get = function(ref, contexts, isHelper, isArgument) {
		var options = contexts.options || {};
		contexts = contexts.context || contexts;
		// Assume the local object is the last context in the stack.
		var obj = contexts[contexts.length - 1],
			// Assume the parent context is the second to last context in the stack.
			context = contexts[contexts.length - 2],
			// Split the reference (like `a.b.c`) into an array of key names.
			names = ref.indexOf(&#039;\\.&#039;) == -1 
				// Reference doesn&#039;t contain escaped periods
				? ref.split(&#039;.&#039;)
				// Reference contains escaped periods (`a.b\c.foo` == `a[&quot;b.c&quot;].foo)
				: (function() {
						var names = [], last = 0;
						ref.replace(/(\\)?\./g, function($0, $1, index) {
							if (!$1) {
								names.push(ref.slice(last, index).replace(/\\\./g,&#039;.&#039;));
								last = index + $0.length;
							}
						});
						names.push(ref.slice(last).replace(/\\\./g,&#039;.&#039;));
						return names;
					})(),
			namesLength = names.length,
			value, lastValue, name, i, j,
			// if we walk up and don&#039;t find a property, we default
			// to listening on an undefined property of the first
			// context that is an observe
			defaultObserve,
			defaultObserveName;

		// Handle `this` references for list iteration: {{.}} or {{this}}
		if (/^\.|this$/.test(ref)) {
			// If context isn&#039;t an object, then it was a value passed by a helper so use it as an override.
			if (!/^object|undefined$/.test(typeof context)) {
				return context || &#039;&#039;;
			}
			// Otherwise just return the closest object.
			else {
				while (value = contexts.pop()) {
					if (typeof value !== &#039;undefined&#039;) {
						return value;
					} 
				}
				return &#039;&#039;;
			}
		} 
		// Handle object resolution (like `a.b.c`).
		else if (!isHelper) {
			// Reverse iterate through the contexts (last in, first out).
			for (i = contexts.length - 1; i &gt;= 0; i--) {
				// Check the context for the reference
				value = contexts[i];
			
				// Is the value a compute?
				if(can.isFunction(value) &amp;&amp; value.isComputed) {
					value = value();
				}
			
				// Make sure the context isn&#039;t a failed object before diving into it.
				if (typeof value !== &#039;undefined&#039; &amp;&amp; value !== null) {
					var isHelper = Mustache.getHelper(ref, options);
					for (j = 0; j &lt; namesLength; j++) {
						// Keep running up the tree while there are matches.
						if (typeof value[names[j]] !== &#039;undefined&#039; &amp;&amp; value[names[j]] !== null) {
							lastValue = value;
							value = value[name = names[j]];
						}
						// if there&#039;s a name conflict between property and helper
						// property wins
						else if(isHelper) {
							return ref;
						}
						// If it&#039;s undefined, still match if the parent is an Observe.
						else if ( isObserve(value) ) {
							defaultObserve = value;
							defaultObserveName = names[j];
							lastValue = value = undefined;
							break;
						}
						else {
							lastValue = value = undefined;
							break;
						}
					}
				}
			
				// Found a matched reference.
				if (value !== undefined ) {
					return Mustache.resolve(value, lastValue, name, isArgument);
				}
			}
		}

		if( defaultObserve &amp;&amp; 
			// if there&#039;s not a helper by this name and no attribute with this name
			!(Mustache.getHelper(ref) &amp;&amp;
				can.inArray(defaultObserveName, can.Observe.keys(defaultObserve)) === -1) ) {
			return defaultObserve.compute(defaultObserveName);
		}
		// Support helpers without arguments, but only if there wasn&#039;t a matching data reference.
		// Helpers have priority over local function, see https://github.com/bitovi/canjs/issues/258
		if (value = Mustache.getHelper(ref,options)) {
			return ref;
		} else if (typeof obj !== &#039;undefined&#039; &amp;&amp; obj !== null &amp;&amp; can.isFunction(obj[ref])) {
			// Support helper-like functions as anonymous helpers
			return obj[ref];
		}

		return &#039;&#039;;
	};
	
	/**
	 * @hide
	 *
	 * Resolves an object to its truthy equivalent.
	 *
	 * @param {Object} value    The object to resolve.
	 * @param {Object} [lastValue]  	Only used with Mustache.get.
	 * @param {Object} [name]  				Only used with Mustache.get.
	 * @param {Boolean} [isArgument]  Only used with Mustache.get.
	 * @return {Object} The resolved object.
	 */
	Mustache.resolve = function(value, lastValue, name, isArgument) {
		if(lastValue &amp;&amp; can.isFunction(lastValue[name]) &amp;&amp; isArgument) {
			if(lastValue[name].isComputed){
				return lastValue[name];
			}
			// Don&#039;t execute functions if they are parameters for a helper and are not a can.compute
			// Need to bind it to the original context so that that information doesn&#039;t get lost by the helper
			return function() { 
				return lastValue[name].apply(lastValue, arguments); 
			};
		}
		// Support attributes on compute objects
		else if(lastValue &amp;&amp; can.isFunction(lastValue) &amp;&amp; lastValue.isComputed) {
			return lastValue()[name];
		}
		// Support functions stored in objects.
		else if (lastValue &amp;&amp; can.isFunction(lastValue[name])) {
			return lastValue[name]();
		} 
		// Invoke the length to ensure that Observe.List events fire.
		else if (isObserve(value) &amp;&amp; isArrayLike(value) &amp;&amp; value.attr(&#039;length&#039;)){
			return value;
		}
		// Add support for observes
		else if (lastValue &amp;&amp; isObserve(lastValue)) {
			return lastValue.compute(name);
		} 
		else if (can.isFunction(value)) {
			return value();
		}
		else {
			return value;
		}
	};
	
	/**
	 * @static
	 */
	// ## Helpers
	//
	// Helpers are functions that can be called from within a template.
	// These helpers differ from the scanner helpers in that they execute
	// at runtime instead of during compilation.
	//
	// Custom helpers can be added via `can.Mustache.registerHelper`,
	// but there are also some built-in helpers included by default.
	// Most of the built-in helpers are little more than aliases to actions 
	// that the base version of Mustache simply implies based on the 
	// passed in object.
	// 
	// Built-in helpers:
	// 
	// * `data` - `data` is a special helper that is implemented via scanning helpers. 
	//		It hooks up the active element to the active data object: `&lt;div {{data &quot;key&quot;}} /&gt;`
	// * `if` - Renders a truthy section: `{{#if var}} render {{/if}}`
	// * `unless` - Renders a falsey section: `{{#unless var}} render {{/unless}}`
	// * `each` - Renders an array: `{{#each array}} render {{this}} {{/each}}`
	// * `with` - Opens a context section: `{{#with var}} render {{/with}}`
	Mustache._helpers = {};
	/**
	 * @description Register a helper.
	 * @function can.Mustache.registerHelper registerHelper
	 * @signature `Mustache.registerHelper(name, helper)`
	 * @param {String} name The name of the helper.
	 * @param {can.Mustache.helper} helper The helper function.
	 * 
	 * @body
	 * Registers a helper with the Mustache system.
	 * Pass the name of the helper followed by the
	 * function to which Mustache should invoke.
	 * These are run at runtime.
	 */
	Mustache.registerHelper = function(name, fn){
		this._helpers[name]={ name: name, fn: fn };
	};
	
	/**
	 * @hide
	 * @function can.Mustache.getHelper getHelper
	 * @description Retrieve a helper.
	 * @signature `Mustache.getHelper(name)`
	 * @param {String} name The name of the helper.
	 * @return {Function|null} The helper, or `null` if
	 * no helper by that name is found.
	 *
	 * @body 
	 * Returns a helper given the name.
	 */
	Mustache.getHelper = function(name,options) {
		return options &amp;&amp; options.helpers &amp;&amp; options.helpers[name] &amp;&amp; {
			fn: options.helpers[name]
		} || this._helpers[name];
	};

	/**
	 * @function can.Mustache.static.render render
	 * @hide
	 * @parent can.Mustache.static
	 * @signature `Mustache.render(partial, context)`
	 * @param {Object} partial
	 * @param {Object} context
	 *
	 * @body
	 * `Mustache.render` is a helper method that calls
	 * into `can.view.render` passing the partial 
	 * and the context object.  
	 * 
	 * Its purpose is to determine if the partial object 
	 * being passed represents a template like:
	 *
	 * 		partial === &quot;movember.mustache&quot;
	 *
	 * or if the partial is a variable name that represents
	 * a partial on the context object such as:
	 *
	 * 		context[partial] === &quot;movember.mustache&quot;
	 */
	Mustache.render = function(partial, context){
		// Make sure the partial being passed in
		// isn&#039;t a variable like { partial: &quot;foo.mustache&quot; }
		if(!can.view.cached[partial] &amp;&amp; context[partial]){
			partial = context[partial];
		}

		// Call into `can.view.render` passing the
		// partial and context.
		return can.view.render(partial, context);
	};

	Mustache.renderPartial = function(partial,context,options) {
		return partial.render ? partial.render(context,options) :
			partial(context,options);
	};

	// The built-in Mustache helpers.
	can.each({
		// Implements the `if` built-in helper.
		/**
		 * @function can.Mustache.helpers.if {{#if key}}
		 * @parent can.Mustache.htags 2
		 * @signature `{{#if key}}BLOCK{{/if}}`
	 	 * 
	 	 * Renders the `BLOCK` template within the current template.
	 	 * 
	 	 * @param {can.Mustache.key} key A key that references a value within the current or parent 
	 	 * context. If the value is a function or can.compute, the function&#039;s return value is used.
	 	 * 
	 	 * @param {can.Mustache} BLOCK A mustache template.
	 	 * 
	 	 * @return {String} If the key&#039;s value is truthy, the `BLOCK` is rendered with the
	 	 * current context and its value is returned; otherwise, an empty string.
	 	 * 
	 	 * @body
	 	 * 
	 	 * ## Use
	 	 * 
		 * `{{#if key}}` provides explicit conditional truthy tests. For example,
		 * 
		 * The template:
		 * 
		 *     {{#if user.isFemale}}
		 *       {{#if user.isMarried}}
		 *         Mrs 
		 *       {{/if}}
		 *       {{#if user.isSingle}}
		 *         Miss 
		 *       {{/if}}
		 *     {{/if}}
		 * 
		 * Rendered with:
		 * 
		 *     {user: {isFemale: true, isMarried: true}}
		 *     
		 * Results in:
		 * 
		 *     Mrs
		 * 
		 * If can be used with [can.Mustache.helpers.else {{else}}] too. For example,
		 * 
		 *     {{#if user.isFemale}}
		 *       {{#if user.isMarried}}
		 *         Mrs 
		 *       {{else}}
		 *         Miss 
		 *       {{/if}}
		 *     {{/if}}
		 * 
		 * Rendered with:
		 * 
		 *     {user: {isFemale: true, isMarried: false}}
		 *     
		 * Results in:
		 * 
		 *     Miss
		 */
		&#039;if&#039;: function(expr, options){
			if (!!Mustache.resolve(expr)) {
				return options.fn(options.contexts || this);
			}
			else {
				return options.inverse(options.contexts || this);
			}
		},
		// Implements the `unless` built-in helper.
		/**
		 * @function can.Mustache.helpers.unless {{#unless key}}
		 * @parent can.Mustache.htags 4
		 * 
	 	 * @signature `{{#unless key}}BLOCK{{/unless}}`
	 	 * 
	 	 * Render the block of text if the key&#039;s value is falsey.
	 	 * 
	 	 * @param {can.Mustache.key} key A key that references a value within the current or parent 
		 * context. If the value is a function or can.compute, the function&#039;s 
		 * return value is used.
		 * 
	 	 * @param {can.Mustache} BLOCK A template that is rendered 
	 	 * if the `key`&#039;s value is falsey.
	 	 * 
	 	 * @body
	 	 * 
		 * The `unless` helper evaluates the inverse of the value
		 * of the key and renders the block between the helper and the slash.
		 * 
		 *     {{#unless expr}}
		 *       // unless
		 *     {{/unless}}
		 */
		&#039;unless&#039;: function(expr, options){
			if (!Mustache.resolve(expr)) {
				return options.fn(options.contexts || this);
			}
		},
		
		// Implements the `each` built-in helper.
		/**
		 * @function can.Mustache.helpers.each {{#each key}}
	 	 * @parent can.Mustache.htags 5
	 	 * 
	 	 * @signature `{{#each key}}BLOCK{{/each}}`
	 	 * 
	 	 * Render the block of text for each item in key&#039;s value.
	 	 * 
	 	 * @param {can.Mustache.key} key A key that references a value within the current or parent 
		 * context. If the value is a function or can.compute, the function&#039;s 
		 * return value is used.
		 * 
		 * If the value of the key is a [can.Observe.List], the resulting HTML is updated when the
		 * list changes. When a change in the list happens, only the minimum amount of DOM
		 * element changes occur.
	 	 * 
	 	 * @param {can.Mustache} BLOCK A template that is rendered for each item in 
	 	 * the `key`&#039;s value. The `BLOCK` is rendered with the context set to the item being rendered.
	 	 * 
	 	 * @body
	 	 * 
	 	 * ## Use
	 	 * 
	 	 * Use the `each` helper to iterate over a array
		 * of items and render the block between the helper and the slash. For example,
		 * 
		 * The template:
		 * 
		 *     &lt;ul&gt;
		 *       {{#each friends}}
		 *         &lt;li&gt;{{name}}&lt;/li&gt;
		 *       {{/each}}
		 *     &lt;/ul&gt;
		 * 
		 * Rendered with:
		 * 
		 *     {friends: [{name: &quot;Austin&quot;},{name: &quot;Justin&quot;}]}
		 * 
		 * Renders:
		 * 
		 *     &lt;ul&gt;
		 *       &lt;li&gt;Austin&lt;/li&gt;
		 *       &lt;li&gt;Justin&lt;/li&gt;
		 *     &lt;/ul&gt;
		 * 
		 */
		&#039;each&#039;: function(expr, options) {
      		expr = Mustache.resolve(expr);
			if (!!expr &amp;&amp; isArrayLike(expr)) {
				if (isObserve(expr) &amp;&amp; typeof expr.attr(&#039;length&#039;) !== &#039;undefined&#039;) {
					return can.view.lists &amp;&amp; can.view.lists(expr, function(item) {
						return options.fn(item);
					});
				}
				else {
					var result = [];
					for (var i = 0; i &lt; expr.length; i++) {
						result.push(options.fn(expr[i]));
					}
					return result.join(&#039;&#039;);
				}
			}
		},
		// Implements the `with` built-in helper.
		/**
		 * @function can.Mustache.helpers.with {{#with key}}
		 * @parent can.Mustache.htags 6
		 * 
		 * @signature `{{#with key}}BLOCK{{/with}}`
		 * 
		 * Changes the context within a block.
		 * 
		 * @param {can.Mustache.key} key A key that references a value within the current or parent 
		 * context. If the value is a function or can.compute, the function&#039;s 
		 * return value is used.
		 * 
	 	 * @param {can.Mustache} BLOCK A template that is rendered 
	 	 * with the context of the `key`&#039;s value.
		 * 
		 * @body
	 	 * 
		 * Mustache typically applies the context passed in the section 
		 * at compiled time.  However, if you want to override this 
		 * context you can use the `with` helper.
		 * 
		 *     {{#with arr}}
		 *       // with
		 *     {{/with}}
		 */
		&#039;with&#039;: function(expr, options){
			var ctx = expr;
			expr = Mustache.resolve(expr);
			if (!!expr) {
				return options.fn(ctx);
			}
		}
		
		/**
		 * @function can.Mustache.helpers.elementCallback {{(el)-&gt;CODE}}
		 *
		 * @parent can.Mustache.htags 8
		 *
		 * @signature `{{(el) -&gt; CODE}}`
		 * 
		 * Executes an element callback with the inline code on the element.
		 * 
		 * @param {String} code The inline code to execute on the element.
		 * 
		 * @body
		 * 
		 * ## Use 
		 * 
		 * It is common for you to want to execute some code on a given 
		 * DOM element. An example would be for initializing a jQuery plugin 
		 * on the new HTML.
		 * 
		 * 		&lt;div class=&quot;tabs&quot; {{(el) -&gt; el.jquery_tabs()}}&gt;&lt;/div&gt;
		 * 
		 */
		//
	}, function(fn, name){
		Mustache.registerHelper(name, fn);
	});
	
	// ## Registration
	//
	// Registers Mustache with can.view.
	can.view.register({
		suffix: &quot;mustache&quot;,

		contentType: &quot;x-mustache-template&quot;,

		// Returns a `function` that renders the view.
		script: function( id, src ) {
			return &quot;can.Mustache(function(_CONTEXT,_VIEW) { &quot; + new Mustache({
				text: src,
				name: id
			}).template.out + &quot; })&quot;;
		},

		renderer: function( id, text ) {
			return Mustache({
				text: text,
				name: id
			});
		}
	});

	return can;
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>

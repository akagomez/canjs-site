<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>observe/observe.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">67.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">1997</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">146.87</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">5.88</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// 1.69
steal(&#039;can/util&#039;,&#039;can/util/bind&#039;,&#039;can/construct&#039;, function(can, bind) {
	// ## observe.js  
	// `can.Observe`  
	// _Provides the observable pattern for JavaScript Objects._  
	//  
	// Returns `true` if something is an object with properties of its own.
	var canMakeObserve = function( obj ) {
			return obj &amp;&amp; !can.isDeferred(obj) &amp;&amp; (can.isArray(obj) || can.isPlainObject( obj ) || ( obj instanceof can.Observe ));
		},
		
		// Removes all listeners.
		unhookup = function(items, namespace){
			return can.each(items, function(item){
				if(item &amp;&amp; item.unbind){
					item.unbind(&quot;change&quot; + namespace);
				}
			});
		},
		// Listens to changes on `child` and &quot;bubbles&quot; the event up.  
		// `child` - The object to listen for changes on.  
		// `prop` - The property name is at on.  
		// `parent` - The parent object of prop.
		// `ob` - (optional) The Observe object constructor
		// `list` - (optional) The observable list constructor
		hookupBubble = function( child, prop, parent, Ob, List ) {
			Ob = Ob || Observe;
			List = List || Observe.List;

			// If it&#039;s an `array` make a list, otherwise a child.
			if (child instanceof Observe){
				// We have an `observe` already...
				// Make sure it is not listening to this already
				// It&#039;s only listening if it has bindings already.
				parent._bindings &amp;&amp;unhookup([child], parent._cid);
			} else if ( can.isArray(child) ) {
				child = new List(child);
			} else {
				child = new Ob(child);
			}
			// only listen if something is listening to you
			if(parent._bindings){
				// Listen to all changes and `batchTrigger` upwards.
				bindToChildAndBubbleToParent(child, prop, parent)
			}
			

			return child;
		},
		bindToChildAndBubbleToParent = function(child, prop, parent){
			child.bind(&quot;change&quot; + parent._cid, 
				function( /* ev, attr */ ) {
				// `batchTrigger` the type on this...
				var args = can.makeArray(arguments),
					ev = args.shift();
					args[0] = (prop === &quot;*&quot; ? 
						[ parent.indexOf( child ), args[0]] :
						[ prop, args[0]] ).join(&quot;.&quot;);

				// track objects dispatched on this observe		
				ev.triggeredNS = ev.triggeredNS || {};

				// if it has already been dispatched exit
				if (ev.triggeredNS[parent._cid]) {
					return;
				}

				ev.triggeredNS[parent._cid] = true;
				// send change event with modified attr to parent	
				can.trigger(parent, ev, args);
				// send modified attr event to parent
				//can.trigger(parent, args[0], args);
			});
		},
		// An `id` to track events for a given observe.
		observeId = 0,
		// A helper used to serialize an `Observe` or `Observe.List`.  
		// `observe` - The observable.  
		// `how` - To serialize with `attr` or `serialize`.  
		// `where` - To put properties, in an `{}` or `[]`.
		serialize = function( observe, how, where ) {
			// Go through each property.
			observe.each(function( val, name ) {
				// If the value is an `object`, and has an `attrs` or `serialize` function.
				where[name] = canMakeObserve(val) &amp;&amp; can.isFunction( val[how] ) ?
				// Call `attrs` or `serialize` to get the original data back.
				val[how]() :
				// Otherwise return the value.
				val;
			});
			return where;
		},
		attrParts = function(attr, keepKey) {
			if(keepKey) {
				return [attr];
			}
			return can.isArray(attr) ? attr : (&quot;&quot;+attr).split(&quot;.&quot;);
		},
		// Which batch of events this is for -- might not want to send multiple
		// messages on the same batch.  This is mostly for event delegation.
		batchNum = 1,
		// how many times has start been called without a stop
		transactions = 0,
		// an array of events within a transaction
		batchEvents = [],
		stopCallbacks = [],
		makeBindSetup = function(wildcard){
			return function(){
				var parent = this;
				this._each(function(child, prop){
					if(child &amp;&amp; child.bind){
						bindToChildAndBubbleToParent(child, wildcard || prop, parent)
					}
				})
			};
		};
	
	/**
	 * @add can.Observe
	 */
	//
	var Observe = can.Map = can.Observe = can.Construct( {
	/**
	 * @static
	 */
		// keep so it can be overwritten
		bind : can.bindAndSetup,
		unbind: can.unbindAndTeardown,
		id: &quot;id&quot;,
		canMakeObserve : canMakeObserve,
		// starts collecting events
		// takes a callback for after they are updated
		// how could you hook into after ejs
		/**
		 * @function can.Observe.startBatch startBatch
		 * @parent can.Observe.static
		 * @description Begin an event batch.
		 * 
		 * @signature `can.Observe.startBatch([batchStopHandler])`
		 * 
		 * @param {Function} [batchStopHandler] a callback that gets called after all batched events have been called
		 *
		 * @body
		 * `startBatch` causes [can.Observe] to begin an event batch. Until `[can.Observe.stopBatch]` is called, any
		 * events that would result from calls to `[can.Observe::attr attr]` are held back from firing. If you have
		 * lots of changes to make to can.Observes, batching them together can help performance &amp;emdash; especially if
		 * those can.Observes are live-bound to the DOM.
		 *
		 * In this example, you can see how the _first_ and _change_ events are not fired (and their handlers
		 * are not called) until `stopBatch` is called.
		 *
		 * @codestart
		 * var person = new can.Observe({
		 *     first: &#039;Alexis&#039;,
		 *     last: &#039;Abril&#039;
		 * });
		 *
		 * person.bind(&#039;first&#039;, function() {
		 *     console.log(&quot;First name changed.&quot;);
		 * }).bind(&#039;change&#039;, function() {
		 *     console.log(&quot;Something changed.&quot;);
		 * });
		 * 
		 * can.Observe.startBatch();
		 * person.attr(&#039;first&#039;, &#039;Alex&#039;);
		 * console.log(&#039;Still in the batch.&#039;);
		 * can.Observe.stopBatch();
		 * 
		 * // the log has:
		 * // Still in the batch.
		 * // First name changed.
		 * // Something changed.
		 * @codeend
		 *
		 * You can also pass a callback to `startBatch` which will be called after all the events have
		 * been fired:
		 * @codestart
		 * can.Observe.startBatch(function() {
		 *     console.log(&#039;The batch is over.&#039;);
		 * });
		 * person.attr(&#039;first&#039;, &#039;Izzy&#039;);
		 * console.log(&#039;Still in the batch.&#039;);
		 * can.Observe.stopBatch();
		 * 
		 * // The console has:
		 * // Still in the batch.
		 * // First name changed.
		 * // Something changed.
		 * // The batch is over.
		 * @codeend
		 *
		 * ## Calling `startBatch` multiple times
		 * 
		 * If you call `startBatch` more than once, `stopBatch` needs to be called
		 * the same number of times before any batched events will fire. For ways
		 * to circumvent this process, see [can.Observe.stopBatch].
		 *
		 * Here is an example that demonstrates how events are affected by calling
		 * `startBatch` multiple times.
		 * 
		 * @codestart
		 * var addPeople = function(observable) {
		 *     can.Observe.startBatch();
		 *     observable.attr(&#039;a&#039;, &#039;Alice&#039;);
		 *     observable.attr(&#039;b&#039;, &#039;Bob&#039;);
		 *     observable.attr(&#039;e&#039;, &#039;Eve&#039;);
		 *     can.Observe.stopBatch();
		 * };
		 *
		 * // In a completely different place:
		 * var list = new can.Observe();
		 * list.bind(&#039;change&#039;, function() {
		 *     console.log(&#039;The list changed.&#039;);
		 * });
		 *
		 * can.Observe.startBatch();
		 * addPeople(list);
		 * console.log(&#039;Still in the batch.&#039;);
		 *
		 * // Here, the console has:
		 * // Still in the batch.
		 * 
		 * can.Observe.stopBatch();
		 * 
		 * // Here, the console has:
		 * // Still in the batch.
		 * // The list changed.
		 * // The list changed.
		 * // The list changed.
		 * @codeend
		 */
		startBatch: function( batchStopHandler ) {
			transactions++;
			batchStopHandler &amp;&amp; stopCallbacks.push(batchStopHandler);
		},
		/**
		 * @function can.Observe.stopBatch stopBatch
		 * @parent can.Observe.static
		 * @description End an event batch.
		 * @signature `can.Observe.stopBatch([force[, callStart]])`
		 * @param {bool} [force=false] whether to stop batching events immediately
		 * @param {bool} [callStart=false] whether to call `[can.Observe.startBatch startBatch]` after firing batched events
		 * 
		 * @body
		 * `stopBatch` matches an earlier `[can.Observe.startBatch]` call. If `stopBatch` has been
		 * called as many times as `startBatch` (or if _force_ is true), all batched events will be
		 * fired and any callbacks passed to `startBatch` since the beginning of the batch will be
		 * called. If _force and _callStart_ are both true, a new batch will be started when all
		 * the events and callbacks have been fired.
		 *
		 * See `[can.Observe.startBatch]` for examples of `startBatch` and `stopBatch` in normal use.
		 * 
		 * In this example, the batch is forceably ended in the `addPeople` function.
		 * @codestart
		 * var addPeople = function(observable) {
		 *     can.Observe.startBatch();
		 *     observable.attr(&#039;a&#039;, &#039;Alice&#039;);
		 *     observable.attr(&#039;b&#039;, &#039;Bob&#039;);
		 *     observable.attr(&#039;e&#039;, &#039;Eve&#039;);
		 *     can.Observe.stopBatch(true);
		 * };
		 *
		 * // In a completely different place:
		 * var list = new can.Observe();
		 * list.bind(&#039;change&#039;, function() {
		 *     console.log(&#039;The list changed.&#039;);
		 * });
		 *
		 * can.Observe.startBatch();
		 * addPeople(list);
		 * console.log(&#039;Still in the batch.&#039;);
		 *
		 * // Here, the console has:
		 * // Still in the batch.
		 * 
		 * can.Observe.stopBatch();
		 * 
		 * // Here, the console has:
		 * // The list changed.
		 * // The list changed.
		 * // The list changed.
		 * // Still in the batch.
		 * @codeend
		 */
		stopBatch: function(force, callStart){
			if(force){
				transactions = 0;
			} else {
				transactions--;
			}
			
			if(transactions == 0){
				var items = batchEvents.slice(0),
					callbacks = stopCallbacks.slice(0);
				batchEvents= [];
				stopCallbacks = [];
				batchNum++;
				callStart &amp;&amp; this.startBatch();
				can.each(items, function( args ) {
					can.trigger.apply(can, args);
				});
				can.each(callbacks, function( cb ) {
					cb();
				});
			}
		},
		/**
		 * @function can.Observe.triggerBatch triggerBatch
		 * @parent can.Observe.static
		 * @description Trigger an event to be added to the current batch.
		 * @signature `can.Observe.triggerBatch(item, event [, args])`
		 * @param {can.Observe} item the target of the event
		 * @param {String|Object} event the type of event (e.g. &quot;change&quot;), or an event object with a type given (e.g. {type: &quot;change&quot;})
		 * @param {Array} [args] the parameters to trigger the event with.
		 * 
		 * @body
		 * If events are currently being batched, calling `triggerBatch` adds an event
		 * to the batch. If events are not currently being batched, the event is triggered
		 * immediately.
		 */
		triggerBatch: function( item, event, args ) {
			// Don&#039;t send events if initalizing.
			if ( ! item._init) {
				if (transactions == 0 ) {
					return can.trigger(item, event, args);
				} else {
					event = typeof event === &quot;string&quot; ?
						{ type: event } : 
						event;
					event.batchNum = batchNum;
					batchEvents.push([
					item,
					event, 
					args ] );
				}
			}
		},
		/**
		 * @function can.Observe.keys keys
		 * @parent can.Observe.static
		 * @description Iterate over the keys of an Observe.
		 * @signature `can.Observe.keys(observe)`
		 * @param {can.Observe} observe the `can.Observe` to get the keys from
		 * @return {Array} An array containing the keys from _observe_.
		 * 
		 * @body
		 * `keys` iterates over an observe to get an array of its keys.
		 * 
		 * @codestart
		 * var people = new can.Observe({
		 *     a: &#039;Alice&#039;,
		 *     b: &#039;Bob&#039;,
		 *     e: &#039;Eve&#039;
		 * });
		 * 
		 * can.Observe.keys(people); // [&#039;a&#039;, &#039;b&#039;, &#039;e&#039;]
		 * @codeend
		 */
		keys: function(observe) {
			var keys = [];
			Observe.__reading &amp;&amp; Observe.__reading(observe, &#039;__keys&#039;);
			for(var keyName in observe._data) {
				keys.push(keyName);
			}
			return keys;
		}
	},
	/**
	 * @prototype
	 */
	{
		setup: function( obj ) {
			// `_data` is where we keep the properties.
			this._data = {};
			/**
			 * @property {String} can.Observe.prototype._cid
			 * @hide
			 *
			 * A globally unique ID for this `can.Observe` instance.
			 */
			// The namespace this `object` uses to listen to events.
			can.cid(this, &quot;.observe&quot;);
			// Sets all `attrs`.
			this._init = 1;
			this.attr(obj);
			this.bind(&#039;change&#039;+this._cid,can.proxy(this._changes,this));
			delete this._init;
		},
		_bindsetup: makeBindSetup(),
		_bindteardown: function(){
			var cid = this._cid;
			this._each(function(child){
				unhookup([child], cid)
			})
		},
		_changes: function(ev, attr, how,newVal, oldVal){
			Observe.triggerBatch(this, {type:attr, batchNum: ev.batchNum}, [newVal,oldVal]);
		},
		_triggerChange: function(attr, how,newVal, oldVal){
			Observe.triggerBatch(this,&quot;change&quot;,can.makeArray(arguments))
		},
		// no live binding iterator
		_each: function(callback){
			var data = this.__get();
			for(var prop in data){
				if(data.hasOwnProperty(prop)){
					callback(data[prop],prop)
				}
			}
		},
		/**
		 * @function can.Observe.prototype.attr attr
		 * @description Get or set properties on an Observe.
		 * @signature `observe.attr()`
		 * 
		 * Gets a collection of all the properties in this `can.Observe`.
		 * 
		 * @return {Object&lt;String, *&gt;} an object with all the properties in this `can.Observe`.
		 * 
		 * @signature `observe.attr(key)`
		 * 
		 * Reads a property from this `can.Observe`.
		 * 
		 * @param {String} key the property to read
		 * @return {*} the value assigned to _key_.
		 *
		 * @signature `observe.attr(key, value)`
		 * 
		 * Assigns _value_ to a property on this `can.Observe` called _key_.
		 * 
		 * @param {String} key the property to set
		 * @param {*} value the value to assign to _key_.
		 * @return {can.Observe} this Observe, for chaining
		 * 
		 * @signature `observe.attr(obj[, removeOthers])`
		 * 
		 * Assigns each value in _obj_ to a property on this `can.Observe` named after the
		 * corresponding key in _obj_, effectively merging _obj_ into the Observe.
		 * 
		 * @param {Object&lt;String, *&gt;} obj a collection of key-value pairs to set.
		 * If any properties already exist on the `can.Observe`, they will be overwritten.
		 *
		 * @param {bool} [removeOthers=false] whether to remove keys not present in _obj_.
		 * To remove keys without setting other keys, use `[can.Observe::removeAttr removeAttr]`.
		 *
		 * @return {can.Observe} this Observe, for chaining
		 * 
		 * @body
		 * `attr` gets or sets properties on the `can.Observe` it&#039;s called on. Here&#039;s a tour through
		 * how all of its forms work:
		 *
		 * @codestart
		 * var people = new can.Observe({});
		 * 
		 * // set a property:
		 * people.attr(&#039;a&#039;, &#039;Alex&#039;);
		 * 
		 * // get a property:
		 * people.attr(&#039;a&#039;); // &#039;Alex&#039;
		 *
		 * // set and merge multiple properties:
		 * people.attr({
		 *     a: &#039;Alice&#039;,
		 *     b: &#039;Bob&#039;
		 * });
		 * 
		 * // get all properties:
		 * people.attr(); // {a: &#039;Alice&#039;, b: &#039;Bob&#039;}
		 * 
		 * // set properties while removing others:
		 * people.attr({
		 *     b: &#039;Bill&#039;,
		 *     e: &#039;Eve&#039;
		 * }, true);
		 *
		 * people.attr(); // {b: &#039;Bill&#039;, e: &#039;Eve&#039;}
		 * @codeend
		 * 
		 * ## Deep properties
		 * 
		 * `attr` can also set and read deep properties. All you have to do is specify
		 * the property name as you normally would if you weren&#039;t using `attr`.
		 * 
		 * @codestart
		 * var people = new can.Observe({names: {}});
		 * 
		 * // set a property:
		 * people.attr(&#039;names.a&#039;, &#039;Alice&#039;);
		 * 
		 * // get a property:
		 * people.attr(&#039;names.a&#039;); // &#039;Alice&#039;
		 * people.names.attr(&#039;a&#039;); // &#039;Alice&#039;
		 *
		 * // get all properties:
		 * people.attr(); // {names: {a: &#039;Alice&#039;}}
		 * @codeend
		 * 
		 * Objects that are added to Observes become Observes themselves behind the scenes,
		 * so changes to deep properties fire events at each level, and you can bind at any
		 * level. As this example shows, all the same events are fired no matter what level
		 * you call `attr` at:
		 * 
		 * @codestart
		 * var people = new can.Observe({names: {}});
		 *
		 * people.bind(&#039;change&#039;, function(ev, attr, how, newVal, oldVal) {
		 *   console.log(&#039;people change: &#039; + attr + &#039;, &#039; + how + &#039;, &#039; + newVal + &#039;, &#039; + oldVal);
		 * });
		 * 
		 * people.names.bind(&#039;change&#039;, function(ev, attr, how, newVal, oldVal) {
		 *    console.log(&#039;people.names change&#039; + attr + &#039;, &#039; + how + &#039;, &#039; + newVal + &#039;, &#039; + oldVal);
		 * });
		 * 
		 * people.bind(&#039;names&#039;, function(ev, newVal, oldVal) {
		 *     console.log(&#039;people names: &#039; + newVal + &#039;, &#039; + oldVal);
		 * });
		 *
		 * people.names.bind(&#039;a&#039;, function(ev, newVal, oldVal) {
		 *     console.log(&#039;people.names a: &#039; + newVal + &#039;, &#039; + oldVal);
		 * });
		 * 
		 * people.bind(&#039;names.a&#039;, function(ev, newVal, oldVal) {
		 *     console.log(&#039;people names.a: &#039; + newVal + &#039;, &#039; + oldVal);
		 * });
		 * 
		 * people.attr(&#039;names.a&#039;, &#039;Alice&#039;); // people change: names.a, add, Alice, undefined
		 *                                  // people.names change: a, add, Alice, undefined
		 *                                  // people.names a: Alice, undefined
		 *                                  // people names.a: Alice, undefined
		 * 
		 * people.names.attr(&#039;b&#039;, &#039;Bob&#039;);   // people change: names.b, add, Bob, undefined
		 *                                  // people.names change: b, add, Bob, undefined
		 *                                  // people.names b: Bob, undefined
		 *                                  // people names.b: Bob, undefined
		 * @codeend
		 * 
		 * ## See also
		 * 
		 * For information on the events that are fired on property changes and how
		 * to listen for those events, see [can.Observe.prototype.bind bind].
		 */
		attr: function( attr, val ) {
			// This is super obfuscated for space -- basically, we&#039;re checking
			// if the type of the attribute is not a `number` or a `string`.
			var type = typeof attr;
			if ( type !== &quot;string&quot; &amp;&amp; type !== &quot;number&quot; ) {
				return this._attrs(attr, val)
			} else if ( arguments.length === 1 ) {// If we are getting a value.
				// Let people know we are reading.
				Observe.__reading &amp;&amp; Observe.__reading(this, attr)
				return this._get(attr)
			} else {
				// Otherwise we are setting.
				this._set(attr, val);
				return this;
			}
		},
		/**
		 * @function can.Observe.prototype.each each
		 * @description Call a function on each property of an Observe.
		 * @signature `observe.each( callback(item, propName ) )`
		 * 
		 * `each` iterates through the Observe, calling a function
		 * for each property value and key.
		 * 
		 * @param {function(*,String)} callback(item,propName) the function to call for each property
		 * The value and key of each property will be passed as the first and second
		 * arguments, respectively, to the callback. If the callback returns false,
		 * the loop will stop.
		 * 
		 * @return {can.Observe} this Observe, for chaining
		 *
		 * @body
		 * @codestart
		 * var names = [];
		 * new can.Observe({a: &#039;Alice&#039;, b: &#039;Bob&#039;, e: &#039;Eve&#039;}).each(function(value, key) {
		 *     names.push(value);
		 * });
		 * 
		 * names; // [&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;]
		 * 
		 * names = [];
		 * new can.Observe({a: &#039;Alice&#039;, b: &#039;Bob&#039;, e: &#039;Eve&#039;}).each(function(value, key) {
		 *     names.push(value);
		 *     if(key === &#039;b&#039;) {
		 *         return false;
		 *     }
		 * });
		 * 
		 * names; // [&#039;Alice&#039;, &#039;Bob&#039;]
		 * 
		 * @codeend
		 */
		each: function() {
			Observe.__reading &amp;&amp; Observe.__reading(this, &#039;__keys&#039;);
			return can.each.apply(undefined, [this.__get()].concat(can.makeArray(arguments)))
		},
		/**
		 * @function can.Observe.prototype.removeAttr removeAttr
		 * @description Remove a property from an Observe.
		 * @signature `observe.removeAttr(attrName)`
		 * @param {String} attrName the name of the property to remove
		 * @return {*} the value of the property that was removed
		 * 
		 * @body
		 * `removeAttr` removes a property by name from an Observe.
		 * 
		 * @codestart
		 * var people = new can.Observe({a: &#039;Alice&#039;, b: &#039;Bob&#039;, e: &#039;Eve&#039;});
		 * 
		 * people.removeAttr(&#039;b&#039;); // &#039;Bob&#039;
		 * people.attr();          // {a: &#039;Alice&#039;, e: &#039;Eve&#039;}
		 * @codeend
		 * 
		 * Removing an attribute will cause a _change_ event to fire with `&#039;remove&#039;`
		 * passed as the _how_ parameter and `undefined` passed as the _newVal_ to
		 * handlers. It will also cause a _property name_ event to fire with `undefined`
		 * passed as _newVal_. An in-depth description at these events can be found
		 * under `[can.Observe.prototype.attr attr]`.
		 */
		removeAttr: function( attr ) {
				// Info if this is List or not
			var isList = this instanceof can.Observe.List,
				// Convert the `attr` into parts (if nested).
				parts = attrParts(attr),
				// The actual property to remove.
				prop = parts.shift(),
				// The current value.
				current = isList ? this[prop] : this._data[prop];

			// If we have more parts, call `removeAttr` on that part.
			if ( parts.length ) {
				return current.removeAttr(parts)
			} else {
				if(isList) {
					this.splice(prop, 1)
				} else if( prop in this._data ){
					// Otherwise, `delete`.
					delete this._data[prop];
					// Create the event.
					if (!(prop in this.constructor.prototype)) {
						delete this[prop]
					}
					// Let others know the number of keys have changed
					Observe.triggerBatch(this, &quot;__keys&quot;);
					this._triggerChange(prop, &quot;remove&quot;, undefined, current);

				}
				return current;
			}
		},
		// Reads a property from the `object`.
		_get: function( attr ) {
			var value = typeof attr === &#039;string&#039; &amp;&amp; !!~attr.indexOf(&#039;.&#039;) &amp;&amp; this.__get(attr);
			if(value) {
				return value;
			}

			// break up the attr (`&quot;foo.bar&quot;`) into `[&quot;foo&quot;,&quot;bar&quot;]`
			var parts = attrParts(attr),
				// get the value of the first attr name (`&quot;foo&quot;`)
				current = this.__get(parts.shift());
			// if there are other attributes to read
			return parts.length ? 
				// and current has a value
				current ?
					// lookup the remaining attrs on current
					current._get(parts) : 
					// or if there&#039;s no current, return undefined
					undefined 	
				: 
				// if there are no more parts, return current
				current;
		},
		// Reads a property directly if an `attr` is provided, otherwise
		// returns the &quot;real&quot; data object itself.
		__get: function( attr ) {
			return attr ? this._data[attr] : this._data;
		},
		// Sets `attr` prop as value on this object where.
		// `attr` - Is a string of properties or an array  of property values.
		// `value` - The raw value to set.
		_set: function( attr, value, keepKey) {
			// Convert `attr` to attr parts (if it isn&#039;t already).
			var parts = attrParts(attr, keepKey),
				// The immediate prop we are setting.
				prop = parts.shift(),
				// The current value.
				current = this.__get(prop);

			// If we have an `object` and remaining parts.
			if ( canMakeObserve(current) &amp;&amp; parts.length ) {
				// That `object` should set it (this might need to call attr).
				current._set(parts, value)
			} else if (!parts.length ) {
				// We&#039;re in &quot;real&quot; set territory.
				if(this.__convert){
					value = this.__convert(prop, value)
				}
				this.__set(prop, value, current)
			} else {
				throw &quot;can.Observe: Object does not exist&quot;
			}
		},
		__set : function(prop, value, current){
		
			// Otherwise, we are setting it on this `object`.
			// TODO: Check if value is object and transform
			// are we changing the value.
			if ( value !== current ) {
				// Check if we are adding this for the first time --
				// if we are, we need to create an `add` event.
				var changeType = this.__get().hasOwnProperty(prop) ? &quot;set&quot; : &quot;add&quot;;

				// Set the value on data.
				this.___set(prop,

				// If we are getting an object.
				canMakeObserve(value) ?

				// Hook it up to send event.
				hookupBubble(value, prop, this) :
				// Value is normal.
				value);

				if(changeType == &quot;add&quot;){
					// If there is no current value, let others know that
					// the the number of keys have changed
					
					Observe.triggerBatch(this, &quot;__keys&quot;, undefined);
					
				}
				// `batchTrigger` the change event.
				this._triggerChange(prop, changeType, value, current);
				
				//Observe.triggerBatch(this, prop, [value, current]);
				// If we can stop listening to our old value, do it.
				current &amp;&amp; unhookup([current], this._cid);
			}

		},
		// Directly sets a property on this `object`.
		___set: function( prop, val ) {
			this._data[prop] = val;
			// Add property directly for easy writing.
			// Check if its on the `prototype` so we don&#039;t overwrite methods like `attrs`.
			if (!(prop in this.constructor.prototype)) {
				this[prop] = val
			}
		},

		/**
		 * @function can.Observe.prototype.bind bind
		 * @description Bind event handlers to an Observe.
		 * 
		 * @signature `observe.bind(eventType, handler)`
		 * 
		 * @param {String} eventType the type of event to bind this handler to
		 * @param {Function} handler the handler to be called when this type of event fires
		 * The signature of the handler depends on the type of event being bound. See below
		 * for details.
		 * @return {can.Observe} this Observe, for chaining
		 * 
		 * @body
		 * `bind` binds event handlers to property changes on `can.Observe`s. When you change
		 * a property using `attr`, two events are fired on the Observe, allowing other parts
		 * of your application to observe the changes to the object.
		 *
		 * ## The _change_ event
		 * 
		 * The first event that is fired is the _change_ event. The _change_ event is useful
		 * if you want to react to all changes on an Observe.
		 *
		 * @codestart
		 * var o = new can.Observe({});
		 * o.bind(&#039;change&#039;, function(ev, attr, how, newVal, oldVal) {
		 *     console.log(&#039;Something changed.&#039;);
		 * });
		 * @codeend
		 * 
		 * The parameters of the event handler for the _change_ event are:
		 *
		 * - _ev_ The event object.
		 * - _attr_ Which property changed.
		 * - _how_ Whether the property was added, removed, or set. Possible values are `&#039;add&#039;`, `&#039;remove&#039;`, or `&#039;set&#039;`.
		 * - _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.
		 * - _oldVal_ Thishe value of the property before the change. `oldVal` will be `undefined` if the property was added.
		 * 
		 * Here is a concrete tour through the _change_ event handler&#039;s arguments:
		 * 
		 * @codestart
		 * var o = new can.Observe({});
		 * o.bind(&#039;change&#039;, function(ev, attr, how, newVal, oldVal) {
		 *     console.log(ev + &#039;, &#039; + attr + &#039;, &#039; + how + &#039;, &#039; + newVal + &#039;, &#039; + oldVal);
		 * });
		 * 
		 * o.attr(&#039;a&#039;, &#039;Alexis&#039;); // [object Object], a, add, Alexis, undefined
		 * o.attr(&#039;a&#039;, &#039;Adam&#039;);   // [object Object], a, set, Adam, Alexis
		 * o.attr({
		 *     &#039;a&#039;: &#039;Alice&#039;,      // [object Object], a, set, Alice, Adam
		 *     &#039;b&#039;: &#039;Bob&#039;         // [object Object], b, add, Bob, undefined
		 * });
		 * o.removeAttr(&#039;a&#039;);     // [object Object], a, remove, undefined, Alice
		 * @codeend
		 *
		 * (See also `[can.Observe::removeAttr removeAttr]`, which removes properties).
		 * 
		 * ## The _property name_ event
		 * 
		 * The second event that is fired is an event whose type is the same as the changed
		 * property&#039;s name. This event is useful for noticing changes to a specific property.
		 *
		 * @codestart
		 * var o = new can.Observe({});
		 * o.bind(&#039;a&#039;, function(ev, newVal, oldVal) {
		 *     console.log(&#039;The value of a changed.&#039;);
		 * });
		 * @codeend
		 * 
		 * The parameters of the event handler for the _property name_ event are:
		 *
		 * - _ev_ The event object.
		 * - _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.
		 * - _oldVal_ The value of the property before the change. `oldVal` will be `undefined` if the property was added.
		 * 
		 * Here is a concrete tour through the _property name_ event handler&#039;s arguments:
		 * 
		 * @codestart
		 * var o = new can.Observe({});
		 * o.bind(&#039;a&#039;, function(ev, newVal, oldVal) {
		 *     console.log(ev + &#039;, &#039; + newVal + &#039;, &#039; + oldVal);
		 * });
		 * 
		 * o.attr(&#039;a&#039;, &#039;Alexis&#039;); // [object Object], Alexis, undefined
		 * o.attr(&#039;a&#039;, &#039;Adam&#039;);   // [object Object], Adam, Alexis
		 * o.attr({
		 *     &#039;a&#039;: &#039;Alice&#039;,      // [object Object], Alice, Adam
		 *     &#039;b&#039;: &#039;Bob&#039; 
		 * });
		 * o.removeAttr(&#039;a&#039;);     // [object Object], undefined, Alice
		 * @codeend
		 *
		 * ## See also
		 * 
		 * More information about changing properties on Observes can be found under
		 * [can.Observe.prototype.attr attr].
		 * 
		 * For a more specific way to changes on Observes, see the [can.Observe.delegate] plugin.
		 */
		bind: can.bindAndSetup,
		/**
		 * @function can.Observe.prototype.unbind unbind
		 * @description Unbind event handlers from an Observe.
		 * @signature `observe.unbind(eventType[, handler])`
		 * @param {String} eventType the type of event to unbind, exactly as passed to `bind`
		 * @param {Function} [handler] the handler to unbind
		 *
		 * @body
		 * `unbind` unbinds event handlers previously bound with [can.Observe.prototype.bind `bind`].
		 * If no _handler_ is passed, all handlers for the given event type will be unbound.
		 *
		 * @codestart
		 * var i = 0,
		 *     increaseBy2 = function() { i += 2; },
		 *     increaseBy3 = function() { i += 3; },
		 *     o = new can.Observe();
		 *
		 * o.bind(&#039;change&#039;, increaseBy2);
		 * o.bind(&#039;change&#039;, increaseBy3);
		 * o.attr(&#039;a&#039;, &#039;Alice&#039;);
		 * i; // 5
		 * 
		 * o.unbind(&#039;change&#039;, increaseBy2);
		 * o.attr(&#039;b&#039;, &#039;Bob&#039;);
		 * i; // 8
		 *
		 * o.unbind(&#039;change&#039;);
		 * o.attr(&#039;e&#039;, &#039;Eve&#039;);
		 * i; // 8
		 * @codeend
		 */
		unbind: can.unbindAndTeardown,
		/**
		 * @function can.Observe.prototype.serialize serialize
		 * @description Serialize this object to something that
		 * can be passed to `JSON.stringify`.
		 * @signature `observe.serialize()`
		 * 
		 * 
		 * Get the serialized Object form of the observe.  Serialized
		 * data is typically used to send back to a server.
		 * 
		 *     o.serialize() //-&gt; { name: &#039;Justin&#039; }
		 *     
		 * Serialize currently returns the same data 
		 * as [can.Observe.prototype.attrs].  However, in future
		 * versions, serialize will be able to return serialized
		 * data similar to [can.Model].  The following will work:
		 * 
		 *     new Observe({time: new Date()})
		 *       .serialize() //-&gt; { time: 1319666613663 }
		 * 
		 * @return {Object} a JavaScript Object that can be 
		 * serialized with `JSON.stringify` or other methods. 
		 * 
		 */
		serialize: function() {
			return serialize(this, &#039;serialize&#039;, {});
		},
		/**
		 * @hide
		 * Set multiple properties on the observable
		 * @param {Object} props
		 * @param {Boolean} remove true if you should remove properties that are not in props
		 */
		_attrs: function( props, remove ) {

			if ( props === undefined ) {
				return serialize(this, &#039;attr&#039;, {})
			}

			props = can.extend({}, props);
			var prop,
				self = this,
				newVal;
			Observe.startBatch();
			this.each(function(curVal, prop){
				newVal = props[prop];

				// If we are merging...
				if ( newVal === undefined ) {
					remove &amp;&amp; self.removeAttr(prop);
					return;
				}
				
				if(self.__convert){
					newVal = self.__convert(prop, newVal)
				}

				// if we&#039;re dealing with models, want to call _set to let converter run
				if( newVal instanceof can.Observe ) {
					self.__set(prop, newVal, curVal)
				// if its an object, let attr merge
				} else if ( canMakeObserve(curVal) &amp;&amp; canMakeObserve(newVal) &amp;&amp; curVal.attr ) {
					curVal.attr(newVal, remove)
				// otherwise just set
				} else if ( curVal != newVal ) {
					self.__set(prop, newVal, curVal)
				}

				delete props[prop];
			})
			// Add remaining props.
			for ( var prop in props ) {
				newVal = props[prop];
				this._set(prop, newVal, true)
			}
			Observe.stopBatch()
			return this;
		},

		/**
		 * @function can.Observe.prototype.compute compute
		 * @description Make a can.compute from an observable property.
		 * @signature `observe.compute(attrName)`
		 * @param {String} attrName the property to bind to
		 * @return {can.compute} a [can.compute] bound to _attrName_
		 *
		 * @body
		 * `compute` is a convenience method for making computes from properties
		 * of Observes. More information about computes can be found under [can.compute].
		 *
		 * @codestart
		 * var observe = new can.Observe({a: &#039;Alexis&#039;});
		 * var name = observe.compute(&#039;a&#039;);
		 * name.bind(&#039;change&#039;, function(ev, nevVal, oldVal) {
		 *     console.log(&#039;a changed from &#039; + oldVal + &#039;to&#039; + newName + &#039;.&#039;);
		 * });
		 *
		 * name(); // &#039;Alexis&#039;
		 * 
		 * observe.attr(&#039;a&#039;, &#039;Adam&#039;); // &#039;a changed from Alexis to Adam.&#039;
		 * name(); // &#039;Adam&#039;
		 *
		 * name(&#039;Alice&#039;); // &#039;a changed from Adam to Alice.&#039;
		 * name(); // &#039;Alice&#039;
		 */
		compute: function(prop) {
			return can.compute(this,prop);
		}
	});
	// Helpers for `observable` lists.
	var splice = [].splice,
		/**
		 * @constructor can.Observe.List
		 * @inherits can.Observe
		 * @download can/observe
		 * @test can/observe/qunit.html
		 * @parent canjs
		 * 
		 * Use for observable array-like objects.
		 * 
		 * @signature `new can.Observe.List([array])`
		 * 
		 * Create an observable array-like object.
		 * 
		 * @param {Array} [array] items to seed the List with
		 * @return {can.Observe.List} an instance of `can.Observe.List` with the elements from _array_
		 * 
		 * @signature `can.Observe.List([name,] [staticProperties,] instanceProperties)`
		 * 
		 * Creates a new extended constructor function. 
		 *     
		 * This is deprecated. In CanJS 1.2, by default, calling the constructor function
		 * without `new` will create a `new` instance. Use [can.Construct.extend can.Observe.extend] 
		 * instead of calling the constructor to extend.
		 * 
		 * @body
		 * 
		 * ## Working with Lists
		 *
		 * `can.Observe.List` extends `[can.Observe]`, so all the ways that you&#039;re used to working with
		 * Observes also work here, including [can.Observe.prototype.bind bind], [can.Observe.prototype.unbind unbind],
		 * and [can.Observe.prototype.each each]. And just as you can directly read properties normally
		 * off of an Observe, you can use array accessors ([]) to read elements directly off of a List.
		 *
		 * The one function of `can.Observe` that works slightly differently is `attr`. As expected when working with
		 * arrays, top-level keys passed into `attr` are required to be numeric. (Strings may still be used when getting
		 * or modifying deep properties). Any top-level keys that are non-numeric are ignored. In addition, as might be
		 * expected, a call to argument-less `attr` returns an array instead of an object.
		 *
		 * Just as you shouldn&#039;t set properties of an Observe directly, you shouldn&#039;t change elements
		 * of a List directly. Always use `attr` to set the elements of a List, or use [can.Observe.List.prototype.push push],
		 * [can.Observe.List.prototype.pop pop], [can.Observe.List.prototype.shift shift], [can.Observe.List.prototype.unshift unshift], or [can.Observe.List.prototype.splice splice].
		 *
		 * Here is a tour through the forms of `can.Observe.List`&#039;s `attr` that parallels the one found under [can.Observe.prototype.attr attr]:
		 *
		 * @codestart
		 * var people = new can.Observe.List([&#039;Alex&#039;, &#039;Bill&#039;]);
		 *
		 * // set an element:
		 * people.attr(0, &#039;Adam&#039;);
		 * people[0] = &#039;Adam&#039;; // don&#039;t do this!
		 *
		 * // get an element:
		 * people.attr(0); // &#039;Adam&#039;
		 * people[0]; // &#039;Adam&#039;
		 *
		 * // get all elements:
		 * people.attr(); // [&#039;Adam&#039;, &#039;Bill&#039;]
		 *
		 * // extend the array:
		 * people.attr(4, &#039;Charlie&#039;);
		 * people.attr(); // [&#039;Adam&#039;, &#039;Bill&#039;, undefined, undefined, &#039;Charlie&#039;]
		 *
		 * // merge the elements:
		 * people.attr([&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;]);
		 * people.attr(); // [&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;, undefined, &#039;Charlie&#039;]
		 * @codeend
		 *
		 * ## Listening to changes
		 *
		 * As with `can.Observe`s, the real power of observable arrays comes from being able to
		 * react to changes in the member elements of the array. Lists emit five types of events:
		 * - the _change_ event fires on every change to a List.
		 * - the _set_ event is fired when an element is set.
		 * - the _add_ event is fired when an element is added to the List.
		 * - the _remove_ event is fired when an element is removed from the List.
		 * - the _length_ event is fired when the length of the List changes.
		 *
		 * This example presents a brief concrete survey of the times these events are fired:
		 *
		 * @codestart
		 * var list = new can.Observe.List([&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;]);
		 *
		 * list.bind(&#039;change&#039;, function() { console.log(&#039;An element changed.&#039;); });
		 * list.bind(&#039;set&#039;, function() { console.log(&#039;An element was set.&#039;); });
		 * list.bind(&#039;add&#039;, function() { console.log(&#039;An element was added.&#039;); });
		 * list.bind(&#039;remove&#039;, function() { console.log(&#039;An element was removed.&#039;); });
		 * list.bind(&#039;length&#039;, function() { console.log(&#039;The length of the list changed.&#039;); });
		 *
		 * list.attr(0, &#039;Alexis&#039;); // &#039;An element changed.&#039;
		 *                         // &#039;An element was set.&#039;
		 *
		 * list.attr(3, &#039;Xerxes&#039;); // &#039;An element changed.&#039;
		 *                         // &#039;An element was added.&#039;
		 *                         // &#039;The length of the list was changed.&#039;
		 *
		 * list.attr([&#039;Adam&#039;, &#039;Bill&#039;]); // &#039;An element changed.&#039;
		 *                              // &#039;An element was set.&#039;
		 *                              // &#039;An element was changed.&#039;
		 *                              // &#039;An element was set.&#039;
		 *
		 * list.pop(); // &#039;An element changed.&#039;
		 *             // &#039;An element was removed.&#039;
		 *             // &#039;The length of the list was changed.&#039;
		 * @codeend
		 *
		 * More information about binding to these events can be found under [can.Observe.List.prototype.attr attr].
		 */
			list = Observe(
	/**
	 * @prototype
	 */
	{
		setup: function( instances, options ) {
			this.length = 0;
			can.cid(this, &quot;.observe&quot;)
			this._init = 1;
			if( can.isDeferred(instances) ) {
				this.replace(instances)
			} else {
				this.push.apply(this, can.makeArray(instances || []));
			}
			// this change needs to be ignored
			this.bind(&#039;change&#039;+this._cid,can.proxy(this._changes,this));
			can.extend(this, options);
			delete this._init;
		},
		_triggerChange: function(attr, how, newVal, oldVal){
			
			Observe.prototype._triggerChange.apply(this,arguments)
			// `batchTrigger` direct add and remove events...
			if ( !~ attr.indexOf(&#039;.&#039;)){
				
				if( how === &#039;add&#039; ) {
					Observe.triggerBatch(this, how, [newVal,+attr]);
					Observe.triggerBatch(this,&#039;length&#039;,[this.length]);
				} else if( how === &#039;remove&#039; ) {
					Observe.triggerBatch(this, how, [oldVal, +attr]);
					Observe.triggerBatch(this,&#039;length&#039;,[this.length]);
				} else {
					Observe.triggerBatch(this,how,[newVal, +attr])
				}
				
			}
			
		},
		__get : function(attr){
			return attr ? this[attr] : this;
		},
		___set : function(attr, val){
			this[attr] = val;
			if(+attr &gt;= this.length){
				this.length = (+attr+1)
			}
		},
		_each: function(callback){
			var data = this.__get();
			for(var i =0; i &lt; data.length; i++){
				callback(data[i],i)
			}
		},
		_bindsetup: makeBindSetup(&quot;*&quot;),
		// Returns the serialized form of this list.
		/**
		 * @hide
		 * Returns the serialized form of this list.
		 */
		serialize: function() {
			return serialize(this, &#039;serialize&#039;, []);
		},
		/**
		 * @function can.Observe.List.prototype.each each
		 * @parent can.Observe.List.prototype
		 * @description Call a function on each element of a List.
		 * @signature `list.each( callback(item, index) )`
		 * 
		 * `each` iterates through the Observe, calling a function
		 * for each element.
		 * 
		 * @param {function(*, Number)} callback the function to call for each element
		 * The value and index of each element will be passed as the first and second
		 * arguments, respectively, to the callback. If the callback returns false,
		 * the loop will stop.
		 * 
		 * @return {can.Observe.List} this List, for chaining
		 *
		 * @body
		 * @codestart
		 * var i = 0;
		 * new can.Observe([1, 10, 100]).each(function(element, index) {
		 *     i += element;
		 * });
		 * 
		 * i; // 111
		 * 
		 * i = 0;
		 * new can.Observe([1, 10, 100]).each(function(element, index) {
		 *     i += element;
		 *     if(index &gt;= 1) {
		 *         return false;
		 *     }
		 * });
		 * 
		 * i; // 11
		 * @codeend
		 */
		//  
		/**
		 * @function can.Observe.List.prototype.splice splice
		 * @description Insert and remove elements from a List.
		 * @signature `list.splice(index[, howMany[, ...newElements]])`
		 * @param {Number} index where to start removing or inserting elements
		 * 
		 * @param {Number} [howMany] the number of elements to remove
		 * If _howMany_ is not provided, `splice` will all elements from `index` to the end of the List.
		 *
		 * @param {*} newElements elements to insert into the List
		 *
		 * @return {Array} the elements removed by `splice`
		 *
		 * @body
		 * `splice` lets you remove elements from and insert elements into a List.
		 *
		 * This example demonstrates how to do surgery on a list of numbers:
		 * 
		 * @codestart
		 * var list = new can.Observe.List([0, 1, 2, 3]);
		 *
		 * // starting at index 2, remove one element and insert &#039;Alice&#039; and &#039;Bob&#039;:
		 * list.splice(2, 1, &#039;Alice&#039;, &#039;Bob&#039;);
		 * list.attr(); // [0, 1, &#039;Alice&#039;, &#039;Bob&#039;, 3]
		 * @codeend
		 *
		 * ## Events
		 *
		 * `splice` causes the List it&#039;s called on to emit _change_ events,
		 * _add_ events, _remove_ events, and _length_ events. If there are
		 * any elements to remove, a _change_ event, a _remove_ event, and a
		 * _length_ event will be fired. If there are any elements to insert, a
		 * separate _change_ event, an _add_ event, and a separate _length_ event
		 * will be fired. 
		 *
		 * This slightly-modified version of the above example should help
		 * make it clear how `splice` causes events to be emitted:
		 *
		 * @codestart
		 * var list = new can.Observe.List([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;]);
		 * list.bind(&#039;change&#039;, function(ev, attr, how, newVals, oldVals) {
	     *     console.log(&#039;change: &#039; + attr + &#039;, &#039; + how + &#039;, &#039; + newVals + &#039;, &#039; + oldVals);
		 * });
		 * list.bind(&#039;add&#039;, function(ev, newVals, where) {
	     *     console.log(&#039;add: &#039; + newVals + &#039;, &#039; + where);
		 * });
		 * list.bind(&#039;remove&#039;, function(ev, oldVals, where) {
	     *     console.log(&#039;remove: &#039; + oldVals + &#039;, &#039; + where);
		 * });
		 * list.bind(&#039;length&#039;, function(ev, length) {
	     *     console.log(&#039;length: &#039; + length + &#039;, &#039; + this.attr());
		 * });
		 *
		 * // starting at index 2, remove one element and insert &#039;Alice&#039; and &#039;Bob&#039;:
		 * list.splice(2, 1, &#039;Alice&#039;, &#039;Bob&#039;); // change: 2, &#039;remove&#039;, undefined, [&#039;c&#039;]
		 *                                    // remove: [&#039;c&#039;], 2
		 *                                    // length: 5, [&#039;a&#039;, &#039;b&#039;, &#039;Alice&#039;, &#039;Bob&#039;, &#039;d&#039;]
		 *                                    // change: 2, &#039;add&#039;, [&#039;Alice&#039;, &#039;Bob&#039;], [&#039;c&#039;]
		 *                                    // add: [&#039;Alice&#039;, &#039;Bob&#039;], 2
		 *                                    // length: 5, [&#039;a&#039;, &#039;b&#039;, &#039;Alice&#039;, &#039;Bob&#039;, &#039;d&#039;]
		 * @codeend
		 *
		 * More information about binding to these events can be found under [can.Observe.List.prototype.attr attr].
		 */
		splice: function( index, howMany ) {
			var args = can.makeArray(arguments),
				i;

			for ( i = 2; i &lt; args.length; i++ ) {
				var val = args[i];
				if ( canMakeObserve(val) ) {
					args[i] = hookupBubble(val, &quot;*&quot;, this, this.constructor.Observe, this.constructor)
				}
			}
			if ( howMany === undefined ) {
				howMany = args[1] = this.length - index;
			}
			var removed = splice.apply(this, args);
			can.Observe.startBatch();
			if ( howMany &gt; 0 ) {
				this._triggerChange(&quot;&quot;+index, &quot;remove&quot;, undefined, removed);
				unhookup(removed, this._cid);
			}
			if ( args.length &gt; 2 ) {
				this._triggerChange(&quot;&quot;+index, &quot;add&quot;, args.slice(2), removed);
			}
			can.Observe.stopBatch();
			return removed;
		},
		/**
		 * @function can.Observe.List.prototype.attr attr
		 * @description Get or set elements in a List.
		 * @signature `list.attr()`
		 * 
		 * Gets a collection of all the elements in this `can.Observe.List`.
		 * 
		 * @return {Array} array with all the elements in this List.
		 * 
		 * @body
		 * `attr` gets or sets elements on the `can.Observe.List` it&#039;s called on. Here&#039;s a tour through
		 * how all of its forms work:
		 * 
		 * ## Deep properties
		 * 
		 * `attr` can also set and read deep properties. All you have to do is specify
		 * the property name as you normally would if you weren&#039;t using `attr`.
		 * 
		 * @codestart
		 * var people = new can.Observe.List([{name: &#039;Alex&#039;}, {name: &#039;Bob&#039;}]);
		 * 
		 * // set a property:
		 * people.attr(&#039;0.name&#039;, &#039;Alice&#039;);
		 * 
		 * // get a property:
		 * people.attr(&#039;0.name&#039;);  // &#039;Alice&#039;
		 * people[0].attr(&#039;name&#039;); // &#039;Alice&#039;
		 *
		 * // get all properties:
		 * people.attr(); // [{name: &#039;Alice&#039;}, {name: &#039;Bob&#039;}]
		 * @codeend
		 *
		 * The discussion of deep properties under `[can.Observe.prototype.attr attr]` may also
		 * be enlightening.
		 *
		 * ## Events
		 *
		 * `can.Observe.List`s emit five types of events in response to changes. They are:
		 * - the _change_ event fires on every change to a List.
		 * - the _set_ event is fired when an element is set.
		 * - the _add_ event is fired when an element is added to the List.
		 * - the _remove_ event is fired when an element is removed from the List.
		 * - the _length_ event is fired when the length of the List changes.
		 *
		 * ## The _change_ event
		 * 
		 * The first event that is fired is the _change_ event. The _change_ event is useful
		 * if you want to react to all changes on an List.
		 *
		 * @codestart
		 * var list = new can.Observe.List([]);
		 * list.bind(&#039;change&#039;, function(ev, index, how, newVal, oldVal) {
		 *     console.log(&#039;Something changed.&#039;);
		 * });
		 * @codeend
		 * 
		 * The parameters of the event handler for the _change_ event are:
		 *
		 * - _ev_ The event object.
		 * - _index_ Where the change took place.
		 * - _how_ Whether elements were added, removed, or set.
		 * Possible values are `&#039;add&#039;`, `&#039;remove&#039;`, or `&#039;set&#039;`.
		 * - _newVal_ The elements affected after the change
		 *  _newVal_ will be a single value when an index is set, an Array when elements
		 * were added, and `undefined` if elements were removed.
		 * - _oldVal_ The elements affected before the change.
		 * _newVal_ will be a single value when an index is set, an Array when elements
		 * were removed, and `undefined` if elements were added.
		 * 
		 * Here is a concrete tour through the _change_ event handler&#039;s arguments:
		 * 
		 * @codestart
		 * var list = new can.Observe.List();
		 * list.bind(&#039;change&#039;, function(ev, index, how, newVal, oldVal) {
		 *     console.log(ev + &#039;, &#039; + index + &#039;, &#039; + how + &#039;, &#039; + newVal + &#039;, &#039; + oldVal);
		 * });
		 * 
		 * list.attr([&#039;Alexis&#039;, &#039;Bill&#039;]); // [object Object], 0, add, [&#039;Alexis&#039;, &#039;Bill&#039;], undefined
		 * list.attr(2, &#039;Eve&#039;);           // [object Object], 2, add, Eve, undefined
		 * list.attr(0, &#039;Adam&#039;);          // [object Object], 0, set, Adam, Alexis
		 * list.attr([&#039;Alice&#039;, &#039;Bob&#039;]);   // [object Object], 0, set, Alice, Adam
		 *                                // [object Object], 1, set, Bob, Bill
		 * list.removeAttr(1);            // [object Object], 1, remove, undefined, Bob
		 * @codeend
		 *
		 * ## The _set_ event
		 * 
		 * _set_ events are fired when an element at an index that already exists in the List is
		 * modified. Actions can cause _set_ events to fire never also cause _length_ events
		 * to fire (although some functions, such as `[can.Observe.List.prototype.splice splice]`
		 * may cause unrelated sets of events to fire after being batched).
		 * 
		 * The parameters of the event handler for the _set_ event are:
		 *
		 * - _ev_ The event object.
		 * - _newVal_ The new value of the element.
		 * - _index_ where the set took place.
		 *
		 * Here is a concrete tour through the _set_ event handler&#039;s arguments:
		 * 
		 * @codestart
		 * var list = new can.Observe.List();
		 * list.bind(&#039;set&#039;, function(ev, newVal, index) {
		 *     console.log(newVal + &#039;, &#039; + index);
		 * });
		 * 
		 * list.attr([&#039;Alexis&#039;, &#039;Bill&#039;]);
		 * list.attr(2, &#039;Eve&#039;);          
		 * list.attr(0, &#039;Adam&#039;);          // Adam, 0
		 * list.attr([&#039;Alice&#039;, &#039;Bob&#039;]);   // Alice, 0
		 *                                // Bob, 1
		 * list.removeAttr(1);            
		 * @codeend
		 *
		 * ## The _add_ event
		 * 
		 * _add_ events are fired when elements are added or inserted
		 * into the List.
		 * 
		 * The parameters of the event handler for the _add_ event are:
		 *
		 * - _ev_ The event object.
		 * - _newElements_ The new elements.
		 * If more than one element is added, _newElements_ will be an array.
		 * Otherwise, it is simply the new element itself.
		 * - _index_ Where the add or insert took place.
		 *
		 * Here is a concrete tour through the _add_ event handler&#039;s arguments:
		 * 
		 * @codestart
		 * var list = new can.Observe.List();
		 * list.bind(&#039;add&#039;, function(ev, newElements, index) {
		 *     console.log(newElements + &#039;, &#039; + index);
		 * });
		 * 
		 * list.attr([&#039;Alexis&#039;, &#039;Bill&#039;]); // [&#039;Alexis&#039;, &#039;Bill&#039;], 0
		 * list.attr(2, &#039;Eve&#039;);           // Eve, 2
		 * list.attr(0, &#039;Adam&#039;);          
		 * list.attr([&#039;Alice&#039;, &#039;Bob&#039;]);   
		 *                                
		 * list.removeAttr(1);            
		 * @codeend
		 *
		 * ## The _remove_ event
		 * 
		 * _remove_ events are fired when elements are removed from the list.
		 * 
		 * The parameters of the event handler for the _remove_ event are:
		 *
		 * - _ev_ The event object.
		 * - _removedElements_ The removed elements.
		 * If more than one element was removed, _removedElements_ will be an array.
		 * Otherwise, it is simply the element itself.
		 * - _index_ Where the removal took place.
		 *
		 * Here is a concrete tour through the _remove_ event handler&#039;s arguments:
		 * 
		 * @codestart
		 * var list = new can.Observe.List();
		 * list.bind(&#039;remove&#039;, function(ev, removedElements, index) {
		 *     console.log(removedElements + &#039;, &#039; + index);
		 * });
		 * 
		 * list.attr([&#039;Alexis&#039;, &#039;Bill&#039;]); 
		 * list.attr(2, &#039;Eve&#039;);           
		 * list.attr(0, &#039;Adam&#039;);          
		 * list.attr([&#039;Alice&#039;, &#039;Bob&#039;]);   
		 *                                
		 * list.removeAttr(1);            // Bob, 1
		 * @codeend
		 *
		 * ## The _length_ event
		 * 
		 * _length_ events are fired whenever the list changes.
		 * 
		 * The parameters of the event handler for the _length_ event are:
		 *
		 * - _ev_ The event object.
		 * - _length_ The current length of the list.
		 *
		 * If events were batched when the _length_ event was triggered, _length_
		 * will have the length of the list when `stopBatch` was called. Because
		 * of this, you may recieve multiple _length_ events with the same
		 * _length_ parameter.
		 * 
		 * Here is a concrete tour through the _length_ event handler&#039;s arguments:
		 * 
		 * @codestart
		 * var list = new can.Observe.List();
		 * list.bind(&#039;length&#039;, function(ev, length) {
		 *     console.log(length);
		 * });
		 * 
		 * list.attr([&#039;Alexis&#039;, &#039;Bill&#039;]); // 2
		 * list.attr(2, &#039;Eve&#039;);           // 3
		 * list.attr(0, &#039;Adam&#039;);          
		 * list.attr([&#039;Alice&#039;, &#039;Bob&#039;]);   
		 *                                
		 * list.removeAttr(1);            // 2
		 * @codeend
		 */
		_attrs: function( items, remove ) {
			if ( items === undefined ) {
				return serialize(this, &#039;attr&#039;, []);
			}

			// Create a copy.
			items = can.makeArray( items );

      		Observe.startBatch();
			this._updateAttrs(items, remove);
			Observe.stopBatch()
		},

	    _updateAttrs : function( items, remove ){
	      var len = Math.min(items.length, this.length);
	
	      for ( var prop = 0; prop &lt; len; prop++ ) {
	        var curVal = this[prop],
	          newVal = items[prop];
	
	        if ( canMakeObserve(curVal) &amp;&amp; canMakeObserve(newVal) ) {
	          curVal.attr(newVal, remove)
	        } else if ( curVal != newVal ) {
	          this._set(prop, newVal)
	        } else {
	
	        }
	      }
	      if ( items.length &gt; this.length ) {
	        // Add in the remaining props.
	        this.push.apply( this, items.slice( this.length ) );
	      } else if ( items.length &lt; this.length &amp;&amp; remove ) {
	        this.splice(items.length)
	      }
	    }
	}),


		// Converts to an `array` of arguments.
		getArgs = function( args ) {
			return args[0] &amp;&amp; can.isArray(args[0]) ?
				args[0] :
				can.makeArray(args);
		};
	// Create `push`, `pop`, `shift`, and `unshift`
	can.each({
		/**
		 * @function can.Observe.List.prototype.push push
		 * @description Add elements to the end of a list.
		 * @signature `list.push(...elements)`
		 *
		 * `push` adds elements onto the end of a List.]
		 * 
		 * @param {*} elements the elements to add to the List
		 *
		 * @return {Number} the new length of the List
		 *
		 * @body
		 * `push` is fairly straightforward:
		 *
		 * @codestart
		 * var list = new can.Observe.List([&#039;Alice&#039;]);
		 *
		 * list.push(&#039;Bob&#039;, &#039;Eve&#039;);
		 * list.attr(); // [&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;]
		 * @codeend
		 *
		 * If you have an array you want to concatenate to the end
		 * of the List, you can use `apply`:
		 *
		 * @codestart
		 * var names = [&#039;Bob&#039;, &#039;Eve&#039;],
		 *     list = new can.Observe.List([&#039;Alice&#039;]);
		 *
		 * list.push.apply(list, names);
		 * list.attr(); // [&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;]
		 * @codeend
		 *
		 * ## Events
		 *
		 * `push` causes _change_, _add_, and _length_ events to be fired.
		 *
		 * ## See also
		 *
		 * `push` has a counterpart in [can.Observe.List.prototype.pop pop], or you may be
		 * looking for [can.Observe.List.prototype.unshift unshift] and its counterpart [can.Observe.List.prototype.shift shift].
		 */
		push: &quot;length&quot;,
		/**
		 * @function can.Observe.List.prototype.unshift unshift
		 * @description Add elements to the beginning of a List.
		 * @signature `list.unshift(...elements)`
		 *
		 * `unshift` adds elements onto the beginning of a List.
		 * 
		 * @param {*} elements the elements to add to the List
		 *
		 * @return {Number} the new length of the List
		 *
		 * @body
		 * `unshift` adds elements to the front of the list in bulk in the order specified:
		 *
		 * @codestart
		 * var list = new can.Observe.List([&#039;Alice&#039;]);
		 *
		 * list.unshift(&#039;Bob&#039;, &#039;Eve&#039;);
		 * list.attr(); // [&#039;Bob&#039;, &#039;Eve&#039;, &#039;Alice&#039;]
		 * @codeend
		 *
		 * If you have an array you want to concatenate to the beginning
		 * of the List, you can use `apply`:
		 *
		 * @codestart
		 * var names = [&#039;Bob&#039;, &#039;Eve&#039;],
		 *     list = new can.Observe.List([&#039;Alice&#039;]);
		 *
		 * list.push.apply(list, names);
		 * list.attr(); // [&#039;Bob&#039;, &#039;Eve&#039;, &#039;Alice&#039;]
		 * @codeend
		 *
		 * ## Events
		 *
		 * `unshift` causes _change_, _add_, and _length_ events to be fired.
		 *
		 * ## See also
		 *
		 * `unshift` has a counterpart in [can.Observe.List.prototype.shift shift], or you may be
		 * looking for [can.Observe.List.prototype.push push] and its counterpart [can.Observe.List.prototype.pop pop].
		 */
		unshift: 0
	},
	// Adds a method
	// `name` - The method name.
	// `where` - Where items in the `array` should be added.
	function( where, name ) {
		var orig = [][name]
		list.prototype[name] = function() {
			// Get the items being added.
			var args = [],
				// Where we are going to add items.
				len = where ? this.length : 0,
				i = arguments.length,
				res,
				val,
				constructor = this.constructor;

			// Go through and convert anything to an `observe` that needs to be converted.
			while(i--){
				val = arguments[i];
				args[i] =  canMakeObserve(val) ?
					hookupBubble(val, &quot;*&quot;, this, this.constructor.Observe, this.constructor) :
					val;
			}
			
			// Call the original method.
			res = orig.apply(this, args);

			if ( !this.comparator || args.length ) {

				this._triggerChange(&quot;&quot;+len, &quot;add&quot;, args, undefined);
			}
						
			return res;
		}
	});

	can.each({
		/**
		 * @function can.Observe.List.prototype.pop pop
		 * @description Remove an element from the end of a List.
		 * @signature `list.pop()`
		 *
		 * `push` removes an element from the end of a List.
		 * 
		 * @return {*} the element just popped off the List, or `undefined` if the List was empty
		 *
		 * @body
		 * `pop` is the opposite action from `[can.Observe.List.prototype.push push]`:
		 *
		 * @codestart
		 * var list = new can.Observe.List([&#039;Alice&#039;]);
		 *
		 * list.push(&#039;Bob&#039;, &#039;Eve&#039;);
		 * list.attr(); // [&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;]
		 * 
		 * list.pop(); // &#039;Eve&#039;
		 * list.pop(); // &#039;Bob&#039;
		 * list.pop(); // &#039;Alice&#039;
		 * list.pop(); // undefined
		 * @codeend
		 *
		 * ## Events
		 *
		 * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty
		 * when it is called.
		 *
		 * ## See also
		 *
		 * `pop` has its counterpart in [can.Observe.List.prototype.push push], or you may be
		 * looking for [can.Observe.List.prototype.unshift unshift] and its counterpart [can.Observe.List.prototype.shift shift].
		 */
		pop: &quot;length&quot;,
		/**
		 * @function can.Observe.List.prototype.shift shift
		 * @description Remove en element from the front of a list.
		 * @signature `list.shift()`
		 *
		 * `shift` removes an element from the beginning of a List.
		 *
		 * @return {*} the element just shifted off the List, or `undefined` if the List is empty
		 *
		 * @body
		 * `shift` is the opposite action from `[can.Observe.List.unshift unshift]`:
		 *
		 * @codestart
		 * var list = new can.Observe.List([&#039;Alice&#039;]);
		 *
		 * list.unshift(&#039;Bob&#039;, &#039;Eve&#039;);
		 * list.attr(); // [&#039;Bob&#039;, &#039;Eve&#039;, &#039;Alice&#039;]
		 *
		 * list.shift(); // &#039;Bob&#039;
		 * list.shift(); // &#039;Eve&#039;
		 * list.shift(); // &#039;Alice&#039;
		 * list.shift(); // undefined
		 * @codeend
		 *
		 * ## Events
		 *
		 * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty
		 * when it is called.
		 *
		 * ## See also
		 *
		 * `shift` has a counterpart in [can.Observe.List.prototype.unshift unshift], or you may be
		 * looking for [can.Observe.List.prototype.push push] and its counterpart [can.Observe.List.prototype.pop pop].
		 */
		shift: 0
	},
	// Creates a `remove` type method
	function( where, name ) {
		list.prototype[name] = function() {
			
			var args = getArgs(arguments),
				len = where &amp;&amp; this.length ? this.length - 1 : 0;


			var res = [][name].apply(this, args)

			// Create a change where the args are
			// `len` - Where these items were removed.
			// `remove` - Items removed.
			// `undefined` - The new values (there are none).
			// `res` - The old, removed values (should these be unbound).
			this._triggerChange(&quot;&quot;+len, &quot;remove&quot;, undefined, [res])

			if ( res &amp;&amp; res.unbind ) {
				res.unbind(&quot;change&quot; + this._cid)
			}
			return res;
		}
	});
	
	can.extend(list.prototype, {
		/**
		 * @function can.Observe.List.prototype.indexOf indexOf
		 * @description Look for an item in a List.
		 * @signature `list.indexOf(item)`
		 *
		 * `indexOf` finds the position of a given item in the List.
		 *
		 * @param {*} item the item to find
		 *
		 * @return {Number} the position of the item in the List, or -1 if the item is not found.
		 *
		 * @body
		 * @codestart
		 * var list = new can.Observe.List([&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;]);
		 * list.indexOf(&#039;Alice&#039;);   // 0
		 * list.indexOf(&#039;Charlie&#039;); // -1
		 * @codeend
		 *
		 * It is trivial to make a `contains`-type function using `indexOf`:
		 *
		 * @codestart
		 * function(list, item) {
		 *     return list.indexOf(item) &gt;= 0;
		 * }
		 * @codeend
		 */
		indexOf: function(item) {
			this.attr(&#039;length&#039;)
			return can.inArray(item, this)
		},

		/**
		 * @function can.Observe.List.prototype.join join
		 * @description Join a List&#039;s elements into a string.
		 * @signature `list.join(separator)`
		 *
		 * `join` turns a List into a string by inserting _separator_ between the string representations
		 * of all the elements of the List.
		 *
		 * @param {String} separator the string to seperate elements with
		 *
		 * @return {String} the joined string
		 *
		 * @body
		 * @codestart
		 * var list = new can.Observe.List([&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;]);
		 * list.join(&#039;, &#039;); // &#039;Alice, Bob, Eve&#039;
		 *
		 * var beatles = new can.Observe.List([&#039;John&#039;, &#039;Paul&#039;, &#039;Ringo&#039;, &#039;George&#039;]);
		 * beatles.join(&#039;&amp;&#039;); // &#039;John&amp;Paul&amp;Ringo&amp;George&#039;
		 * @codeend
		 */
		join : [].join,
		
		/**
		 * @function can.Observe.List.prototype.reverse reverse
		 * @description Reverse the order of a List.
		 * @signature `list.reverse()`
		 *
		 * `reverse` reverses the elements of the List in place.
		 *
		 * @return {can.Observe.List} the List, for chaining
		 *
		 * @body
		 * @codestart
		 * var list = new can.Observe.List([&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;]);
		 * var reversedList = list.reverse();
		 *
		 * reversedList.attr(); // [&#039;Eve&#039;, &#039;Bob&#039;, &#039;Alice&#039;];
		 * list === reversedList; // true
		 * @codeend
		 */
		reverse: [].reverse,

		/**
		 * @function can.Observe.List.prototype.slice slice
		 * @description Make a copy of a part of a List.
		 * @signature `list.slice([start[, end]])`
		 *
		 * `slice` creates a copy of a portion of the List.
		 *
		 * @param {Number} [start=0] the index to start copying from
		 *
		 * @param {Number} [end] the first index not to include in the copy
		 * If _end_ is not supplied, `slice` will copy until the end of the list.
		 *
		 * @return {can.Observe.List} a new `can.Observe.List` with the extracted elements
		 *
		 * @body
		 * @codestart
		 * var list = new can.Observe.List([&#039;Alice&#039;, &#039;Bob&#039;, &#039;Charlie&#039;, &#039;Daniel&#039;, &#039;Eve&#039;]);
		 * var newList = list.slice(1, 4);
		 * newList.attr(); // [&#039;Bob&#039;, &#039;Charlie&#039;, &#039;Daniel&#039;]
		 * @codeend
		 *
		 * `slice` is the simplest way to copy a List:
		 * 
		 * @codestart
		 * var list = new can.Observe.List([&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;]);
		 * var copy = list.slice();
		 *
		 * copy.attr();   // [&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;]
		 * list === copy; // false
		 * @codeend
		 */
		slice : function() {
			var temp = Array.prototype.slice.apply(this, arguments);
			return new this.constructor( temp );
		},

		/**
		 * @function can.Observe.List.prototype.concat concat
		 * @description Merge many collections together into a List.
		 * @signature `list.concat(...args)`
		 * @param {Array|can.Observe.List|*} args Any number of arrays, Lists, or values to add in
		 * For each parameter given, if it is an Array or a List, each of its elements will be added to
		 * the end of the concatenated List. Otherwise, the parameter itself will be added.
		 *
		 * @body
		 * `concat` makes a new List with the elements of the List followed by the elements of the parameters.
		 *
		 * @codestart
		 * var list = new can.Observe.List();
		 * var newList = list.concat(
		 *     &#039;Alice&#039;,
		 *     [&#039;Bob&#039;, &#039;Charlie&#039;]),
		 *     new can.Observe.List([&#039;Daniel&#039;, &#039;Eve&#039;]),
		 *     {f: &#039;Francis&#039;}
		 * );
		 * newList.attr(); // [&#039;Alice&#039;, &#039;Bob&#039;, &#039;Charlie&#039;, &#039;Daniel&#039;, &#039;Eve&#039;, {f: &#039;Francis&#039;}]
		 * @codeend
		 */
		concat : function() {
			var args = [];
			can.each( can.makeArray( arguments ), function( arg, i ) {
				args[i] = arg instanceof can.Observe.List ? arg.serialize() : arg ;
			});
			return new this.constructor(Array.prototype.concat.apply(this.serialize(), args));
		},

		/**
		 * @function can.Observe.List.prototype.forEach forEach
		 * @description Call a function for each element of a List.
		 * @signature `list.forEach(callback[, thisArg])`
		 * @param {function(element, index, list)} callback a function to call with each element of the List
		 * The three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the
		 * current element of the list, and _list_ the List the elements are coming from.
		 * @param {Object} [thisArg] the object to use as `this` inside the callback
		 *
		 * @body
		 * `forEach` calls a callback for each element in the List.
		 *
		 * @codestart
		 * var list = new can.Observe.List([1, 2, 3]);
		 * list.forEach(function(element, index, list) {
		 *     list.attr(index, element * element);
		 * });
		 * list.attr(); // [1, 4, 9]
		 * @codeend
		 */
		forEach : function( cb, thisarg ) {
			can.each(this, cb, thisarg || this );
		},

		/**
		 * @function can.Observe.List.prototype.replace replace
		 * @description Replace all the elements of a List.
		 * @signature `list.replace(collection)`
		 * @param {Array|can.Observe.List|can.Deferred} collection the collection of new elements to use
		 * If a [can.Deferred] is passed, it must resolve to an `Array` or `can.Observe.List`.
		 * The elements of the list are not actually removed until the Deferred resolves.
		 *
		 * @body
		 * `replace` replaces all the elements of this List with new ones.
		 *
		 * `replace` is especially useful when `can.Observe.List`s are live-bound into `[can.Control]`s,
		 * and you intend to populate them with the results of a `[can.Model]` call:
		 *
		 * @codestart
		 * can.Control({
		 *     init: function() {
		 *         this.list = new Todo.List();
		 *         // live-bind the list into the DOM
		 *         this.element.html(can.view(&#039;list.mustache&#039;, this.list));
		 *         // when this AJAX call returns, the live-bound DOM will be updated
		 *         this.list.replace(Todo.findAll());
		 *     }
		 * });
		 * @codeend
		 *
		 * Learn more about [can.Model.List making Lists of models].
		 *
		 * ## Events
		 * 
		 * A major difference between `replace` and `attr(newElements, true)` is that `replace` always emits
		 * an_add_ event and a _remove_ event, whereas `attr` will cause _set_ events along an _add_ or _remove_
		 * event if needed. Corresponding _change_ and _length_ events will be fired as well.
		 *
		 * The differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:
		 * @codestart
		 * var attrList = new can.Observe.List([&#039;Alexis&#039;, &#039;Bill&#039;]);
		 * attrList.bind(&#039;change&#039;, function(ev, index, how, newVals, oldVals) {
		 *     console.log(index + &#039;, &#039; + how + &#039;, &#039; + newVals + &#039;, &#039; + oldVals);
		 * });
		 * 
		 * var replaceList = new can.Observe.List([&#039;Alexis&#039;, &#039;Bill&#039;]);
		 * replaceList.bind(&#039;change&#039;, function(ev, index, how, newVals, oldVals) {
		 *     console.log(index + &#039;, &#039; + how + &#039;, &#039; + newVals + &#039;, &#039; + oldVals);
		 * });
		 * 
		 * attrList.attr([&#039;Adam&#039;, &#039;Ben&#039;], true);         // 0, set, Adam, Alexis
		 *                                               // 1, set, Ben, Bill
		 * replaceList.replace([&#039;Adam&#039;, &#039;Ben&#039;]);         // 0, remove, undefined, [&#039;Alexis&#039;, &#039;Bill&#039;]
		 *                                               // 0, add, undefined, [&#039;Adam&#039;, &#039;Ben&#039;]
		 * 
		 * attrList.attr([&#039;Amber&#039;], true);               // 0, set, Amber, Adam
		 *                                               // 1, remove, undefined, Ben
		 * replaceList.replace([&#039;Amber&#039;]);               // 0, remove, undefined, [&#039;Adam&#039;, &#039;Ben&#039;]
		 *                                               // 0, add, Amber, [&#039;Adam&#039;, &#039;Ben&#039;]
		 * 
		 * attrList.attr([&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;], true); // 0, set, Alice, Amber
		 *                                               // 1, add, [&#039;Bob&#039;, &#039;Eve&#039;], undefined
		 * replaceList.replace([&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;]); // 0, remove, undefined, Amber
		 *                                               // 0, add, [&#039;Alice&#039;, &#039;Bob&#039;, &#039;Eve&#039;], Amber
		 * @codeend
		 */
		replace : function(newList) {
			if(can.isDeferred(newList)) {
				newList.then(can.proxy(this.replace, this));
			} else {
				this.splice.apply(this, [0, this.length].concat(can.makeArray(newList || [])));
			}

			return this;
		}
	});

	can.List = Observe.List = list;
	Observe.setup = function(){
		can.Construct.setup.apply(this, arguments);
		// I would prefer not to do it this way. It should
		// be using the attributes plugin to do this type of conversion.
		this.List = Observe.List({ Observe : this }, {});
	}
	return Observe;
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>

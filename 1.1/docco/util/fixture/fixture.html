<!DOCTYPE html>

<html>
<head>
  <title>fixture.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>fixture.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>steal(<span class="hljs-string">'can/util'</span>,<span class="hljs-string">'can/util/string'</span>,<span class="hljs-string">'can/util/object'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(can)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Get the URL from old Steal root, new Steal config or can.fixture.rootUrl</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> getUrl = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(url)</span> </span>{
		<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> steal !== <span class="hljs-string">'undefined'</span>) {
			<span class="hljs-keyword">if</span>(can.isFunction(steal.config)) {
				<span class="hljs-keyword">return</span> steal.config().root.mapJoin(url).toString();
			}
			<span class="hljs-keyword">return</span> steal.root.join(url).toString();
		}
		<span class="hljs-keyword">return</span> (can.fixture.rootUrl || <span class="hljs-string">''</span>) + url;
	}

	<span class="hljs-keyword">var</span> updateSettings = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(settings, originalOptions)</span> </span>{
			<span class="hljs-keyword">if</span> (!can.fixture.on) {
				<span class="hljs-keyword">return</span>;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>simple wrapper for logging</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> _logger = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(type, arr)</span></span>{
				<span class="hljs-keyword">if</span>(<span class="hljs-built_in">console</span>.log.apply){
					<span class="hljs-built_in">Function</span>.prototype.call.apply(<span class="hljs-built_in">console</span>[type], [<span class="hljs-built_in">console</span>].concat(arr));</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>console[type].apply(console, arr)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				} <span class="hljs-keyword">else</span> {
					<span class="hljs-built_in">console</span>[type](arr)
				}
			},
			log = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
				<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> steal !== <span class="hljs-string">'undefined'</span> &amp;&amp; steal.dev) {
					steal.dev.log(<span class="hljs-string">'fixture INFO: '</span> + <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>).join(<span class="hljs-string">' '</span>));
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>We always need the type which can also be called method, default to GET</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			settings.type = settings.type || settings.method || <span class="hljs-string">'GET'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>add the fixture option if programmed in</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> data = overwrite(settings);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>if we don’t have a fixture, do nothing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!settings.fixture) {
				<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.location.protocol === <span class="hljs-string">"file:"</span>) {
					log(<span class="hljs-string">"ajax request to "</span> + settings.url + <span class="hljs-string">", no fixture found"</span>);
				}
				<span class="hljs-keyword">return</span>;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>if referencing something else, update the fixture option</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> settings.fixture === <span class="hljs-string">"string"</span> &amp;&amp; can.fixture[settings.fixture]) {
				settings.fixture = can.fixture[settings.fixture];
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>if a string, we just point to the right url</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> settings.fixture == <span class="hljs-string">"string"</span>) {
				<span class="hljs-keyword">var</span> url = settings.fixture;

				<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\/\//</span>.test(url)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>this lets us use rootUrl w/o having steal…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					url = getUrl(settings.fixture.substr(<span class="hljs-number">2</span>));
				}

				<span class="hljs-keyword">if</span>(data) {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Template static fixture URLs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					url = can.sub(url, data);
				}

				<span class="hljs-keyword">delete</span> settings.fixture;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>!steal-remove-start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				log(<span class="hljs-string">"looking for fixture in "</span> + url);</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>!steal-remove-end</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
				settings.url = url;
				settings.data = <span class="hljs-literal">null</span>;
				settings.type = <span class="hljs-string">"GET"</span>;
				<span class="hljs-keyword">if</span> (!settings.error) {
					settings.error = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(xhr, error, message)</span> </span>{
						<span class="hljs-keyword">throw</span> <span class="hljs-string">"fixtures.js Error "</span> + error + <span class="hljs-string">" "</span> + message;
					};
				}
			}
			<span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>!steal-remove-start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				log(<span class="hljs-string">"using a dynamic fixture for "</span> + settings.type + <span class="hljs-string">" "</span> + settings.url);</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>!steal-remove-end</p>

            </div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>it’s a function … add the fixture datatype so our fixture transport handles it
TODO: make everything go here for timing and other fun stuff
add to settings data from fixture …</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				settings.dataTypes &amp;&amp; settings.dataTypes.splice(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"fixture"</span>);

				<span class="hljs-keyword">if</span> (data &amp;&amp; originalOptions) {
					can.extend(originalOptions.data, data)
				}
			}
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>A helper function that takes what’s called with response
and moves some common args around to make it easier to call</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		extractResponse = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(status, statusText, responses, headers)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>if we get response(RESPONSES, HEADERS)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> status != <span class="hljs-string">"number"</span>){
				headers = statusText;
				responses = status;
				statusText = <span class="hljs-string">"success"</span>
				status = <span class="hljs-number">200</span>;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>if we get response(200, RESPONSES, HEADERS)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> statusText != <span class="hljs-string">"string"</span>){
				headers = responses;
				responses = statusText;
				statusText = <span class="hljs-string">"success"</span>;
			}
			<span class="hljs-keyword">if</span> ( status &gt;= <span class="hljs-number">400</span> &amp;&amp; status &lt;= <span class="hljs-number">599</span> ) {
				<span class="hljs-keyword">this</span>.dataType = <span class="hljs-string">"text"</span>
			}
			<span class="hljs-keyword">return</span> [status, statusText, extractResponses(<span class="hljs-keyword">this</span>, responses), headers];
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>If we get data instead of responses,
make sure we provide a response type that matches the first datatype (typically json)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		extractResponses = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(settings, responses)</span></span>{
			<span class="hljs-keyword">var</span> next = settings.dataTypes ? settings.dataTypes[<span class="hljs-number">0</span>] : (settings.dataType || <span class="hljs-string">'json'</span>);
			<span class="hljs-keyword">if</span> (!responses || !responses[next]) {
				<span class="hljs-keyword">var</span> tmp = {}
				tmp[next] = responses;
				responses = tmp;
			}
			<span class="hljs-keyword">return</span> responses;
		};</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>used to check urls
check if jQuery</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (can.ajaxPrefilter &amp;&amp; can.ajaxTransport) {</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>the pre-filter needs to re-route the url</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		can.ajaxPrefilter(updateSettings);

		can.ajaxTransport(<span class="hljs-string">"fixture"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(s, original)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>remove the fixture from the datatype</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			s.dataTypes.shift();</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>we’ll return the result of the next data type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> timeout, stopped = <span class="hljs-literal">false</span>;

			<span class="hljs-keyword">return</span> {
				send: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(headers, callback)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>we’ll immediately wait the delay time for all fixtures</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					timeout = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>if the user wants to call success on their own, we allow it …</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> success = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
							<span class="hljs-keyword">if</span>(stopped === <span class="hljs-literal">false</span>) {
								callback.apply(<span class="hljs-literal">null</span>, extractResponse.apply(s, <span class="hljs-built_in">arguments</span>) );
							}
						},</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>get the result form the fixture</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						result = s.fixture(original, success, headers, s);
						<span class="hljs-keyword">if</span>(result !== <span class="hljs-literal">undefined</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>make sure the result has the right dataType</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							callback(<span class="hljs-number">200</span>, <span class="hljs-string">"success"</span>, extractResponses(s, result), {});
						}
					}, can.fixture.delay);
				},
				abort: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
					stopped = <span class="hljs-literal">true</span>;
					clearTimeout(timeout)
				}
			};
		});
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">var</span> AJAX = can.ajax;
		can.ajax = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(settings)</span> </span>{
			updateSettings(settings, settings);
			<span class="hljs-keyword">if</span> (settings.fixture) {
				<span class="hljs-keyword">var</span> timeout, d = <span class="hljs-keyword">new</span> can.Deferred(),
					stopped = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>TODO this should work with response</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				d.getResponseHeader = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>call success and fail</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				d.then(settings.success, settings.fail);</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>abort should stop the timeout and calling success</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				d.abort = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
					clearTimeout(timeout);
					stopped = <span class="hljs-literal">true</span>;
					d.reject(d)
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>set a timeout that simulates making a request ….</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				timeout = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>if the user wants to call success on their own, we allow it …</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> success = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
						<span class="hljs-keyword">var</span> response = extractResponse.apply(settings, <span class="hljs-built_in">arguments</span>),
							status = response[<span class="hljs-number">0</span>];

						<span class="hljs-keyword">if</span> ( (status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span> || status === <span class="hljs-number">304</span>) &amp;&amp; stopped === <span class="hljs-literal">false</span>) {
							d.resolve(response[<span class="hljs-number">2</span>][settings.dataType])
						} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>TODO probably resolve better</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							d.reject(d, <span class="hljs-string">'error'</span>, response[<span class="hljs-number">1</span>]);
						}
					},</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>get the result form the fixture</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					result = settings.fixture(settings, success, settings.headers, settings);
					<span class="hljs-keyword">if</span>(result !== <span class="hljs-literal">undefined</span>) {
						d.resolve(result)
					}
				}, can.fixture.delay);
				
				<span class="hljs-keyword">return</span> d;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> AJAX(settings);
			}
		}
	}

	<span class="hljs-keyword">var</span> typeTest = <span class="hljs-regexp">/^(script|json|text|jsonp)$/</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>a list of ‘overwrite’ settings object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		overwrites = [],</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>returns the index of an overwrite function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		find = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(settings, exact)</span> </span>{
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; overwrites.length; i++) {
				<span class="hljs-keyword">if</span> ($fixture._similar(settings, overwrites[i], exact)) {
					<span class="hljs-keyword">return</span> i;
				}
			}
			<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>overwrites the settings fixture if an overwrite matches</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		overwrite = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(settings)</span> </span>{
			<span class="hljs-keyword">var</span> index = find(settings);
			<span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) {
				settings.fixture = overwrites[index].fixture;
				<span class="hljs-keyword">return</span> $fixture._getData(overwrites[index].url, settings.url)
			}

		},</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Makes an attempt to guess where the id is at in the url and returns it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		getId = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(settings)</span> </span>{
			<span class="hljs-keyword">var</span> id = settings.data.id;

			<span class="hljs-keyword">if</span> (id === <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">typeof</span> settings.data === <span class="hljs-string">"number"</span>) {
				id = settings.data;
			}

			<span class="hljs-comment">/*
			 Check for id in params(if query string)
			 If this is just a string representation of an id, parse
			 if(id === undefined &amp;&amp; typeof settings.data === "string") {
			 id = settings.data;
			 }
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>*/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
			<span class="hljs-keyword">if</span> (id === <span class="hljs-literal">undefined</span>) {
				settings.url.replace(<span class="hljs-regexp">/\/(\d+)(\/|$|\.)/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(all, num)</span> </span>{
					id = num;
				});
			}

			<span class="hljs-keyword">if</span> (id === <span class="hljs-literal">undefined</span>) {
				id = settings.url.replace(<span class="hljs-regexp">/\/(\w+)(\/|$|\.)/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(all, num)</span> </span>{
					<span class="hljs-keyword">if</span> (num != <span class="hljs-string">'update'</span>) {
						id = num;
					}
				})
			}

			<span class="hljs-keyword">if</span> (id === <span class="hljs-literal">undefined</span>) { <span class="hljs-comment">// if still not set, guess a random number</span>
				id = <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">1000</span>)
			}

			<span class="hljs-keyword">return</span> id;
		};


	<span class="hljs-keyword">var</span> $fixture = can.fixture = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(settings, fixture)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>if we provide a fixture …</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (fixture !== <span class="hljs-literal">undefined</span>) {
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> settings == <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>handle url strings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> matches = settings.match(<span class="hljs-regexp">/(GET|POST|PUT|DELETE) (.+)/i</span>);
				<span class="hljs-keyword">if</span> (!matches) {
					settings = {
						url : settings
					};
				} <span class="hljs-keyword">else</span> {
					settings = {
						url : matches[<span class="hljs-number">2</span>],
						type : matches[<span class="hljs-number">1</span>]
					};
				}

			}</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>handle removing.  An exact match if fixture was provided, otherwise, anything similar</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> index = find(settings, !!fixture);
			<span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) {
				overwrites.splice(index, <span class="hljs-number">1</span>)
			}
			<span class="hljs-keyword">if</span> (fixture == <span class="hljs-literal">null</span>) {
				<span class="hljs-keyword">return</span>
			}
			settings.fixture = fixture;
			overwrites.push(settings)
		} <span class="hljs-keyword">else</span> {
			can.each(settings, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fixture, url)</span></span>{
				$fixture(url, fixture);
			})
		}
	};
	<span class="hljs-keyword">var</span> replacer = can.replacer;

	can.extend(can.fixture, {</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>given ajax settings, find an overwrite</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		_similar : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(settings, overwrite, exact)</span> </span>{
			<span class="hljs-keyword">if</span> (exact) {
				<span class="hljs-keyword">return</span> can.Object.same(settings, overwrite, {fixture : <span class="hljs-literal">null</span>})
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> can.Object.subset(settings, overwrite, can.fixture._compare)
			}
		},
		_compare : {
			url : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>{
				<span class="hljs-keyword">return</span> !!$fixture._getData(b, a)
			},
			fixture : <span class="hljs-literal">null</span>,
			type : <span class="hljs-string">"i"</span>
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>gets data from a url like “/todo/{id}” given “todo/5”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		_getData : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fixtureUrl, url)</span> </span>{
			<span class="hljs-keyword">var</span> order = [],
				fixtureUrlAdjusted = fixtureUrl.replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">'\\.'</span>).replace(<span class="hljs-string">'?'</span>, <span class="hljs-string">'\\?'</span>),
				res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(fixtureUrlAdjusted.replace(replacer, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(whole, part)</span> </span>{
					order.push(part)
					<span class="hljs-keyword">return</span> <span class="hljs-string">"([^\/]+)"</span>
				}) + <span class="hljs-string">"$"</span>).exec(url),
				data = {};

			<span class="hljs-keyword">if</span> (!res) {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
			}
			res.shift();
			can.each(order, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> </span>{
				data[name] = res.shift()
			})
			<span class="hljs-keyword">return</span> data;
		},
		<span class="hljs-comment">/**
		 * @description Make a store of objects to use when making requests against fixtures.
		 * @function can.fixture.store store
		 * @parent can.fixture
		 * 
		 * @signature `can.fixture.store(count, make[, filter])`
		 * 
		 * @param {Number} count The number of items to create.
		 * 
		 * @param {Function} make A function that will return the JavaScript object. The
		 * make function is called back with the id and the current array of items.
		 * 
		 * @param {Function} [filter] A function used to further filter results. Used for to simulate
		 * server params like searchText or startDate.
		 * The function should return true if the item passes the filter,
		 * false otherwise. For example:
		 *
		 *
		 *     function(item, settings){
		 *       if(settings.data.searchText){
		 *            var regex = new RegExp("^"+settings.data.searchText)
		 *           return regex.test(item.name);
		 *       }
		 *     }
		 *
		 * @return {can.fixture.Store} A generator object providing fixture functions for *findAll*, *findOne*, *create*,
		 * *update* and *destroy*.
		 *
		 * @body
		 * `can.fixture.store(count, generator(index,items))` is used
		 * to create a store of items that can simulate a full CRUD service. Furthermore,
		 * the store can do filtering, grouping, sorting, and paging.
		 * 
		 * ## Basic Example
		 * 
		 * The following creates a store for 100 todos:
		 * 
		 *     var todoStore = can.fixture.store(100, function(i){
		 *       return {
		 *         id: i,
		 *         name: "todo number "+i,
		 *         description: "a description of some todo",
		 *         ownerId: can.fixture.rand(10)
		 *       }
		 *     })
		 * 
		 * `todoStore`'s methods:
		 * 
		 *  - [can.fixture.types.Store.findAll findAll],
		 *  - [can.fixture.types.Store.findOne findOne],
		 *  - [can.fixture.types.Store.create create],
		 *  - [can.fixture.types.Store.update update], and
		 *  - [can.fixture.types.Store.destroy destroy] 
		 * 
		 * Can be used to simulate a REST service like:
		 * 
		 *      can.fixture({
		 *        'GET /todos':         todoStore.findAll,
		 *        'GET /todos/{id}':    todoStore.findOne,
		 *        'POST /todos':        todoStore.create,
		 *        'PUT /todos/{id}':    todoStore.update,
		 *        'DELETE /todos/{id}': todoStore.destroy
		 *      });
		 * 
		 * These fixtures, combined with a [can.Model] that connects to these services like:
		 * 
		 *      var Todo = can.Model.extend({
		 *          findAll : 'GET /todos',
		 *          findOne : 'GET /todos/{id}',
		 *          create  : 'POST /todos',
		 *          update  : 'PUT /todos/{id}',
		 *          destroy : 'DELETE /todos/{id}'
		 *      }, {});
		 * 
		 * ... allows you to simulate requests for all of owner 5's todos like:
		 * 
		 *     Todo.findAll({ownerId: 5}, function(todos){
		 *        	   
		 *     })
		 * 
		 * 
		 */</span>
		store: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(types, count, make, filter)</span> </span>{

			<span class="hljs-keyword">var</span> items = [], <span class="hljs-comment">// TODO: change this to a hash</span>
				currentId = <span class="hljs-number">0</span>,
				findOne = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> </span>{
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) {
						<span class="hljs-keyword">if</span> (id == items[i].id) {
							<span class="hljs-keyword">return</span> items[i];
						}
					}
				},
				methods = {};

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> types === <span class="hljs-string">"string"</span>) {
				types = [types + <span class="hljs-string">"s"</span>, types ]
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!can.isArray(types)) {
				filter = make;
				make = count;
				count = types;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>make all items</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			can.extend(methods, {
				<span class="hljs-comment">/**
				 * @description Simulate a findAll to a fixture.
				 * @function can.fixture.types.Store.findAll
				 * @parent can.fixture.types.Store
				 * @signature `store.findAll(request)`
				 * 
				 * `store.findAll(request)` simulates a request to 
				 * get a list items from the server. It supports the
				 * following params:
				 * 
				 *  - order - `order=name ASC` 
				 *  - group - `group=name`
				 *  - limit - `limit=20`
				 *  - offset - `offset=60`
				 *  - id filtering - `ownerId=5`
				 * 
				 * 
				 * @param {{}} request The ajax request object. The available parameters are:
				 * @option {String} order The order of the results.
				 * `order: 'name ASC'`
				 * @option {String} group How to group the results.
				 * `group: 'name'`
				 * @option {String} limit A limit on the number to retrieve.
				 * `limit: 20`
				 * @option {String} offset The offset of the results.
				 * `offset: 60`
				 * @option {String} id Filtering by ID.
				 * `id: 5`
				 * 
				 * @return {Object} a response object like:
				 * 
				 *     {
				 *       count: 1000,
				 *       limit: 20,
				 *       offset: 60,
				 *       data: [item1, item2, ...]
				 *     }
				 * 
				 * where:
				 * 
				 * - count - the number of items that match any filtering 
				 *   before limit and offset is taken into account
				 * - offset - the offset passed
				 * - limit - the limit passed
				 * - data - an array of JS objects with each item's properties
				 * 
				 */</span>
				findAll: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(request)</span> </span>{
					request =  request || {}</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>copy array of items</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> retArr = items.slice(<span class="hljs-number">0</span>);
					request.data = request.data || {};</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>sort using order
order looks like [“age ASC”,”gender DESC”]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					can.each((request.data.order || []).slice(<span class="hljs-number">0</span>).reverse(), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> </span>{
						<span class="hljs-keyword">var</span> split = name.split(<span class="hljs-string">" "</span>);
						retArr = retArr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>{
							<span class="hljs-keyword">if</span> (split[<span class="hljs-number">1</span>].toUpperCase() !== <span class="hljs-string">"ASC"</span>) {
								<span class="hljs-keyword">if</span> (a[split[<span class="hljs-number">0</span>]] &lt; b[split[<span class="hljs-number">0</span>]]) {
									<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
								} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[split[<span class="hljs-number">0</span>]] == b[split[<span class="hljs-number">0</span>]]) {
									<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
								} <span class="hljs-keyword">else</span> {
									<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
								}
							}
							<span class="hljs-keyword">else</span> {
								<span class="hljs-keyword">if</span> (a[split[<span class="hljs-number">0</span>]] &lt; b[split[<span class="hljs-number">0</span>]]) {
									<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
								} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[split[<span class="hljs-number">0</span>]] == b[split[<span class="hljs-number">0</span>]]) {
									<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
								} <span class="hljs-keyword">else</span> {
									<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
								}
							}
						});
					});</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>group is just like a sort</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					can.each((request.data.group || []).slice(<span class="hljs-number">0</span>).reverse(), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> </span>{
						<span class="hljs-keyword">var</span> split = name.split(<span class="hljs-string">" "</span>);
						retArr = retArr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>{
							<span class="hljs-keyword">return</span> a[split[<span class="hljs-number">0</span>]] &gt; b[split[<span class="hljs-number">0</span>]];
						});
					});


					<span class="hljs-keyword">var</span> offset = <span class="hljs-built_in">parseInt</span>(request.data.offset, <span class="hljs-number">10</span>) || <span class="hljs-number">0</span>,
						limit = <span class="hljs-built_in">parseInt</span>(request.data.limit, <span class="hljs-number">10</span>) || (items.length - offset),
						i = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>filter results if someone added an attr like parentId</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> param <span class="hljs-keyword">in</span> request.data) {
						i = <span class="hljs-number">0</span>;
						<span class="hljs-keyword">if</span> (request.data[param] !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-comment">// don't do this if the value of the param is null (ignore it)</span>
							(param.indexOf(<span class="hljs-string">"Id"</span>) != -<span class="hljs-number">1</span> || param.indexOf(<span class="hljs-string">"_id"</span>) != -<span class="hljs-number">1</span>)) {
							<span class="hljs-keyword">while</span> (i &lt; retArr.length) {
								<span class="hljs-keyword">if</span> (request.data[param] != retArr[i][param]) {
									retArr.splice(i, <span class="hljs-number">1</span>);
								} <span class="hljs-keyword">else</span> {
									i++;
								}
							}
						}
					}

					<span class="hljs-keyword">if</span> (filter) {
						i = <span class="hljs-number">0</span>;
						<span class="hljs-keyword">while</span> (i &lt; retArr.length) {
							<span class="hljs-keyword">if</span> (!filter(retArr[i], request)) {
								retArr.splice(i, <span class="hljs-number">1</span>);
							} <span class="hljs-keyword">else</span> {
								i++;
							}
						}
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>return data spliced with limit and offset</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> {
						<span class="hljs-string">"count"</span> : retArr.length,
						<span class="hljs-string">"limit"</span> : request.data.limit,
						<span class="hljs-string">"offset"</span> : request.data.offset,
						<span class="hljs-string">"data"</span> : retArr.slice(offset, offset + limit)
					};
				},
				<span class="hljs-comment">/**
				 * @description Simulate a findOne request on a fixture.
				 * @function can.fixture.types.Store.findOne
				 * @parent can.fixture.types.Store
				 * @signature `store.findOne(request, callback)`
				 * @param {Object} request Parameters for the request.
				 * @param {Function} callback A function to call with the retrieved item.
				 * 
				 * @body
				 * `store.findOne(request, response(item))` simulates a request to 
				 * get a single item from the server by id.
				 * 
				 *     todosStore.findOne({
				 *       url: "/todos/5"
				 *     }, function(todo){
				 *       
				 *     });
				 * 
				 */</span>
				findOne : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(request, response)</span> </span>{
					<span class="hljs-keyword">var</span> item = findOne(getId(request));
					response(item ? item : <span class="hljs-literal">undefined</span>);
				},
				<span class="hljs-comment">/**
				 * @description Simulate an update on a fixture.
				 * @function can.fixture.types.Store.update
				 * @parent can.fixture.types.Store
				 * @signature `store.update(request, callback)`
				 * @param {Object} request Parameters for the request.
				 * @param {Function} callback A function to call with the updated item and headers.
				 * 
				 * @body
				 * `store.update(request, response(props,headers))` simulates
				 * a request to update an items properties on a server.
				 * 
				 *     todosStore.update({
				 *       url: "/todos/5"
				 *     }, function(props, headers){
				 *       props.id //-&gt; 5
				 *       headers.location // "todos/5"
				 *     });
				 */</span>
				update: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(request,response)</span> </span>{
					<span class="hljs-keyword">var</span> id = getId(request);</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>TODO: make it work with non-linear ids ..</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					can.extend(findOne(id), request.data);
					response({
						id : getId(request)
					}, {
						location : request.url || <span class="hljs-string">"/"</span> + getId(request)
					});
				},
				<span class="hljs-comment">/**
				 * @description Simulate destroying a Model on a fixture.
				 * @function can.fixture.types.Store.destroy
				 * @parent can.fixture.types.Store
				 * @signature `store.destroy(request, callback)`
				 * @param {Object} request Parameters for the request.
				 * @param {Function} callback A function to call after destruction.
				 * 
				 * @body
				 * `store.destroy(request, response())` simulates
				 * a request to destroy an item from the server.
				 * 
				 * @codestart
				 * todosStore.destroy({
				 *   url: "/todos/5"
				 * }, function(){});
				 * @codeend
				 */</span>
				destroy: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(request)</span> </span>{
					<span class="hljs-keyword">var</span> id = getId(request);
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) {
						<span class="hljs-keyword">if</span> (items[i].id == id) {
							items.splice(i, <span class="hljs-number">1</span>);
							<span class="hljs-keyword">break</span>;
						}
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>TODO: make it work with non-linear ids ..</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					can.extend(findOne(id) || {}, request.data);
					<span class="hljs-keyword">return</span> {};
				},
				<span class="hljs-comment">/**
				 * @description Simulate creating a Model with a fixture.
				 * @function can.fixture.types.Store.create
				 * @parent can.fixture.types.Store
				 * @signature `store.create(request, callback)`
				 * @param {Object} request Parameters for the request.
				 * @param {Function} callback A function to call with the created item.
				 * 
				 * @body
				 * `store.destroy(request, callback)` simulates
				 * a request to destroy an item from the server.
				 * 
				 * @codestart
				 * todosStore.create({
				 *   url: "/todos"
				 * }, function(){});
				 * @codeend
				 */</span>
				create: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(settings, response)</span> </span>{
					<span class="hljs-keyword">var</span> item = make(items.length, items);

					can.extend(item, settings.data);

					<span class="hljs-keyword">if</span> (!item.id) {
						item.id = currentId++;
					}

					items.push(item);
					response({
						id : item.id
					}, {
						location : settings.url + <span class="hljs-string">"/"</span> + item.id
					})
				}
			});

			<span class="hljs-keyword">var</span> reset = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
				items = [];
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; (count); i++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>call back provided make</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> item = make(i, items);
	
					<span class="hljs-keyword">if</span> (!item.id) {
						item.id = i;
					}
					currentId = <span class="hljs-built_in">Math</span>.max(item.id+<span class="hljs-number">1</span>, currentId+<span class="hljs-number">1</span>) || items.length;
					items.push(item);
				}
				<span class="hljs-keyword">if</span>(can.isArray(types)) {
					can.fixture[<span class="hljs-string">"~"</span> + types[<span class="hljs-number">0</span>]] = items;
					can.fixture[<span class="hljs-string">"-"</span> + types[<span class="hljs-number">0</span>]] = methods.findAll;
					can.fixture[<span class="hljs-string">"-"</span> + types[<span class="hljs-number">1</span>]] = methods.findOne;
					can.fixture[<span class="hljs-string">"-"</span> + types[<span class="hljs-number">1</span>]+<span class="hljs-string">"Update"</span>] = methods.update;
					can.fixture[<span class="hljs-string">"-"</span> + types[<span class="hljs-number">1</span>]+<span class="hljs-string">"Destroy"</span>] = methods.destroy;
					can.fixture[<span class="hljs-string">"-"</span> + types[<span class="hljs-number">1</span>]+<span class="hljs-string">"Create"</span>] = methods.create;
				}
				
			}
			reset()</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>if we have types given add them to can.fixture</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			

			<span class="hljs-keyword">return</span> can.extend({
				getId: getId,
				<span class="hljs-comment">/**
				 * @description Get an item from the store by ID.
				 * @function can.fixture.types.Store.find
				 * @parent can.fixture.types.Store
				 * @signature `store.find(settings)`
				 * @param {Object} settings An object containing an `id` key
				 * corresponding to the item to find.
				 * 
				 * @body
				 * `store.find(settings)`
				 * `store.destroy(request, callback)` simulates a request to 
				 * get a single item from the server.
				 * 
				 * @codestart
				 * todosStore.find({
				 *   url: "/todos/5"
				 * }, function(){});
				 * @codeend
				 */</span>
				find: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(settings)</span></span>{
					<span class="hljs-keyword">return</span> findOne( getId(settings) );
				},
				<span class="hljs-comment">/**
				 * @description Reset the fixture store.
				 * @function can.fixture.types.Store.reset
				 * @parent can.fixture.types.Store
				 * @signature `store.reset()`
				 * 
				 * @body
				 * `store.reset()` resets the store to contain its 
				 * original data. This is useful for making tests that
				 * operate independently.
				 * 
				 * ## Basic Example
				 * 
				 * After creating a `taskStore` and hooking it up to a 
				 * `task` model in the "Basic Example" in [can.fixture.store store's docs],
				 * a test might create several tasks like:
				 * 
				 *     new Task({name: "Take out trash", ownerId: 5}).save();
				 * 
				 * But, another test might need to operate on the original set of
				 * tasks created by `can.fixture.store`. Reset the task store with:
				 * 
				 *     taskStore.reset()
				 * 
				 */</span>
				reset: reset
			}, methods);
		},
		<span class="hljs-comment">/**
		 * @description Create a random number or selection.
		 * @function can.fixture.rand rand
		 * @parent can.fixture
		 * @signature `can.fixture.rand([min,] max)`
		 * @param {Number} [min=0] The lower bound on integers to select.
		 * @param {Number} max The upper bound on integers to select.
		 * @return {Number} A random integer in the range [__min__, __max__).
		 *
		 * @signature `can.fixture.rand(choices, min[ ,max])`
		 * @param {Array} choices An array of things to choose from.
		 * @param {Number} min The minimum number of times to choose from __choices__.
		 * @param {Number} [max=min] The maximum number of times to choose from __choices__.
		 * @return {Array} An array of between __min__ and __max__ random choices from __choices__.
		 *
		 * @body
		 * `can.fixture.rand` creates random integers or random arrays of
		 * other arrays.
		 *
		 * ## Examples
		 *
		 *     var rand = can.fixture.rand;
		 *
		 *     // get a random integer between 0 and 10 (inclusive)
		 *     rand(11);
		 *
		 *     // get a random number between -5 and 5 (inclusive)
		 *     rand(-5, 6);
		 *
		 *     // pick a random item from an array
		 *     rand(["j","m","v","c"],1)[0]
		 *
		 *     // pick a random number of items from an array
		 *     rand(["j","m","v","c"])
		 *
		 *     // pick 2 items from an array
		 *     rand(["j","m","v","c"],2)
		 *
		 *     // pick between 2 and 3 items at random
		 *     rand(["j","m","v","c"],2,3)
		 */</span>
		rand : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr, min, max)</span> </span>{
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arr == <span class="hljs-string">'number'</span>) {
				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> min == <span class="hljs-string">'number'</span>) {
					<span class="hljs-keyword">return</span> arr + <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (min - arr));
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * arr);
				}

			}
			<span class="hljs-keyword">var</span> rand = <span class="hljs-built_in">arguments</span>.callee;</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>get a random set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (min === <span class="hljs-literal">undefined</span>) {
				<span class="hljs-keyword">return</span> rand(arr, rand(arr.length + <span class="hljs-number">1</span>))
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>get a random selection of arr</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> res = [];
			arr = arr.slice(<span class="hljs-number">0</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>set max</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!max) {
				max = min;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>random max</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			max = min + <span class="hljs-built_in">Math</span>.round(rand(max - min))
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; max; i++) {
				res.push(arr.splice(rand(arr.length), <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])
			}
			<span class="hljs-keyword">return</span> res;
		},
		<span class="hljs-comment">/**
		 * @hide
		 *
		 * Use can.fixture.xhr to create an object that looks like an xhr object.
		 *
		 * ## Example
		 *
		 * The following example shows how the -restCreate fixture uses xhr to return
		 * a simulated xhr object:
		 * @codestart
		 * "-restCreate" : function( settings, cbType ) {
		 *   switch(cbType){
		 *     case "success":
		 *       return [
		 *         {id: parseInt(Math.random()*1000)},
		 *         "success",
		 *         can.fixture.xhr()];
		 *     case "complete":
		 *       return [
		 *         can.fixture.xhr({
		 *           getResponseHeader: function() { 
		 *             return settings.url+"/"+parseInt(Math.random()*1000);
		 *           }
		 *         }),
		 *         "success"];
		 *   }
		 * }
		 * @codeend
		 * @param {Object} [xhr] properties that you want to overwrite
		 * @return {Object} an object that looks like a successful XHR object.
		 */</span>
		xhr : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(xhr)</span> </span>{
			<span class="hljs-keyword">return</span> can.extend({}, {
				abort : can.noop,
				getAllResponseHeaders : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
					<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
				},
				getResponseHeader : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
					<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
				},
				open : can.noop,
				overrideMimeType : can.noop,
				readyState : <span class="hljs-number">4</span>,
				responseText : <span class="hljs-string">""</span>,
				responseXML : <span class="hljs-literal">null</span>,
				send : can.noop,
				setRequestHeader : can.noop,
				status : <span class="hljs-number">200</span>,
				statusText : <span class="hljs-string">"OK"</span>
			}, xhr);
		},
		<span class="hljs-comment">/**
		 * @property {Boolean} can.fixture.on on
		 * @parent can.fixture
		 *
		 * `can.fixture.on` lets you programatically turn off fixtures. This is mostly used for testing.
		 *
		 *     can.fixture.on = false
		 *     Task.findAll({}, function(){
		 *       can.fixture.on = true;
		 *     })
		 */</span>
		on : <span class="hljs-literal">true</span>
	});
	<span class="hljs-comment">/**
	 * @property {Number} can.fixture.delay delay
	 * @parent can.fixture
	 *
	 * `can.fixture.delay` indicates the delay in milliseconds between an ajax request is made and
	 * the success and complete handlers are called.  This only sets
	 * functional synchronous fixtures that return a result. By default, the delay is 200ms.
	 *
	 * @codestart
	 * steal('can/util/fixtures').then(function(){
	 *   can.fixture.delay = 1000;
	 * })
	 * @codeend
	 */</span>
	can.fixture.delay = <span class="hljs-number">200</span>;

	<span class="hljs-comment">/**
	 * @property {String} can.fixture.rootUrl rootUrl
	 * @parent can.fixture
	 *
	 * `can.fixture.rootUrl` contains the root URL for fixtures to use.
	 * If you are using StealJS it will use the Steal root
	 * URL by default.
	 */</span>
	can.fixture.rootUrl = getUrl(<span class="hljs-string">''</span>);

	can.fixture[<span class="hljs-string">"-handleFunction"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(settings)</span> </span>{
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> settings.fixture === <span class="hljs-string">"string"</span> &amp;&amp; can.fixture[settings.fixture]) {
			settings.fixture = can.fixture[settings.fixture];
		}
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> settings.fixture == <span class="hljs-string">"function"</span>) {
			setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
				<span class="hljs-keyword">if</span> (settings.success) {
					settings.success.apply(<span class="hljs-literal">null</span>, settings.fixture(settings, <span class="hljs-string">"success"</span>));
				}
				<span class="hljs-keyword">if</span> (settings.complete) {
					settings.complete.apply(<span class="hljs-literal">null</span>, settings.fixture(settings, <span class="hljs-string">"complete"</span>));
				}
			}, can.fixture.delay);
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		}
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>Expose this for fixture debugging</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	can.fixture.overwrites = overwrites;
	can.fixture.make = can.fixture.store;
	<span class="hljs-keyword">return</span> can.fixture;
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>

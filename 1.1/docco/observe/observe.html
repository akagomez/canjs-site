<!DOCTYPE html>

<html>
<head>
  <title>observe.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>observe.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>1.69</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>steal(<span class="hljs-string">'can/util'</span>,<span class="hljs-string">'can/util/bind'</span>,<span class="hljs-string">'can/construct'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(can, bind)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="observe-js">observe.js</h2>
<p><code>can.Observe</code><br><em>Provides the observable pattern for JavaScript Objects.</em>  </p>
<p>Returns <code>true</code> if something is an object with properties of its own.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> canMakeObserve = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( obj )</span> </span>{
			<span class="hljs-keyword">return</span> obj &amp;&amp; !can.isDeferred(obj) &amp;&amp; (can.isArray(obj) || can.isPlainObject( obj ) || ( obj <span class="hljs-keyword">instanceof</span> can.Observe ));
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Removes all listeners.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		unhookup = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(items, namespace)</span></span>{
			<span class="hljs-keyword">return</span> can.each(items, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span></span>{
				<span class="hljs-keyword">if</span>(item &amp;&amp; item.unbind){
					item.unbind(<span class="hljs-string">"change"</span> + namespace);
				}
			});
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Listens to changes on <code>child</code> and “bubbles” the event up.<br><code>child</code> - The object to listen for changes on.<br><code>prop</code> - The property name is at on.<br><code>parent</code> - The parent object of prop.
<code>ob</code> - (optional) The Observe object constructor
<code>list</code> - (optional) The observable list constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		hookupBubble = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( child, prop, parent, Ob, List )</span> </span>{
			Ob = Ob || Observe;
			List = List || Observe.List;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>If it’s an <code>array</code> make a list, otherwise a child.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (child <span class="hljs-keyword">instanceof</span> Observe){</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>We have an <code>observe</code> already…
Make sure it is not listening to this already
It’s only listening if it has bindings already.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				parent._bindings &amp;&amp;unhookup([child], parent._cid);
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( can.isArray(child) ) {
				child = <span class="hljs-keyword">new</span> List(child);
			} <span class="hljs-keyword">else</span> {
				child = <span class="hljs-keyword">new</span> Ob(child);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>only listen if something is listening to you</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(parent._bindings){</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Listen to all changes and <code>batchTrigger</code> upwards.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				bindToChildAndBubbleToParent(child, prop, parent)
			}
			

			<span class="hljs-keyword">return</span> child;
		},
		bindToChildAndBubbleToParent = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child, prop, parent)</span></span>{
			child.bind(<span class="hljs-string">"change"</span> + parent._cid, 
				<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( <span class="hljs-comment">/* ev, attr */</span> )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p><code>batchTrigger</code> the type on this…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> args = can.makeArray(<span class="hljs-built_in">arguments</span>),
					ev = args.shift();
					args[<span class="hljs-number">0</span>] = (prop === <span class="hljs-string">"*"</span> ? 
						[ parent.indexOf( child ), args[<span class="hljs-number">0</span>]] :
						[ prop, args[<span class="hljs-number">0</span>]] ).join(<span class="hljs-string">"."</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>track objects dispatched on this observe        </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				ev.triggeredNS = ev.triggeredNS || {};</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>if it has already been dispatched exit</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (ev.triggeredNS[parent._cid]) {
					<span class="hljs-keyword">return</span>;
				}

				ev.triggeredNS[parent._cid] = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>send change event with modified attr to parent    </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				can.trigger(parent, ev, args);</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>send modified attr event to parent
can.trigger(parent, args[0], args);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			});
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>An <code>id</code> to track events for a given observe.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		observeId = <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>A helper used to serialize an <code>Observe</code> or <code>Observe.List</code>.<br><code>observe</code> - The observable.<br><code>how</code> - To serialize with <code>attr</code> or <code>serialize</code>.<br><code>where</code> - To put properties, in an <code>{}</code> or <code>[]</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		serialize = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( observe, how, where )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Go through each property.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			observe.each(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( val, name )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>If the value is an <code>object</code>, and has an <code>attrs</code> or <code>serialize</code> function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				where[name] = canMakeObserve(val) &amp;&amp; can.isFunction( val[how] ) ?</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Call <code>attrs</code> or <code>serialize</code> to get the original data back.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				val[how]() :</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Otherwise return the value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				val;
			});
			<span class="hljs-keyword">return</span> where;
		},
		attrParts = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attr, keepKey)</span> </span>{
			<span class="hljs-keyword">if</span>(keepKey) {
				<span class="hljs-keyword">return</span> [attr];
			}
			<span class="hljs-keyword">return</span> can.isArray(attr) ? attr : (<span class="hljs-string">""</span>+attr).split(<span class="hljs-string">"."</span>);
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Which batch of events this is for — might not want to send multiple
messages on the same batch.  This is mostly for event delegation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		batchNum = <span class="hljs-number">1</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>how many times has start been called without a stop</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		transactions = <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>an array of events within a transaction</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		batchEvents = [],
		stopCallbacks = [],
		makeBindSetup = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(wildcard)</span></span>{
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
				<span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">this</span>;
				<span class="hljs-keyword">this</span>._each(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child, prop)</span></span>{
					<span class="hljs-keyword">if</span>(child &amp;&amp; child.bind){
						bindToChildAndBubbleToParent(child, wildcard || prop, parent)
					}
				})
			};
		};
	
	<span class="hljs-comment">/**
	 * @add can.Observe
	 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> Observe = can.Map = can.Observe = can.Construct( {
	<span class="hljs-comment">/**
	 * @static
	 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>keep so it can be overwritten</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		bind : can.bindAndSetup,
		unbind: can.unbindAndTeardown,
		id: <span class="hljs-string">"id"</span>,
		canMakeObserve : canMakeObserve,</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>starts collecting events
takes a callback for after they are updated
how could you hook into after ejs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @function can.Observe.startBatch startBatch
		 * @parent can.Observe.static
		 * @description Begin an event batch.
		 * 
		 * @signature `can.Observe.startBatch([batchStopHandler])`
		 * 
		 * @param {Function} [batchStopHandler] a callback that gets called after all batched events have been called
		 *
		 * @body
		 * `startBatch` causes [can.Observe] to begin an event batch. Until `[can.Observe.stopBatch]` is called, any
		 * events that would result from calls to `[can.Observe::attr attr]` are held back from firing. If you have
		 * lots of changes to make to can.Observes, batching them together can help performance &amp;emdash; especially if
		 * those can.Observes are live-bound to the DOM.
		 *
		 * In this example, you can see how the _first_ and _change_ events are not fired (and their handlers
		 * are not called) until `stopBatch` is called.
		 *
		 * @codestart
		 * var person = new can.Observe({
		 *     first: 'Alexis',
		 *     last: 'Abril'
		 * });
		 *
		 * person.bind('first', function() {
		 *     console.log("First name changed.");
		 * }).bind('change', function() {
		 *     console.log("Something changed.");
		 * });
		 * 
		 * can.Observe.startBatch();
		 * person.attr('first', 'Alex');
		 * console.log('Still in the batch.');
		 * can.Observe.stopBatch();
		 * 
		 * // the log has:
		 * // Still in the batch.
		 * // First name changed.
		 * // Something changed.
		 * @codeend
		 *
		 * You can also pass a callback to `startBatch` which will be called after all the events have
		 * been fired:
		 * @codestart
		 * can.Observe.startBatch(function() {
		 *     console.log('The batch is over.');
		 * });
		 * person.attr('first', 'Izzy');
		 * console.log('Still in the batch.');
		 * can.Observe.stopBatch();
		 * 
		 * // The console has:
		 * // Still in the batch.
		 * // First name changed.
		 * // Something changed.
		 * // The batch is over.
		 * @codeend
		 *
		 * ## Calling `startBatch` multiple times
		 * 
		 * If you call `startBatch` more than once, `stopBatch` needs to be called
		 * the same number of times before any batched events will fire. For ways
		 * to circumvent this process, see [can.Observe.stopBatch].
		 *
		 * Here is an example that demonstrates how events are affected by calling
		 * `startBatch` multiple times.
		 * 
		 * @codestart
		 * var addPeople = function(observable) {
		 *     can.Observe.startBatch();
		 *     observable.attr('a', 'Alice');
		 *     observable.attr('b', 'Bob');
		 *     observable.attr('e', 'Eve');
		 *     can.Observe.stopBatch();
		 * };
		 *
		 * // In a completely different place:
		 * var list = new can.Observe();
		 * list.bind('change', function() {
		 *     console.log('The list changed.');
		 * });
		 *
		 * can.Observe.startBatch();
		 * addPeople(list);
		 * console.log('Still in the batch.');
		 *
		 * // Here, the console has:
		 * // Still in the batch.
		 * 
		 * can.Observe.stopBatch();
		 * 
		 * // Here, the console has:
		 * // Still in the batch.
		 * // The list changed.
		 * // The list changed.
		 * // The list changed.
		 * @codeend
		 */</span>
		startBatch: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( batchStopHandler )</span> </span>{
			transactions++;
			batchStopHandler &amp;&amp; stopCallbacks.push(batchStopHandler);
		},
		<span class="hljs-comment">/**
		 * @function can.Observe.stopBatch stopBatch
		 * @parent can.Observe.static
		 * @description End an event batch.
		 * @signature `can.Observe.stopBatch([force[, callStart]])`
		 * @param {bool} [force=false] whether to stop batching events immediately
		 * @param {bool} [callStart=false] whether to call `[can.Observe.startBatch startBatch]` after firing batched events
		 * 
		 * @body
		 * `stopBatch` matches an earlier `[can.Observe.startBatch]` call. If `stopBatch` has been
		 * called as many times as `startBatch` (or if _force_ is true), all batched events will be
		 * fired and any callbacks passed to `startBatch` since the beginning of the batch will be
		 * called. If _force and _callStart_ are both true, a new batch will be started when all
		 * the events and callbacks have been fired.
		 *
		 * See `[can.Observe.startBatch]` for examples of `startBatch` and `stopBatch` in normal use.
		 * 
		 * In this example, the batch is forceably ended in the `addPeople` function.
		 * @codestart
		 * var addPeople = function(observable) {
		 *     can.Observe.startBatch();
		 *     observable.attr('a', 'Alice');
		 *     observable.attr('b', 'Bob');
		 *     observable.attr('e', 'Eve');
		 *     can.Observe.stopBatch(true);
		 * };
		 *
		 * // In a completely different place:
		 * var list = new can.Observe();
		 * list.bind('change', function() {
		 *     console.log('The list changed.');
		 * });
		 *
		 * can.Observe.startBatch();
		 * addPeople(list);
		 * console.log('Still in the batch.');
		 *
		 * // Here, the console has:
		 * // Still in the batch.
		 * 
		 * can.Observe.stopBatch();
		 * 
		 * // Here, the console has:
		 * // The list changed.
		 * // The list changed.
		 * // The list changed.
		 * // Still in the batch.
		 * @codeend
		 */</span>
		stopBatch: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(force, callStart)</span></span>{
			<span class="hljs-keyword">if</span>(force){
				transactions = <span class="hljs-number">0</span>;
			} <span class="hljs-keyword">else</span> {
				transactions--;
			}
			
			<span class="hljs-keyword">if</span>(transactions == <span class="hljs-number">0</span>){
				<span class="hljs-keyword">var</span> items = batchEvents.slice(<span class="hljs-number">0</span>),
					callbacks = stopCallbacks.slice(<span class="hljs-number">0</span>);
				batchEvents= [];
				stopCallbacks = [];
				batchNum++;
				callStart &amp;&amp; <span class="hljs-keyword">this</span>.startBatch();
				can.each(items, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( args )</span> </span>{
					can.trigger.apply(can, args);
				});
				can.each(callbacks, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( cb )</span> </span>{
					cb();
				});
			}
		},
		<span class="hljs-comment">/**
		 * @function can.Observe.triggerBatch triggerBatch
		 * @parent can.Observe.static
		 * @description Trigger an event to be added to the current batch.
		 * @signature `can.Observe.triggerBatch(item, event [, args])`
		 * @param {can.Observe} item the target of the event
		 * @param {String|Object} event the type of event (e.g. "change"), or an event object with a type given (e.g. {type: "change"})
		 * @param {Array} [args] the parameters to trigger the event with.
		 * 
		 * @body
		 * If events are currently being batched, calling `triggerBatch` adds an event
		 * to the batch. If events are not currently being batched, the event is triggered
		 * immediately.
		 */</span>
		triggerBatch: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( item, event, args )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Don’t send events if initalizing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> ( ! item._init) {
				<span class="hljs-keyword">if</span> (transactions == <span class="hljs-number">0</span> ) {
					<span class="hljs-keyword">return</span> can.trigger(item, event, args);
				} <span class="hljs-keyword">else</span> {
					event = <span class="hljs-keyword">typeof</span> event === <span class="hljs-string">"string"</span> ?
						{ type: event } : 
						event;
					event.batchNum = batchNum;
					batchEvents.push([
					item,
					event, 
					args ] );
				}
			}
		},
		<span class="hljs-comment">/**
		 * @function can.Observe.keys keys
		 * @parent can.Observe.static
		 * @description Iterate over the keys of an Observe.
		 * @signature `can.Observe.keys(observe)`
		 * @param {can.Observe} observe the `can.Observe` to get the keys from
		 * @return {Array} An array containing the keys from _observe_.
		 * 
		 * @body
		 * `keys` iterates over an observe to get an array of its keys.
		 * 
		 * @codestart
		 * var people = new can.Observe({
		 *     a: 'Alice',
		 *     b: 'Bob',
		 *     e: 'Eve'
		 * });
		 * 
		 * can.Observe.keys(people); // ['a', 'b', 'e']
		 * @codeend
		 */</span>
		keys: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(observe)</span> </span>{
			<span class="hljs-keyword">var</span> keys = [];
			Observe.__reading &amp;&amp; Observe.__reading(observe, <span class="hljs-string">'__keys'</span>);
			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> keyName <span class="hljs-keyword">in</span> observe._data) {
				keys.push(keyName);
			}
			<span class="hljs-keyword">return</span> keys;
		}
	},
	<span class="hljs-comment">/**
	 * @prototype
	 */</span>
	{
		setup: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( obj )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p><code>_data</code> is where we keep the properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>._data = {};
			<span class="hljs-comment">/**
			 * @property {String} can.Observe.prototype._cid
			 * @hide
			 *
			 * A globally unique ID for this `can.Observe` instance.
			 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>The namespace this <code>object</code> uses to listen to events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			can.cid(<span class="hljs-keyword">this</span>, <span class="hljs-string">".observe"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Sets all <code>attrs</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>._init = <span class="hljs-number">1</span>;
			<span class="hljs-keyword">this</span>.attr(obj);
			<span class="hljs-keyword">this</span>.bind(<span class="hljs-string">'change'</span>+<span class="hljs-keyword">this</span>._cid,can.proxy(<span class="hljs-keyword">this</span>._changes,<span class="hljs-keyword">this</span>));
			<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._init;
		},
		_bindsetup: makeBindSetup(),
		_bindteardown: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
			<span class="hljs-keyword">var</span> cid = <span class="hljs-keyword">this</span>._cid;
			<span class="hljs-keyword">this</span>._each(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child)</span></span>{
				unhookup([child], cid)
			})
		},
		_changes: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ev, attr, how,newVal, oldVal)</span></span>{
			Observe.triggerBatch(<span class="hljs-keyword">this</span>, {type:attr, batchNum: ev.batchNum}, [newVal,oldVal]);
		},
		_triggerChange: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attr, how,newVal, oldVal)</span></span>{
			Observe.triggerBatch(<span class="hljs-keyword">this</span>,<span class="hljs-string">"change"</span>,can.makeArray(<span class="hljs-built_in">arguments</span>))
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>no live binding iterator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		_each: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
			<span class="hljs-keyword">var</span> data = <span class="hljs-keyword">this</span>.__get();
			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> data){
				<span class="hljs-keyword">if</span>(data.hasOwnProperty(prop)){
					callback(data[prop],prop)
				}
			}
		},
		<span class="hljs-comment">/**
		 * @function can.Observe.prototype.attr attr
		 * @description Get or set properties on an Observe.
		 * @signature `observe.attr()`
		 * 
		 * Gets a collection of all the properties in this `can.Observe`.
		 * 
		 * @return {Object&lt;String, *&gt;} an object with all the properties in this `can.Observe`.
		 * 
		 * @signature `observe.attr(key)`
		 * 
		 * Reads a property from this `can.Observe`.
		 * 
		 * @param {String} key the property to read
		 * @return {*} the value assigned to _key_.
		 *
		 * @signature `observe.attr(key, value)`
		 * 
		 * Assigns _value_ to a property on this `can.Observe` called _key_.
		 * 
		 * @param {String} key the property to set
		 * @param {*} value the value to assign to _key_.
		 * @return {can.Observe} this Observe, for chaining
		 * 
		 * @signature `observe.attr(obj[, removeOthers])`
		 * 
		 * Assigns each value in _obj_ to a property on this `can.Observe` named after the
		 * corresponding key in _obj_, effectively merging _obj_ into the Observe.
		 * 
		 * @param {Object&lt;String, *&gt;} obj a collection of key-value pairs to set.
		 * If any properties already exist on the `can.Observe`, they will be overwritten.
		 *
		 * @param {bool} [removeOthers=false] whether to remove keys not present in _obj_.
		 * To remove keys without setting other keys, use `[can.Observe::removeAttr removeAttr]`.
		 *
		 * @return {can.Observe} this Observe, for chaining
		 * 
		 * @body
		 * `attr` gets or sets properties on the `can.Observe` it's called on. Here's a tour through
		 * how all of its forms work:
		 *
		 * @codestart
		 * var people = new can.Observe({});
		 * 
		 * // set a property:
		 * people.attr('a', 'Alex');
		 * 
		 * // get a property:
		 * people.attr('a'); // 'Alex'
		 *
		 * // set and merge multiple properties:
		 * people.attr({
		 *     a: 'Alice',
		 *     b: 'Bob'
		 * });
		 * 
		 * // get all properties:
		 * people.attr(); // {a: 'Alice', b: 'Bob'}
		 * 
		 * // set properties while removing others:
		 * people.attr({
		 *     b: 'Bill',
		 *     e: 'Eve'
		 * }, true);
		 *
		 * people.attr(); // {b: 'Bill', e: 'Eve'}
		 * @codeend
		 * 
		 * ## Deep properties
		 * 
		 * `attr` can also set and read deep properties. All you have to do is specify
		 * the property name as you normally would if you weren't using `attr`.
		 * 
		 * @codestart
		 * var people = new can.Observe({names: {}});
		 * 
		 * // set a property:
		 * people.attr('names.a', 'Alice');
		 * 
		 * // get a property:
		 * people.attr('names.a'); // 'Alice'
		 * people.names.attr('a'); // 'Alice'
		 *
		 * // get all properties:
		 * people.attr(); // {names: {a: 'Alice'}}
		 * @codeend
		 * 
		 * Objects that are added to Observes become Observes themselves behind the scenes,
		 * so changes to deep properties fire events at each level, and you can bind at any
		 * level. As this example shows, all the same events are fired no matter what level
		 * you call `attr` at:
		 * 
		 * @codestart
		 * var people = new can.Observe({names: {}});
		 *
		 * people.bind('change', function(ev, attr, how, newVal, oldVal) {
		 *   console.log('people change: ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);
		 * });
		 * 
		 * people.names.bind('change', function(ev, attr, how, newVal, oldVal) {
		 *    console.log('people.names change' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);
		 * });
		 * 
		 * people.bind('names', function(ev, newVal, oldVal) {
		 *     console.log('people names: ' + newVal + ', ' + oldVal);
		 * });
		 *
		 * people.names.bind('a', function(ev, newVal, oldVal) {
		 *     console.log('people.names a: ' + newVal + ', ' + oldVal);
		 * });
		 * 
		 * people.bind('names.a', function(ev, newVal, oldVal) {
		 *     console.log('people names.a: ' + newVal + ', ' + oldVal);
		 * });
		 * 
		 * people.attr('names.a', 'Alice'); // people change: names.a, add, Alice, undefined
		 *                                  // people.names change: a, add, Alice, undefined
		 *                                  // people.names a: Alice, undefined
		 *                                  // people names.a: Alice, undefined
		 * 
		 * people.names.attr('b', 'Bob');   // people change: names.b, add, Bob, undefined
		 *                                  // people.names change: b, add, Bob, undefined
		 *                                  // people.names b: Bob, undefined
		 *                                  // people names.b: Bob, undefined
		 * @codeend
		 * 
		 * ## See also
		 * 
		 * For information on the events that are fired on property changes and how
		 * to listen for those events, see [can.Observe.prototype.bind bind].
		 */</span>
		attr: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( attr, val )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>This is super obfuscated for space — basically, we’re checking
if the type of the attribute is not a <code>number</code> or a <code>string</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span> attr;
			<span class="hljs-keyword">if</span> ( type !== <span class="hljs-string">"string"</span> &amp;&amp; type !== <span class="hljs-string">"number"</span> ) {
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._attrs(attr, val)
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">1</span> ) {<span class="hljs-comment">// If we are getting a value.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Let people know we are reading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				Observe.__reading &amp;&amp; Observe.__reading(<span class="hljs-keyword">this</span>, attr)
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._get(attr)
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Otherwise we are setting.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>._set(attr, val);
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
			}
		},
		<span class="hljs-comment">/**
		 * @function can.Observe.prototype.each each
		 * @description Call a function on each property of an Observe.
		 * @signature `observe.each( callback(item, propName ) )`
		 * 
		 * `each` iterates through the Observe, calling a function
		 * for each property value and key.
		 * 
		 * @param {function(*,String)} callback(item,propName) the function to call for each property
		 * The value and key of each property will be passed as the first and second
		 * arguments, respectively, to the callback. If the callback returns false,
		 * the loop will stop.
		 * 
		 * @return {can.Observe} this Observe, for chaining
		 *
		 * @body
		 * @codestart
		 * var names = [];
		 * new can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {
		 *     names.push(value);
		 * });
		 * 
		 * names; // ['Alice', 'Bob', 'Eve']
		 * 
		 * names = [];
		 * new can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {
		 *     names.push(value);
		 *     if(key === 'b') {
		 *         return false;
		 *     }
		 * });
		 * 
		 * names; // ['Alice', 'Bob']
		 * 
		 * @codeend
		 */</span>
		each: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
			Observe.__reading &amp;&amp; Observe.__reading(<span class="hljs-keyword">this</span>, <span class="hljs-string">'__keys'</span>);
			<span class="hljs-keyword">return</span> can.each.apply(<span class="hljs-literal">undefined</span>, [<span class="hljs-keyword">this</span>.__get()].concat(can.makeArray(<span class="hljs-built_in">arguments</span>)))
		},
		<span class="hljs-comment">/**
		 * @function can.Observe.prototype.removeAttr removeAttr
		 * @description Remove a property from an Observe.
		 * @signature `observe.removeAttr(attrName)`
		 * @param {String} attrName the name of the property to remove
		 * @return {*} the value of the property that was removed
		 * 
		 * @body
		 * `removeAttr` removes a property by name from an Observe.
		 * 
		 * @codestart
		 * var people = new can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'});
		 * 
		 * people.removeAttr('b'); // 'Bob'
		 * people.attr();          // {a: 'Alice', e: 'Eve'}
		 * @codeend
		 * 
		 * Removing an attribute will cause a _change_ event to fire with `'remove'`
		 * passed as the _how_ parameter and `undefined` passed as the _newVal_ to
		 * handlers. It will also cause a _property name_ event to fire with `undefined`
		 * passed as _newVal_. An in-depth description at these events can be found
		 * under `[can.Observe.prototype.attr attr]`.
		 */</span>
		removeAttr: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( attr )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Info if this is List or not</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> isList = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> can.Observe.List,</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Convert the <code>attr</code> into parts (if nested).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				parts = attrParts(attr),</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>The actual property to remove.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				prop = parts.shift(),</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>The current value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				current = isList ? <span class="hljs-keyword">this</span>[prop] : <span class="hljs-keyword">this</span>._data[prop];</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>If we have more parts, call <code>removeAttr</code> on that part.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> ( parts.length ) {
				<span class="hljs-keyword">return</span> current.removeAttr(parts)
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">if</span>(isList) {
					<span class="hljs-keyword">this</span>.splice(prop, <span class="hljs-number">1</span>)
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( prop <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>._data ){</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Otherwise, <code>delete</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._data[prop];</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Create the event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!(prop <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.constructor.prototype)) {
						<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>[prop]
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Let others know the number of keys have changed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					Observe.triggerBatch(<span class="hljs-keyword">this</span>, <span class="hljs-string">"__keys"</span>);
					<span class="hljs-keyword">this</span>._triggerChange(prop, <span class="hljs-string">"remove"</span>, <span class="hljs-literal">undefined</span>, current);

				}
				<span class="hljs-keyword">return</span> current;
			}
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Reads a property from the <code>object</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		_get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( attr )</span> </span>{
			<span class="hljs-keyword">var</span> value = <span class="hljs-keyword">typeof</span> attr === <span class="hljs-string">'string'</span> &amp;&amp; !!~attr.indexOf(<span class="hljs-string">'.'</span>) &amp;&amp; <span class="hljs-keyword">this</span>.__get(attr);
			<span class="hljs-keyword">if</span>(value) {
				<span class="hljs-keyword">return</span> value;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>break up the attr (<code>&quot;foo.bar&quot;</code>) into <code>[&quot;foo&quot;,&quot;bar&quot;]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> parts = attrParts(attr),</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>get the value of the first attr name (<code>&quot;foo&quot;</code>)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				current = <span class="hljs-keyword">this</span>.__get(parts.shift());</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>if there are other attributes to read</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> parts.length ?</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>and current has a value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				current ?</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>lookup the remaining attrs on current</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					current._get(parts) :</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>or if there’s no current, return undefined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-literal">undefined</span> 	
				:</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>if there are no more parts, return current</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				current;
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Reads a property directly if an <code>attr</code> is provided, otherwise
returns the “real” data object itself.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		__get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( attr )</span> </span>{
			<span class="hljs-keyword">return</span> attr ? <span class="hljs-keyword">this</span>._data[attr] : <span class="hljs-keyword">this</span>._data;
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Sets <code>attr</code> prop as value on this object where.
<code>attr</code> - Is a string of properties or an array  of property values.
<code>value</code> - The raw value to set.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		_set: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( attr, value, keepKey)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Convert <code>attr</code> to attr parts (if it isn’t already).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> parts = attrParts(attr, keepKey),</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>The immediate prop we are setting.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				prop = parts.shift(),</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>The current value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				current = <span class="hljs-keyword">this</span>.__get(prop);</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>If we have an <code>object</code> and remaining parts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> ( canMakeObserve(current) &amp;&amp; parts.length ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>That <code>object</code> should set it (this might need to call attr).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				current._set(parts, value)
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!parts.length ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>We’re in “real” set territory.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.__convert){
					value = <span class="hljs-keyword">this</span>.__convert(prop, value)
				}
				<span class="hljs-keyword">this</span>.__set(prop, value, current)
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">throw</span> <span class="hljs-string">"can.Observe: Object does not exist"</span>
			}
		},
		__set : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(prop, value, current)</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Otherwise, we are setting it on this <code>object</code>.
TODO: Check if value is object and transform
are we changing the value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> ( value !== current ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>Check if we are adding this for the first time —
if we are, we need to create an <code>add</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> changeType = <span class="hljs-keyword">this</span>.__get().hasOwnProperty(prop) ? <span class="hljs-string">"set"</span> : <span class="hljs-string">"add"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>Set the value on data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>.___set(prop,</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>If we are getting an object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				canMakeObserve(value) ?</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Hook it up to send event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				hookupBubble(value, prop, <span class="hljs-keyword">this</span>) :</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Value is normal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				value);

				<span class="hljs-keyword">if</span>(changeType == <span class="hljs-string">"add"</span>){</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>If there is no current value, let others know that
the the number of keys have changed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					
					Observe.triggerBatch(<span class="hljs-keyword">this</span>, <span class="hljs-string">"__keys"</span>, <span class="hljs-literal">undefined</span>);
					
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p><code>batchTrigger</code> the change event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>._triggerChange(prop, changeType, value, current);</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Observe.triggerBatch(this, prop, [value, current]);
If we can stop listening to our old value, do it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				current &amp;&amp; unhookup([current], <span class="hljs-keyword">this</span>._cid);
			}

		},</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Directly sets a property on this <code>object</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		___set: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( prop, val )</span> </span>{
			<span class="hljs-keyword">this</span>._data[prop] = val;</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Add property directly for easy writing.
Check if its on the <code>prototype</code> so we don’t overwrite methods like <code>attrs</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!(prop <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.constructor.prototype)) {
				<span class="hljs-keyword">this</span>[prop] = val
			}
		},

		<span class="hljs-comment">/**
		 * @function can.Observe.prototype.bind bind
		 * @description Bind event handlers to an Observe.
		 * 
		 * @signature `observe.bind(eventType, handler)`
		 * 
		 * @param {String} eventType the type of event to bind this handler to
		 * @param {Function} handler the handler to be called when this type of event fires
		 * The signature of the handler depends on the type of event being bound. See below
		 * for details.
		 * @return {can.Observe} this Observe, for chaining
		 * 
		 * @body
		 * `bind` binds event handlers to property changes on `can.Observe`s. When you change
		 * a property using `attr`, two events are fired on the Observe, allowing other parts
		 * of your application to observe the changes to the object.
		 *
		 * ## The _change_ event
		 * 
		 * The first event that is fired is the _change_ event. The _change_ event is useful
		 * if you want to react to all changes on an Observe.
		 *
		 * @codestart
		 * var o = new can.Observe({});
		 * o.bind('change', function(ev, attr, how, newVal, oldVal) {
		 *     console.log('Something changed.');
		 * });
		 * @codeend
		 * 
		 * The parameters of the event handler for the _change_ event are:
		 *
		 * - _ev_ The event object.
		 * - _attr_ Which property changed.
		 * - _how_ Whether the property was added, removed, or set. Possible values are `'add'`, `'remove'`, or `'set'`.
		 * - _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.
		 * - _oldVal_ Thishe value of the property before the change. `oldVal` will be `undefined` if the property was added.
		 * 
		 * Here is a concrete tour through the _change_ event handler's arguments:
		 * 
		 * @codestart
		 * var o = new can.Observe({});
		 * o.bind('change', function(ev, attr, how, newVal, oldVal) {
		 *     console.log(ev + ', ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);
		 * });
		 * 
		 * o.attr('a', 'Alexis'); // [object Object], a, add, Alexis, undefined
		 * o.attr('a', 'Adam');   // [object Object], a, set, Adam, Alexis
		 * o.attr({
		 *     'a': 'Alice',      // [object Object], a, set, Alice, Adam
		 *     'b': 'Bob'         // [object Object], b, add, Bob, undefined
		 * });
		 * o.removeAttr('a');     // [object Object], a, remove, undefined, Alice
		 * @codeend
		 *
		 * (See also `[can.Observe::removeAttr removeAttr]`, which removes properties).
		 * 
		 * ## The _property name_ event
		 * 
		 * The second event that is fired is an event whose type is the same as the changed
		 * property's name. This event is useful for noticing changes to a specific property.
		 *
		 * @codestart
		 * var o = new can.Observe({});
		 * o.bind('a', function(ev, newVal, oldVal) {
		 *     console.log('The value of a changed.');
		 * });
		 * @codeend
		 * 
		 * The parameters of the event handler for the _property name_ event are:
		 *
		 * - _ev_ The event object.
		 * - _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.
		 * - _oldVal_ The value of the property before the change. `oldVal` will be `undefined` if the property was added.
		 * 
		 * Here is a concrete tour through the _property name_ event handler's arguments:
		 * 
		 * @codestart
		 * var o = new can.Observe({});
		 * o.bind('a', function(ev, newVal, oldVal) {
		 *     console.log(ev + ', ' + newVal + ', ' + oldVal);
		 * });
		 * 
		 * o.attr('a', 'Alexis'); // [object Object], Alexis, undefined
		 * o.attr('a', 'Adam');   // [object Object], Adam, Alexis
		 * o.attr({
		 *     'a': 'Alice',      // [object Object], Alice, Adam
		 *     'b': 'Bob' 
		 * });
		 * o.removeAttr('a');     // [object Object], undefined, Alice
		 * @codeend
		 *
		 * ## See also
		 * 
		 * More information about changing properties on Observes can be found under
		 * [can.Observe.prototype.attr attr].
		 * 
		 * For a more specific way to changes on Observes, see the [can.Observe.delegate] plugin.
		 */</span>
		bind: can.bindAndSetup,
		<span class="hljs-comment">/**
		 * @function can.Observe.prototype.unbind unbind
		 * @description Unbind event handlers from an Observe.
		 * @signature `observe.unbind(eventType[, handler])`
		 * @param {String} eventType the type of event to unbind, exactly as passed to `bind`
		 * @param {Function} [handler] the handler to unbind
		 *
		 * @body
		 * `unbind` unbinds event handlers previously bound with [can.Observe.prototype.bind `bind`].
		 * If no _handler_ is passed, all handlers for the given event type will be unbound.
		 *
		 * @codestart
		 * var i = 0,
		 *     increaseBy2 = function() { i += 2; },
		 *     increaseBy3 = function() { i += 3; },
		 *     o = new can.Observe();
		 *
		 * o.bind('change', increaseBy2);
		 * o.bind('change', increaseBy3);
		 * o.attr('a', 'Alice');
		 * i; // 5
		 * 
		 * o.unbind('change', increaseBy2);
		 * o.attr('b', 'Bob');
		 * i; // 8
		 *
		 * o.unbind('change');
		 * o.attr('e', 'Eve');
		 * i; // 8
		 * @codeend
		 */</span>
		unbind: can.unbindAndTeardown,
		<span class="hljs-comment">/**
		 * @function can.Observe.prototype.serialize serialize
		 * @description Serialize this object to something that
		 * can be passed to `JSON.stringify`.
		 * @signature `observe.serialize()`
		 * 
		 * 
		 * Get the serialized Object form of the observe.  Serialized
		 * data is typically used to send back to a server.
		 * 
		 *     o.serialize() //-&gt; { name: 'Justin' }
		 *     
		 * Serialize currently returns the same data 
		 * as [can.Observe.prototype.attrs].  However, in future
		 * versions, serialize will be able to return serialized
		 * data similar to [can.Model].  The following will work:
		 * 
		 *     new Observe({time: new Date()})
		 *       .serialize() //-&gt; { time: 1319666613663 }
		 * 
		 * @return {Object} a JavaScript Object that can be 
		 * serialized with `JSON.stringify` or other methods. 
		 * 
		 */</span>
		serialize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
			<span class="hljs-keyword">return</span> serialize(<span class="hljs-keyword">this</span>, <span class="hljs-string">'serialize'</span>, {});
		},
		<span class="hljs-comment">/**
		 * @hide
		 * Set multiple properties on the observable
		 * @param {Object} props
		 * @param {Boolean} remove true if you should remove properties that are not in props
		 */</span>
		_attrs: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( props, remove )</span> </span>{

			<span class="hljs-keyword">if</span> ( props === <span class="hljs-literal">undefined</span> ) {
				<span class="hljs-keyword">return</span> serialize(<span class="hljs-keyword">this</span>, <span class="hljs-string">'attr'</span>, {})
			}

			props = can.extend({}, props);
			<span class="hljs-keyword">var</span> prop,
				self = <span class="hljs-keyword">this</span>,
				newVal;
			Observe.startBatch();
			<span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(curVal, prop)</span></span>{
				newVal = props[prop];</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>If we are merging…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> ( newVal === <span class="hljs-literal">undefined</span> ) {
					remove &amp;&amp; self.removeAttr(prop);
					<span class="hljs-keyword">return</span>;
				}
				
				<span class="hljs-keyword">if</span>(self.__convert){
					newVal = self.__convert(prop, newVal)
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>if we’re dealing with models, want to call _set to let converter run</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span>( newVal <span class="hljs-keyword">instanceof</span> can.Observe ) {
					self.__set(prop, newVal, curVal)</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>if its an object, let attr merge</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( canMakeObserve(curVal) &amp;&amp; canMakeObserve(newVal) &amp;&amp; curVal.attr ) {
					curVal.attr(newVal, remove)</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>otherwise just set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( curVal != newVal ) {
					self.__set(prop, newVal, curVal)
				}

				<span class="hljs-keyword">delete</span> props[prop];
			})</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>Add remaining props.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> props ) {
				newVal = props[prop];
				<span class="hljs-keyword">this</span>._set(prop, newVal, <span class="hljs-literal">true</span>)
			}
			Observe.stopBatch()
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * @function can.Observe.prototype.compute compute
		 * @description Make a can.compute from an observable property.
		 * @signature `observe.compute(attrName)`
		 * @param {String} attrName the property to bind to
		 * @return {can.compute} a [can.compute] bound to _attrName_
		 *
		 * @body
		 * `compute` is a convenience method for making computes from properties
		 * of Observes. More information about computes can be found under [can.compute].
		 *
		 * @codestart
		 * var observe = new can.Observe({a: 'Alexis'});
		 * var name = observe.compute('a');
		 * name.bind('change', function(ev, nevVal, oldVal) {
		 *     console.log('a changed from ' + oldVal + 'to' + newName + '.');
		 * });
		 *
		 * name(); // 'Alexis'
		 * 
		 * observe.attr('a', 'Adam'); // 'a changed from Alexis to Adam.'
		 * name(); // 'Adam'
		 *
		 * name('Alice'); // 'a changed from Adam to Alice.'
		 * name(); // 'Alice'
		 */</span>
		compute: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(prop)</span> </span>{
			<span class="hljs-keyword">return</span> can.compute(<span class="hljs-keyword">this</span>,prop);
		}
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>Helpers for <code>observable</code> lists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> splice = [].splice,
		<span class="hljs-comment">/**
		 * @constructor can.Observe.List
		 * @inherits can.Observe
		 * @download can/observe
		 * @test can/observe/qunit.html
		 * @parent canjs
		 * 
		 * Use for observable array-like objects.
		 * 
		 * @signature `new can.Observe.List([array])`
		 * 
		 * Create an observable array-like object.
		 * 
		 * @param {Array} [array] items to seed the List with
		 * @return {can.Observe.List} an instance of `can.Observe.List` with the elements from _array_
		 * 
		 * @signature `can.Observe.List([name,] [staticProperties,] instanceProperties)`
		 * 
		 * Creates a new extended constructor function. 
		 *     
		 * This is deprecated. In CanJS 1.2, by default, calling the constructor function
		 * without `new` will create a `new` instance. Use [can.Construct.extend can.Observe.extend] 
		 * instead of calling the constructor to extend.
		 * 
		 * @body
		 * 
		 * ## Working with Lists
		 *
		 * `can.Observe.List` extends `[can.Observe]`, so all the ways that you're used to working with
		 * Observes also work here, including [can.Observe.prototype.bind bind], [can.Observe.prototype.unbind unbind],
		 * and [can.Observe.prototype.each each]. And just as you can directly read properties normally
		 * off of an Observe, you can use array accessors ([]) to read elements directly off of a List.
		 *
		 * The one function of `can.Observe` that works slightly differently is `attr`. As expected when working with
		 * arrays, top-level keys passed into `attr` are required to be numeric. (Strings may still be used when getting
		 * or modifying deep properties). Any top-level keys that are non-numeric are ignored. In addition, as might be
		 * expected, a call to argument-less `attr` returns an array instead of an object.
		 *
		 * Just as you shouldn't set properties of an Observe directly, you shouldn't change elements
		 * of a List directly. Always use `attr` to set the elements of a List, or use [can.Observe.List.prototype.push push],
		 * [can.Observe.List.prototype.pop pop], [can.Observe.List.prototype.shift shift], [can.Observe.List.prototype.unshift unshift], or [can.Observe.List.prototype.splice splice].
		 *
		 * Here is a tour through the forms of `can.Observe.List`'s `attr` that parallels the one found under [can.Observe.prototype.attr attr]:
		 *
		 * @codestart
		 * var people = new can.Observe.List(['Alex', 'Bill']);
		 *
		 * // set an element:
		 * people.attr(0, 'Adam');
		 * people[0] = 'Adam'; // don't do this!
		 *
		 * // get an element:
		 * people.attr(0); // 'Adam'
		 * people[0]; // 'Adam'
		 *
		 * // get all elements:
		 * people.attr(); // ['Adam', 'Bill']
		 *
		 * // extend the array:
		 * people.attr(4, 'Charlie');
		 * people.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']
		 *
		 * // merge the elements:
		 * people.attr(['Alice', 'Bob', 'Eve']);
		 * people.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']
		 * @codeend
		 *
		 * ## Listening to changes
		 *
		 * As with `can.Observe`s, the real power of observable arrays comes from being able to
		 * react to changes in the member elements of the array. Lists emit five types of events:
		 * - the _change_ event fires on every change to a List.
		 * - the _set_ event is fired when an element is set.
		 * - the _add_ event is fired when an element is added to the List.
		 * - the _remove_ event is fired when an element is removed from the List.
		 * - the _length_ event is fired when the length of the List changes.
		 *
		 * This example presents a brief concrete survey of the times these events are fired:
		 *
		 * @codestart
		 * var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);
		 *
		 * list.bind('change', function() { console.log('An element changed.'); });
		 * list.bind('set', function() { console.log('An element was set.'); });
		 * list.bind('add', function() { console.log('An element was added.'); });
		 * list.bind('remove', function() { console.log('An element was removed.'); });
		 * list.bind('length', function() { console.log('The length of the list changed.'); });
		 *
		 * list.attr(0, 'Alexis'); // 'An element changed.'
		 *                         // 'An element was set.'
		 *
		 * list.attr(3, 'Xerxes'); // 'An element changed.'
		 *                         // 'An element was added.'
		 *                         // 'The length of the list was changed.'
		 *
		 * list.attr(['Adam', 'Bill']); // 'An element changed.'
		 *                              // 'An element was set.'
		 *                              // 'An element was changed.'
		 *                              // 'An element was set.'
		 *
		 * list.pop(); // 'An element changed.'
		 *             // 'An element was removed.'
		 *             // 'The length of the list was changed.'
		 * @codeend
		 *
		 * More information about binding to these events can be found under [can.Observe.List.prototype.attr attr].
		 */</span>
			list = Observe(
	<span class="hljs-comment">/**
	 * @prototype
	 */</span>
	{
		setup: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( instances, options )</span> </span>{
			<span class="hljs-keyword">this</span>.length = <span class="hljs-number">0</span>;
			can.cid(<span class="hljs-keyword">this</span>, <span class="hljs-string">".observe"</span>)
			<span class="hljs-keyword">this</span>._init = <span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span>( can.isDeferred(instances) ) {
				<span class="hljs-keyword">this</span>.replace(instances)
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">this</span>.push.apply(<span class="hljs-keyword">this</span>, can.makeArray(instances || []));
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>this change needs to be ignored</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>.bind(<span class="hljs-string">'change'</span>+<span class="hljs-keyword">this</span>._cid,can.proxy(<span class="hljs-keyword">this</span>._changes,<span class="hljs-keyword">this</span>));
			can.extend(<span class="hljs-keyword">this</span>, options);
			<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._init;
		},
		_triggerChange: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attr, how, newVal, oldVal)</span></span>{
			
			Observe.prototype._triggerChange.apply(<span class="hljs-keyword">this</span>,<span class="hljs-built_in">arguments</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p><code>batchTrigger</code> direct add and remove events…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> ( !~ attr.indexOf(<span class="hljs-string">'.'</span>)){
				
				<span class="hljs-keyword">if</span>( how === <span class="hljs-string">'add'</span> ) {
					Observe.triggerBatch(<span class="hljs-keyword">this</span>, how, [newVal,+attr]);
					Observe.triggerBatch(<span class="hljs-keyword">this</span>,<span class="hljs-string">'length'</span>,[<span class="hljs-keyword">this</span>.length]);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( how === <span class="hljs-string">'remove'</span> ) {
					Observe.triggerBatch(<span class="hljs-keyword">this</span>, how, [oldVal, +attr]);
					Observe.triggerBatch(<span class="hljs-keyword">this</span>,<span class="hljs-string">'length'</span>,[<span class="hljs-keyword">this</span>.length]);
				} <span class="hljs-keyword">else</span> {
					Observe.triggerBatch(<span class="hljs-keyword">this</span>,how,[newVal, +attr])
				}
				
			}
			
		},
		__get : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attr)</span></span>{
			<span class="hljs-keyword">return</span> attr ? <span class="hljs-keyword">this</span>[attr] : <span class="hljs-keyword">this</span>;
		},
		___set : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attr, val)</span></span>{
			<span class="hljs-keyword">this</span>[attr] = val;
			<span class="hljs-keyword">if</span>(+attr &gt;= <span class="hljs-keyword">this</span>.length){
				<span class="hljs-keyword">this</span>.length = (+attr+<span class="hljs-number">1</span>)
			}
		},
		_each: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
			<span class="hljs-keyword">var</span> data = <span class="hljs-keyword">this</span>.__get();
			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span>; i &lt; data.length; i++){
				callback(data[i],i)
			}
		},
		_bindsetup: makeBindSetup(<span class="hljs-string">"*"</span>),</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Returns the serialized form of this list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Returns the serialized form of this list.
		 */</span>
		serialize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
			<span class="hljs-keyword">return</span> serialize(<span class="hljs-keyword">this</span>, <span class="hljs-string">'serialize'</span>, []);
		},
		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.each each
		 * @parent can.Observe.List.prototype
		 * @description Call a function on each element of a List.
		 * @signature `list.each( callback(item, index) )`
		 * 
		 * `each` iterates through the Observe, calling a function
		 * for each element.
		 * 
		 * @param {function(*, Number)} callback the function to call for each element
		 * The value and index of each element will be passed as the first and second
		 * arguments, respectively, to the callback. If the callback returns false,
		 * the loop will stop.
		 * 
		 * @return {can.Observe.List} this List, for chaining
		 *
		 * @body
		 * @codestart
		 * var i = 0;
		 * new can.Observe([1, 10, 100]).each(function(element, index) {
		 *     i += element;
		 * });
		 * 
		 * i; // 111
		 * 
		 * i = 0;
		 * new can.Observe([1, 10, 100]).each(function(element, index) {
		 *     i += element;
		 *     if(index &gt;= 1) {
		 *         return false;
		 *     }
		 * });
		 * 
		 * i; // 11
		 * @codeend
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.splice splice
		 * @description Insert and remove elements from a List.
		 * @signature `list.splice(index[, howMany[, ...newElements]])`
		 * @param {Number} index where to start removing or inserting elements
		 * 
		 * @param {Number} [howMany] the number of elements to remove
		 * If _howMany_ is not provided, `splice` will all elements from `index` to the end of the List.
		 *
		 * @param {*} newElements elements to insert into the List
		 *
		 * @return {Array} the elements removed by `splice`
		 *
		 * @body
		 * `splice` lets you remove elements from and insert elements into a List.
		 *
		 * This example demonstrates how to do surgery on a list of numbers:
		 * 
		 * @codestart
		 * var list = new can.Observe.List([0, 1, 2, 3]);
		 *
		 * // starting at index 2, remove one element and insert 'Alice' and 'Bob':
		 * list.splice(2, 1, 'Alice', 'Bob');
		 * list.attr(); // [0, 1, 'Alice', 'Bob', 3]
		 * @codeend
		 *
		 * ## Events
		 *
		 * `splice` causes the List it's called on to emit _change_ events,
		 * _add_ events, _remove_ events, and _length_ events. If there are
		 * any elements to remove, a _change_ event, a _remove_ event, and a
		 * _length_ event will be fired. If there are any elements to insert, a
		 * separate _change_ event, an _add_ event, and a separate _length_ event
		 * will be fired. 
		 *
		 * This slightly-modified version of the above example should help
		 * make it clear how `splice` causes events to be emitted:
		 *
		 * @codestart
		 * var list = new can.Observe.List(['a', 'b', 'c', 'd']);
		 * list.bind('change', function(ev, attr, how, newVals, oldVals) {
	     *     console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);
		 * });
		 * list.bind('add', function(ev, newVals, where) {
	     *     console.log('add: ' + newVals + ', ' + where);
		 * });
		 * list.bind('remove', function(ev, oldVals, where) {
	     *     console.log('remove: ' + oldVals + ', ' + where);
		 * });
		 * list.bind('length', function(ev, length) {
	     *     console.log('length: ' + length + ', ' + this.attr());
		 * });
		 *
		 * // starting at index 2, remove one element and insert 'Alice' and 'Bob':
		 * list.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']
		 *                                    // remove: ['c'], 2
		 *                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']
		 *                                    // change: 2, 'add', ['Alice', 'Bob'], ['c']
		 *                                    // add: ['Alice', 'Bob'], 2
		 *                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']
		 * @codeend
		 *
		 * More information about binding to these events can be found under [can.Observe.List.prototype.attr attr].
		 */</span>
		splice: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( index, howMany )</span> </span>{
			<span class="hljs-keyword">var</span> args = can.makeArray(<span class="hljs-built_in">arguments</span>),
				i;

			<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">2</span>; i &lt; args.length; i++ ) {
				<span class="hljs-keyword">var</span> val = args[i];
				<span class="hljs-keyword">if</span> ( canMakeObserve(val) ) {
					args[i] = hookupBubble(val, <span class="hljs-string">"*"</span>, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.constructor.Observe, <span class="hljs-keyword">this</span>.constructor)
				}
			}
			<span class="hljs-keyword">if</span> ( howMany === <span class="hljs-literal">undefined</span> ) {
				howMany = args[<span class="hljs-number">1</span>] = <span class="hljs-keyword">this</span>.length - index;
			}
			<span class="hljs-keyword">var</span> removed = splice.apply(<span class="hljs-keyword">this</span>, args);
			can.Observe.startBatch();
			<span class="hljs-keyword">if</span> ( howMany &gt; <span class="hljs-number">0</span> ) {
				<span class="hljs-keyword">this</span>._triggerChange(<span class="hljs-string">""</span>+index, <span class="hljs-string">"remove"</span>, <span class="hljs-literal">undefined</span>, removed);
				unhookup(removed, <span class="hljs-keyword">this</span>._cid);
			}
			<span class="hljs-keyword">if</span> ( args.length &gt; <span class="hljs-number">2</span> ) {
				<span class="hljs-keyword">this</span>._triggerChange(<span class="hljs-string">""</span>+index, <span class="hljs-string">"add"</span>, args.slice(<span class="hljs-number">2</span>), removed);
			}
			can.Observe.stopBatch();
			<span class="hljs-keyword">return</span> removed;
		},
		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.attr attr
		 * @description Get or set elements in a List.
		 * @signature `list.attr()`
		 * 
		 * Gets a collection of all the elements in this `can.Observe.List`.
		 * 
		 * @return {Array} array with all the elements in this List.
		 * 
		 * @body
		 * `attr` gets or sets elements on the `can.Observe.List` it's called on. Here's a tour through
		 * how all of its forms work:
		 * 
		 * ## Deep properties
		 * 
		 * `attr` can also set and read deep properties. All you have to do is specify
		 * the property name as you normally would if you weren't using `attr`.
		 * 
		 * @codestart
		 * var people = new can.Observe.List([{name: 'Alex'}, {name: 'Bob'}]);
		 * 
		 * // set a property:
		 * people.attr('0.name', 'Alice');
		 * 
		 * // get a property:
		 * people.attr('0.name');  // 'Alice'
		 * people[0].attr('name'); // 'Alice'
		 *
		 * // get all properties:
		 * people.attr(); // [{name: 'Alice'}, {name: 'Bob'}]
		 * @codeend
		 *
		 * The discussion of deep properties under `[can.Observe.prototype.attr attr]` may also
		 * be enlightening.
		 *
		 * ## Events
		 *
		 * `can.Observe.List`s emit five types of events in response to changes. They are:
		 * - the _change_ event fires on every change to a List.
		 * - the _set_ event is fired when an element is set.
		 * - the _add_ event is fired when an element is added to the List.
		 * - the _remove_ event is fired when an element is removed from the List.
		 * - the _length_ event is fired when the length of the List changes.
		 *
		 * ## The _change_ event
		 * 
		 * The first event that is fired is the _change_ event. The _change_ event is useful
		 * if you want to react to all changes on an List.
		 *
		 * @codestart
		 * var list = new can.Observe.List([]);
		 * list.bind('change', function(ev, index, how, newVal, oldVal) {
		 *     console.log('Something changed.');
		 * });
		 * @codeend
		 * 
		 * The parameters of the event handler for the _change_ event are:
		 *
		 * - _ev_ The event object.
		 * - _index_ Where the change took place.
		 * - _how_ Whether elements were added, removed, or set.
		 * Possible values are `'add'`, `'remove'`, or `'set'`.
		 * - _newVal_ The elements affected after the change
		 *  _newVal_ will be a single value when an index is set, an Array when elements
		 * were added, and `undefined` if elements were removed.
		 * - _oldVal_ The elements affected before the change.
		 * _newVal_ will be a single value when an index is set, an Array when elements
		 * were removed, and `undefined` if elements were added.
		 * 
		 * Here is a concrete tour through the _change_ event handler's arguments:
		 * 
		 * @codestart
		 * var list = new can.Observe.List();
		 * list.bind('change', function(ev, index, how, newVal, oldVal) {
		 *     console.log(ev + ', ' + index + ', ' + how + ', ' + newVal + ', ' + oldVal);
		 * });
		 * 
		 * list.attr(['Alexis', 'Bill']); // [object Object], 0, add, ['Alexis', 'Bill'], undefined
		 * list.attr(2, 'Eve');           // [object Object], 2, add, Eve, undefined
		 * list.attr(0, 'Adam');          // [object Object], 0, set, Adam, Alexis
		 * list.attr(['Alice', 'Bob']);   // [object Object], 0, set, Alice, Adam
		 *                                // [object Object], 1, set, Bob, Bill
		 * list.removeAttr(1);            // [object Object], 1, remove, undefined, Bob
		 * @codeend
		 *
		 * ## The _set_ event
		 * 
		 * _set_ events are fired when an element at an index that already exists in the List is
		 * modified. Actions can cause _set_ events to fire never also cause _length_ events
		 * to fire (although some functions, such as `[can.Observe.List.prototype.splice splice]`
		 * may cause unrelated sets of events to fire after being batched).
		 * 
		 * The parameters of the event handler for the _set_ event are:
		 *
		 * - _ev_ The event object.
		 * - _newVal_ The new value of the element.
		 * - _index_ where the set took place.
		 *
		 * Here is a concrete tour through the _set_ event handler's arguments:
		 * 
		 * @codestart
		 * var list = new can.Observe.List();
		 * list.bind('set', function(ev, newVal, index) {
		 *     console.log(newVal + ', ' + index);
		 * });
		 * 
		 * list.attr(['Alexis', 'Bill']);
		 * list.attr(2, 'Eve');          
		 * list.attr(0, 'Adam');          // Adam, 0
		 * list.attr(['Alice', 'Bob']);   // Alice, 0
		 *                                // Bob, 1
		 * list.removeAttr(1);            
		 * @codeend
		 *
		 * ## The _add_ event
		 * 
		 * _add_ events are fired when elements are added or inserted
		 * into the List.
		 * 
		 * The parameters of the event handler for the _add_ event are:
		 *
		 * - _ev_ The event object.
		 * - _newElements_ The new elements.
		 * If more than one element is added, _newElements_ will be an array.
		 * Otherwise, it is simply the new element itself.
		 * - _index_ Where the add or insert took place.
		 *
		 * Here is a concrete tour through the _add_ event handler's arguments:
		 * 
		 * @codestart
		 * var list = new can.Observe.List();
		 * list.bind('add', function(ev, newElements, index) {
		 *     console.log(newElements + ', ' + index);
		 * });
		 * 
		 * list.attr(['Alexis', 'Bill']); // ['Alexis', 'Bill'], 0
		 * list.attr(2, 'Eve');           // Eve, 2
		 * list.attr(0, 'Adam');          
		 * list.attr(['Alice', 'Bob']);   
		 *                                
		 * list.removeAttr(1);            
		 * @codeend
		 *
		 * ## The _remove_ event
		 * 
		 * _remove_ events are fired when elements are removed from the list.
		 * 
		 * The parameters of the event handler for the _remove_ event are:
		 *
		 * - _ev_ The event object.
		 * - _removedElements_ The removed elements.
		 * If more than one element was removed, _removedElements_ will be an array.
		 * Otherwise, it is simply the element itself.
		 * - _index_ Where the removal took place.
		 *
		 * Here is a concrete tour through the _remove_ event handler's arguments:
		 * 
		 * @codestart
		 * var list = new can.Observe.List();
		 * list.bind('remove', function(ev, removedElements, index) {
		 *     console.log(removedElements + ', ' + index);
		 * });
		 * 
		 * list.attr(['Alexis', 'Bill']); 
		 * list.attr(2, 'Eve');           
		 * list.attr(0, 'Adam');          
		 * list.attr(['Alice', 'Bob']);   
		 *                                
		 * list.removeAttr(1);            // Bob, 1
		 * @codeend
		 *
		 * ## The _length_ event
		 * 
		 * _length_ events are fired whenever the list changes.
		 * 
		 * The parameters of the event handler for the _length_ event are:
		 *
		 * - _ev_ The event object.
		 * - _length_ The current length of the list.
		 *
		 * If events were batched when the _length_ event was triggered, _length_
		 * will have the length of the list when `stopBatch` was called. Because
		 * of this, you may recieve multiple _length_ events with the same
		 * _length_ parameter.
		 * 
		 * Here is a concrete tour through the _length_ event handler's arguments:
		 * 
		 * @codestart
		 * var list = new can.Observe.List();
		 * list.bind('length', function(ev, length) {
		 *     console.log(length);
		 * });
		 * 
		 * list.attr(['Alexis', 'Bill']); // 2
		 * list.attr(2, 'Eve');           // 3
		 * list.attr(0, 'Adam');          
		 * list.attr(['Alice', 'Bob']);   
		 *                                
		 * list.removeAttr(1);            // 2
		 * @codeend
		 */</span>
		_attrs: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( items, remove )</span> </span>{
			<span class="hljs-keyword">if</span> ( items === <span class="hljs-literal">undefined</span> ) {
				<span class="hljs-keyword">return</span> serialize(<span class="hljs-keyword">this</span>, <span class="hljs-string">'attr'</span>, []);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>Create a copy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			items = can.makeArray( items );

      		Observe.startBatch();
			<span class="hljs-keyword">this</span>._updateAttrs(items, remove);
			Observe.stopBatch()
		},

	    _updateAttrs : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( items, remove )</span></span>{
	      <span class="hljs-keyword">var</span> len = <span class="hljs-built_in">Math</span>.min(items.length, <span class="hljs-keyword">this</span>.length);
	
	      <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> prop = <span class="hljs-number">0</span>; prop &lt; len; prop++ ) {
	        <span class="hljs-keyword">var</span> curVal = <span class="hljs-keyword">this</span>[prop],
	          newVal = items[prop];
	
	        <span class="hljs-keyword">if</span> ( canMakeObserve(curVal) &amp;&amp; canMakeObserve(newVal) ) {
	          curVal.attr(newVal, remove)
	        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( curVal != newVal ) {
	          <span class="hljs-keyword">this</span>._set(prop, newVal)
	        } <span class="hljs-keyword">else</span> {
	
	        }
	      }
	      <span class="hljs-keyword">if</span> ( items.length &gt; <span class="hljs-keyword">this</span>.length ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Add in the remaining props.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	        <span class="hljs-keyword">this</span>.push.apply( <span class="hljs-keyword">this</span>, items.slice( <span class="hljs-keyword">this</span>.length ) );
	      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( items.length &lt; <span class="hljs-keyword">this</span>.length &amp;&amp; remove ) {
	        <span class="hljs-keyword">this</span>.splice(items.length)
	      }
	    }
	}),</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>Converts to an <code>array</code> of arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		getArgs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( args )</span> </span>{
			<span class="hljs-keyword">return</span> args[<span class="hljs-number">0</span>] &amp;&amp; can.isArray(args[<span class="hljs-number">0</span>]) ?
				args[<span class="hljs-number">0</span>] :
				can.makeArray(args);
		};</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>Create <code>push</code>, <code>pop</code>, <code>shift</code>, and <code>unshift</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	can.each({
		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.push push
		 * @description Add elements to the end of a list.
		 * @signature `list.push(...elements)`
		 *
		 * `push` adds elements onto the end of a List.]
		 * 
		 * @param {*} elements the elements to add to the List
		 *
		 * @return {Number} the new length of the List
		 *
		 * @body
		 * `push` is fairly straightforward:
		 *
		 * @codestart
		 * var list = new can.Observe.List(['Alice']);
		 *
		 * list.push('Bob', 'Eve');
		 * list.attr(); // ['Alice', 'Bob', 'Eve']
		 * @codeend
		 *
		 * If you have an array you want to concatenate to the end
		 * of the List, you can use `apply`:
		 *
		 * @codestart
		 * var names = ['Bob', 'Eve'],
		 *     list = new can.Observe.List(['Alice']);
		 *
		 * list.push.apply(list, names);
		 * list.attr(); // ['Alice', 'Bob', 'Eve']
		 * @codeend
		 *
		 * ## Events
		 *
		 * `push` causes _change_, _add_, and _length_ events to be fired.
		 *
		 * ## See also
		 *
		 * `push` has a counterpart in [can.Observe.List.prototype.pop pop], or you may be
		 * looking for [can.Observe.List.prototype.unshift unshift] and its counterpart [can.Observe.List.prototype.shift shift].
		 */</span>
		push: <span class="hljs-string">"length"</span>,
		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.unshift unshift
		 * @description Add elements to the beginning of a List.
		 * @signature `list.unshift(...elements)`
		 *
		 * `unshift` adds elements onto the beginning of a List.
		 * 
		 * @param {*} elements the elements to add to the List
		 *
		 * @return {Number} the new length of the List
		 *
		 * @body
		 * `unshift` adds elements to the front of the list in bulk in the order specified:
		 *
		 * @codestart
		 * var list = new can.Observe.List(['Alice']);
		 *
		 * list.unshift('Bob', 'Eve');
		 * list.attr(); // ['Bob', 'Eve', 'Alice']
		 * @codeend
		 *
		 * If you have an array you want to concatenate to the beginning
		 * of the List, you can use `apply`:
		 *
		 * @codestart
		 * var names = ['Bob', 'Eve'],
		 *     list = new can.Observe.List(['Alice']);
		 *
		 * list.push.apply(list, names);
		 * list.attr(); // ['Bob', 'Eve', 'Alice']
		 * @codeend
		 *
		 * ## Events
		 *
		 * `unshift` causes _change_, _add_, and _length_ events to be fired.
		 *
		 * ## See also
		 *
		 * `unshift` has a counterpart in [can.Observe.List.prototype.shift shift], or you may be
		 * looking for [can.Observe.List.prototype.push push] and its counterpart [can.Observe.List.prototype.pop pop].
		 */</span>
		unshift: <span class="hljs-number">0</span>
	},</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>Adds a method
<code>name</code> - The method name.
<code>where</code> - Where items in the <code>array</code> should be added.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( where, name )</span> </span>{
		<span class="hljs-keyword">var</span> orig = [][name]
		list.prototype[name] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>Get the items being added.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> args = [],</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Where we are going to add items.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				len = where ? <span class="hljs-keyword">this</span>.length : <span class="hljs-number">0</span>,
				i = <span class="hljs-built_in">arguments</span>.length,
				res,
				val,
				constructor = <span class="hljs-keyword">this</span>.constructor;</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Go through and convert anything to an <code>observe</code> that needs to be converted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">while</span>(i--){
				val = <span class="hljs-built_in">arguments</span>[i];
				args[i] =  canMakeObserve(val) ?
					hookupBubble(val, <span class="hljs-string">"*"</span>, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.constructor.Observe, <span class="hljs-keyword">this</span>.constructor) :
					val;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>Call the original method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			res = orig.apply(<span class="hljs-keyword">this</span>, args);

			<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.comparator || args.length ) {

				<span class="hljs-keyword">this</span>._triggerChange(<span class="hljs-string">""</span>+len, <span class="hljs-string">"add"</span>, args, <span class="hljs-literal">undefined</span>);
			}
						
			<span class="hljs-keyword">return</span> res;
		}
	});

	can.each({
		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.pop pop
		 * @description Remove an element from the end of a List.
		 * @signature `list.pop()`
		 *
		 * `push` removes an element from the end of a List.
		 * 
		 * @return {*} the element just popped off the List, or `undefined` if the List was empty
		 *
		 * @body
		 * `pop` is the opposite action from `[can.Observe.List.prototype.push push]`:
		 *
		 * @codestart
		 * var list = new can.Observe.List(['Alice']);
		 *
		 * list.push('Bob', 'Eve');
		 * list.attr(); // ['Alice', 'Bob', 'Eve']
		 * 
		 * list.pop(); // 'Eve'
		 * list.pop(); // 'Bob'
		 * list.pop(); // 'Alice'
		 * list.pop(); // undefined
		 * @codeend
		 *
		 * ## Events
		 *
		 * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty
		 * when it is called.
		 *
		 * ## See also
		 *
		 * `pop` has its counterpart in [can.Observe.List.prototype.push push], or you may be
		 * looking for [can.Observe.List.prototype.unshift unshift] and its counterpart [can.Observe.List.prototype.shift shift].
		 */</span>
		pop: <span class="hljs-string">"length"</span>,
		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.shift shift
		 * @description Remove en element from the front of a list.
		 * @signature `list.shift()`
		 *
		 * `shift` removes an element from the beginning of a List.
		 *
		 * @return {*} the element just shifted off the List, or `undefined` if the List is empty
		 *
		 * @body
		 * `shift` is the opposite action from `[can.Observe.List.unshift unshift]`:
		 *
		 * @codestart
		 * var list = new can.Observe.List(['Alice']);
		 *
		 * list.unshift('Bob', 'Eve');
		 * list.attr(); // ['Bob', 'Eve', 'Alice']
		 *
		 * list.shift(); // 'Bob'
		 * list.shift(); // 'Eve'
		 * list.shift(); // 'Alice'
		 * list.shift(); // undefined
		 * @codeend
		 *
		 * ## Events
		 *
		 * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty
		 * when it is called.
		 *
		 * ## See also
		 *
		 * `shift` has a counterpart in [can.Observe.List.prototype.unshift unshift], or you may be
		 * looking for [can.Observe.List.prototype.push push] and its counterpart [can.Observe.List.prototype.pop pop].
		 */</span>
		shift: <span class="hljs-number">0</span>
	},</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Creates a <code>remove</code> type method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( where, name )</span> </span>{
		list.prototype[name] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
			
			<span class="hljs-keyword">var</span> args = getArgs(<span class="hljs-built_in">arguments</span>),
				len = where &amp;&amp; <span class="hljs-keyword">this</span>.length ? <span class="hljs-keyword">this</span>.length - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;


			<span class="hljs-keyword">var</span> res = [][name].apply(<span class="hljs-keyword">this</span>, args)</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Create a change where the args are
<code>len</code> - Where these items were removed.
<code>remove</code> - Items removed.
<code>undefined</code> - The new values (there are none).
<code>res</code> - The old, removed values (should these be unbound).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>._triggerChange(<span class="hljs-string">""</span>+len, <span class="hljs-string">"remove"</span>, <span class="hljs-literal">undefined</span>, [res])

			<span class="hljs-keyword">if</span> ( res &amp;&amp; res.unbind ) {
				res.unbind(<span class="hljs-string">"change"</span> + <span class="hljs-keyword">this</span>._cid)
			}
			<span class="hljs-keyword">return</span> res;
		}
	});
	
	can.extend(list.prototype, {
		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.indexOf indexOf
		 * @description Look for an item in a List.
		 * @signature `list.indexOf(item)`
		 *
		 * `indexOf` finds the position of a given item in the List.
		 *
		 * @param {*} item the item to find
		 *
		 * @return {Number} the position of the item in the List, or -1 if the item is not found.
		 *
		 * @body
		 * @codestart
		 * var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);
		 * list.indexOf('Alice');   // 0
		 * list.indexOf('Charlie'); // -1
		 * @codeend
		 *
		 * It is trivial to make a `contains`-type function using `indexOf`:
		 *
		 * @codestart
		 * function(list, item) {
		 *     return list.indexOf(item) &gt;= 0;
		 * }
		 * @codeend
		 */</span>
		indexOf: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> </span>{
			<span class="hljs-keyword">this</span>.attr(<span class="hljs-string">'length'</span>)
			<span class="hljs-keyword">return</span> can.inArray(item, <span class="hljs-keyword">this</span>)
		},

		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.join join
		 * @description Join a List's elements into a string.
		 * @signature `list.join(separator)`
		 *
		 * `join` turns a List into a string by inserting _separator_ between the string representations
		 * of all the elements of the List.
		 *
		 * @param {String} separator the string to seperate elements with
		 *
		 * @return {String} the joined string
		 *
		 * @body
		 * @codestart
		 * var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);
		 * list.join(', '); // 'Alice, Bob, Eve'
		 *
		 * var beatles = new can.Observe.List(['John', 'Paul', 'Ringo', 'George']);
		 * beatles.join('&amp;'); // 'John&amp;Paul&amp;Ringo&amp;George'
		 * @codeend
		 */</span>
		join : [].join,
		
		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.reverse reverse
		 * @description Reverse the order of a List.
		 * @signature `list.reverse()`
		 *
		 * `reverse` reverses the elements of the List in place.
		 *
		 * @return {can.Observe.List} the List, for chaining
		 *
		 * @body
		 * @codestart
		 * var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);
		 * var reversedList = list.reverse();
		 *
		 * reversedList.attr(); // ['Eve', 'Bob', 'Alice'];
		 * list === reversedList; // true
		 * @codeend
		 */</span>
		reverse: [].reverse,

		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.slice slice
		 * @description Make a copy of a part of a List.
		 * @signature `list.slice([start[, end]])`
		 *
		 * `slice` creates a copy of a portion of the List.
		 *
		 * @param {Number} [start=0] the index to start copying from
		 *
		 * @param {Number} [end] the first index not to include in the copy
		 * If _end_ is not supplied, `slice` will copy until the end of the list.
		 *
		 * @return {can.Observe.List} a new `can.Observe.List` with the extracted elements
		 *
		 * @body
		 * @codestart
		 * var list = new can.Observe.List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);
		 * var newList = list.slice(1, 4);
		 * newList.attr(); // ['Bob', 'Charlie', 'Daniel']
		 * @codeend
		 *
		 * `slice` is the simplest way to copy a List:
		 * 
		 * @codestart
		 * var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);
		 * var copy = list.slice();
		 *
		 * copy.attr();   // ['Alice', 'Bob', 'Eve']
		 * list === copy; // false
		 * @codeend
		 */</span>
		slice : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
			<span class="hljs-keyword">var</span> temp = <span class="hljs-built_in">Array</span>.prototype.slice.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.constructor( temp );
		},

		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.concat concat
		 * @description Merge many collections together into a List.
		 * @signature `list.concat(...args)`
		 * @param {Array|can.Observe.List|*} args Any number of arrays, Lists, or values to add in
		 * For each parameter given, if it is an Array or a List, each of its elements will be added to
		 * the end of the concatenated List. Otherwise, the parameter itself will be added.
		 *
		 * @body
		 * `concat` makes a new List with the elements of the List followed by the elements of the parameters.
		 *
		 * @codestart
		 * var list = new can.Observe.List();
		 * var newList = list.concat(
		 *     'Alice',
		 *     ['Bob', 'Charlie']),
		 *     new can.Observe.List(['Daniel', 'Eve']),
		 *     {f: 'Francis'}
		 * );
		 * newList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]
		 * @codeend
		 */</span>
		concat : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
			<span class="hljs-keyword">var</span> args = [];
			can.each( can.makeArray( <span class="hljs-built_in">arguments</span> ), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( arg, i )</span> </span>{
				args[i] = arg <span class="hljs-keyword">instanceof</span> can.Observe.List ? arg.serialize() : arg ;
			});
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.constructor(<span class="hljs-built_in">Array</span>.prototype.concat.apply(<span class="hljs-keyword">this</span>.serialize(), args));
		},

		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.forEach forEach
		 * @description Call a function for each element of a List.
		 * @signature `list.forEach(callback[, thisArg])`
		 * @param {function(element, index, list)} callback a function to call with each element of the List
		 * The three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the
		 * current element of the list, and _list_ the List the elements are coming from.
		 * @param {Object} [thisArg] the object to use as `this` inside the callback
		 *
		 * @body
		 * `forEach` calls a callback for each element in the List.
		 *
		 * @codestart
		 * var list = new can.Observe.List([1, 2, 3]);
		 * list.forEach(function(element, index, list) {
		 *     list.attr(index, element * element);
		 * });
		 * list.attr(); // [1, 4, 9]
		 * @codeend
		 */</span>
		forEach : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( cb, thisarg )</span> </span>{
			can.each(<span class="hljs-keyword">this</span>, cb, thisarg || <span class="hljs-keyword">this</span> );
		},

		<span class="hljs-comment">/**
		 * @function can.Observe.List.prototype.replace replace
		 * @description Replace all the elements of a List.
		 * @signature `list.replace(collection)`
		 * @param {Array|can.Observe.List|can.Deferred} collection the collection of new elements to use
		 * If a [can.Deferred] is passed, it must resolve to an `Array` or `can.Observe.List`.
		 * The elements of the list are not actually removed until the Deferred resolves.
		 *
		 * @body
		 * `replace` replaces all the elements of this List with new ones.
		 *
		 * `replace` is especially useful when `can.Observe.List`s are live-bound into `[can.Control]`s,
		 * and you intend to populate them with the results of a `[can.Model]` call:
		 *
		 * @codestart
		 * can.Control({
		 *     init: function() {
		 *         this.list = new Todo.List();
		 *         // live-bind the list into the DOM
		 *         this.element.html(can.view('list.mustache', this.list));
		 *         // when this AJAX call returns, the live-bound DOM will be updated
		 *         this.list.replace(Todo.findAll());
		 *     }
		 * });
		 * @codeend
		 *
		 * Learn more about [can.Model.List making Lists of models].
		 *
		 * ## Events
		 * 
		 * A major difference between `replace` and `attr(newElements, true)` is that `replace` always emits
		 * an_add_ event and a _remove_ event, whereas `attr` will cause _set_ events along an _add_ or _remove_
		 * event if needed. Corresponding _change_ and _length_ events will be fired as well.
		 *
		 * The differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:
		 * @codestart
		 * var attrList = new can.Observe.List(['Alexis', 'Bill']);
		 * attrList.bind('change', function(ev, index, how, newVals, oldVals) {
		 *     console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);
		 * });
		 * 
		 * var replaceList = new can.Observe.List(['Alexis', 'Bill']);
		 * replaceList.bind('change', function(ev, index, how, newVals, oldVals) {
		 *     console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);
		 * });
		 * 
		 * attrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis
		 *                                               // 1, set, Ben, Bill
		 * replaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']
		 *                                               // 0, add, undefined, ['Adam', 'Ben']
		 * 
		 * attrList.attr(['Amber'], true);               // 0, set, Amber, Adam
		 *                                               // 1, remove, undefined, Ben
		 * replaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']
		 *                                               // 0, add, Amber, ['Adam', 'Ben']
		 * 
		 * attrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber
		 *                                               // 1, add, ['Bob', 'Eve'], undefined
		 * replaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber
		 *                                               // 0, add, ['Alice', 'Bob', 'Eve'], Amber
		 * @codeend
		 */</span>
		replace : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(newList)</span> </span>{
			<span class="hljs-keyword">if</span>(can.isDeferred(newList)) {
				newList.then(can.proxy(<span class="hljs-keyword">this</span>.replace, <span class="hljs-keyword">this</span>));
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">this</span>.splice.apply(<span class="hljs-keyword">this</span>, [<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.length].concat(can.makeArray(newList || [])));
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		}
	});

	can.List = Observe.List = list;
	Observe.setup = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
		can.Construct.setup.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>I would prefer not to do it this way. It should
be using the attributes plugin to do this type of conversion.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">this</span>.List = Observe.List({ Observe : <span class="hljs-keyword">this</span> }, {});
	}
	<span class="hljs-keyword">return</span> Observe;
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>

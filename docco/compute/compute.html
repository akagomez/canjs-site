<!DOCTYPE html>

<html>
<head>
  <title>compute.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="compute.html">
                compute.js
              </a>
            
              
              <a class="source" href="compute_benchmark.html">
                compute_benchmark.js
              </a>
            
              
              <a class="source" href="proto_compute.html">
                proto_compute.js
              </a>
            
              
              <a class="source" href="read.html">
                read.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>compute.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/* jshint maxdepth:7*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1 id="can-compute">can.compute</h1>
<p><code>can.compute</code> allows creation of observable values
from the result of a funciton. Any time an observable
value that the function depends on changes, the
function automatically updates. This enables creating
observable data that relies on other sources, potentially
multiple different ones. For instance, a <code>can.compute</code> is
able to:</p>
<ul>
<li>Combine a first and last name into a full name and update when either changes</li>
<li>Calculate the absolute value of an observable number, updating any time the observable number does</li>
<li>Specify complicated behavior for getting and setting a value, as well as how to handle changes</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
steal(<span class="hljs-string">'can/util'</span>, <span class="hljs-string">'can/util/bind'</span>, <span class="hljs-string">'can/util/batch'</span>, <span class="hljs-string">'can/compute/proto_compute.js'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(can, bind)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2 id="reading-helpers">Reading Helpers</h2>
<p>The following methods are used to call a function that relies on
observable data and to track the observable events which should 
be listened to when changes occur.
To do this, <a href="#can-__reading"><code>can.__reading(observable, event)</code></a> is called to
“broadcast” the corresponding event on each read.</p>
<h3 id="observed">Observed</h3>
<p>An “Observed” is an object of observable objects and events that
a function relies on. These objects and events must be listened to
in order to determine when to check a function for updates.
This looks like the following:</p>
<pre><code>{ 
  <span class="hljs-string">"map1|first"</span>: {obj: map, event: <span class="hljs-string">"first"</span>},
  <span class="hljs-string">"map1|last"</span> : {obj: map, event: <span class="hljs-string">"last"</span>}
}
</code></pre><p>Each object-event pair is mapped so no duplicates will be listed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	can.compute = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(getterSetter, context, eventName, bindOnce)</span> </span>{

		<span class="hljs-keyword">var</span> internalCompute = <span class="hljs-keyword">new</span> can.Compute(getterSetter, context, eventName, bindOnce);

		<span class="hljs-keyword">var</span> compute = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val)</span> </span>{
			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length) {
				<span class="hljs-keyword">return</span> internalCompute.set(val);
			}

			<span class="hljs-keyword">return</span> internalCompute.get();
		};

		compute.bind = can.proxy(internalCompute.bind, internalCompute);
		compute.unbind = can.proxy(internalCompute.unbind, internalCompute);
		compute.isComputed = internalCompute.isComputed;
		compute.clone = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ctx)</span> </span>{
			<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> getterSetter === <span class="hljs-string">'function'</span>) {
				context = ctx;
			}

			<span class="hljs-keyword">return</span> can.compute(getterSetter, context, ctx, bindOnce);
		};

		compute.computeInstance = internalCompute;

		<span class="hljs-keyword">return</span> compute;
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Instead of calculating whether anything is listening every time,
use a function to do nothing (which may be overwritten)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> k = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>A list of temporarily bound computes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> computes, unbindComputes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = computes.length; i &lt; len; i++) {
				computes[i].unbind(<span class="hljs-string">'change'</span>, k);
			}
			computes = <span class="hljs-literal">null</span>;
		};</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Binds computes for a moment to retain their value and prevent caching</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	can.compute.temporarilyBind = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(compute)</span> </span>{
		compute.bind(<span class="hljs-string">'change'</span>, k);
		<span class="hljs-keyword">if</span> (!computes) {
			computes = [];
			setTimeout(unbindComputes, <span class="hljs-number">10</span>);
		}
		computes.push(compute);
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Whether a compute is truthy</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	can.compute.truthy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(compute)</span> </span>{
		<span class="hljs-keyword">return</span> can.compute(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
			<span class="hljs-keyword">var</span> res = compute();
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">'function'</span>) {
				res = res();
			}
			<span class="hljs-keyword">return</span> !!res;
		});
	};
	can.compute.async = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(initialValue, asyncComputer, context)</span></span>{
		<span class="hljs-keyword">return</span> can.compute(initialValue, {
			fn: asyncComputer,
			context: context
		});
	};


	can.compute.read = can.Compute.read;


	can.compute.set = can.Compute.set;

	<span class="hljs-keyword">return</span> can.compute;
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
